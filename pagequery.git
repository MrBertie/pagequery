blob
mark :2
data 262
<?php
/**
 * English language file
 *
 * @license    GPL 2 (http://www.gnu.org/licenses/gpl.html)
 * @author     Symon Bent <symonbent@gmail.com>
 */

// custom language strings for the pagequery plugin
$lang['no_results'] = 'No results for the search query: ';

blob
mark :3
data 1587
Insert the pagequery markup wherever you want your list to appear.
--------
E.g.{{pagequery>[query];fulltext;sort=key:direction,key2:direction;group;limit=??;cols=?;inwords;proper}}
--------
Parameters as follows:
1. query: any expression directly after the >; can use all Dokuwiki search options (see manual)
2. fulltext: use a full-text search, instead of page_id only [default]
3. sort: keys to sort by, in order of sorting. Each key can be followed by prefered sorting order
Available keys:
* a, ab, abc          by 1st letter, 2 letters, or 3 letters
* name                by page name (no namespace) [not grouped]
* page|id             by full page id, including namespace [not grouped]
* ns                  by namespace (without page name)
* mdate, cdate        by modified|created dates (full) [not grouped]
* m[year][month][day] by modified [year][month][day]; any combination accepted
* c[year][month][day] by created [year][month][day]; any combination accepted
* creator             by page author
Note: date sort default to descending, string sorts to ascending
4. group: show group headers for each change in sort keys. Note: keys with no duplicated cannot be grouped (i.e. name, page|id, mdate, cdate)
5. limit: maximum number of results to return
6. inwords: use real month and day names instead of just numbers
7. cols: number of columns in displayed list (max = 4)
8. proper: display page names and namespace in Proper Case (i.e. no _'s and Capitalised)
----
All options are optional, and the list will default to a boring long 1-column list...
blob
mark :4
data 841
div.dokuwiki div#pagequery h1,
div.dokuwiki div#pagequery h2,
div.dokuwiki div#pagequery h3,
div.dokuwiki div#pagequery h4,
div.dokuwiki div#pagequery h5 {
    padding:0.1em 0 0;
    margin:0;
    margin-bottom:0.4em;
    color:gray;
}
div.dokuwiki div#pagequery h1 {}
div.dokuwiki div#pagequery h2 {margin-left:0.5em}
div.dokuwiki div#pagequery h3 {margin-left:1em}
div.dokuwiki div#pagequery h4 {margin-left:1.5em}
div.dokuwiki div#pagequery h5 {margin-left:2em}

div.dokuwiki div#pagequery table {
    border-collapse:collapse;
    width:99%;
}
div.dokuwiki div#pagequery td {
	border-width:1px;
	padding:5px 10px;
	border-style:solid;
	border-color:#D7D5D4;
	background-color:white;
}
div.dokuwiki div#pagequery ul {
    list-style:none;
    margin:0 0 0.7em 2.5em;
}
div.dokuwiki div#pagequery ul.nogroup {
    margin:0 0 0.7em 0.2em;
}
blob
mark :5
data 18447
<?php
/**
 * PageQuery Plugin: search for and list pages
 *
 * @license    GPL 2 (http://www.gnu.org/licenses/gpl.html)
 * @author	   Symon Bent <symonbent@gmail.com>
 */
// must be run within Dokuwiki
if(!defined('DOKU_INC')) die();

if (!defined('DOKU_LF')) define('DOKU_LF', "\n");
if (!defined('DOKU_TAB')) define('DOKU_TAB', "\t");
if (!defined('DOKU_PLUGIN')) define('DOKU_PLUGIN',DOKU_INC.'lib/plugins/');

require_once(DOKU_PLUGIN.'syntax.php');
require_once(DOKU_INC.'inc/fulltext.php');

//Default max tagits displayed
define('PAGE_LIMIT', 50);

class syntax_plugin_pagequery extends DokuWiki_Syntax_Plugin {
    private $dformat = '';
    private $inwords = false;

	function getInfo() {
		$desc = file_get_contents(DOKU_PLUGIN . 'pagequery/readme.txt');
		return array(
			'author' => 'Symon Bent', 
			'email'  => 'symonbent@gmail.com',
			'date'   => '2010-04-09',
			'name'   => 'Pagequery Plugin',
			'desc'   => empty($desc) ? 'readme.txt is missing!' : $desc,
			'url'    => 'http://wiki.splitbrain.org/plugin:pagequery',
		);
	}

	function getType() {
		return 'substition';
	}
	
	function getPType() {
		return 'block';
	}
	
	function getSort() {
		return 98;
	}

	function connectTo($mode) {
		//Default is a word cloud style, looks good when combined with plugin:box
		$this->Lexer->addSpecialPattern('\{\{pagequery>.*?\}\}', $mode, 'plugin_pagequery');
	}
    /**
     * Parses all the pagequery options:
     * Insert the pagequery markup wherever you want your list to appear. E.g:
     *
     *   {{pagequery>}}
     *
     *   {{pagequery>[query];fulltext;sort=key:direction,key2:direction;group;limit=??;cols=?;inwords;proper}}
     * 
     * Parameters as follows:
     * 1. query:    any expression directly after the >; can use all Dokuwiki search options (see manual)
     * 2. fulltext: use a full-text search, instead of page_id only [default]
     * 3. sort:     keys to sort by, in order of sorting. Each key can be followed by prefered sorting order
     *              available keys:
     *                  a, ab, abc          by 1st letter, 2 letters, or 3 letters
     *                  name                by page name (no namespace) [not grouped]
     *                  page|id             by full page id, including namespace [not grouped]
     *                  ns                  by namespace (without page name)
     *                  mdate, cdate        by modified|created dates (full) [not grouped]
     *                  m[year][month][day] by modified [year][month][day]; any combination accepted
     *                  c[year][month][day] by created [year][month][day]; any combination accepted
     *                  creator             by page author
     *              date sort default to descending, string sorts to ascending
     * 4. group:    show group headers for each change in sort keys
     *              Note: keys with no duplicated cannot be grouped (i.e. name, page|id, mdate, cdate)
     * 5. limit:    maximum number of results to return
     * 6. inwords:  use real month and day names instead of just numbers
     * 7. cols:     number of columns in displayed list (max = 4)
     * 8. proper:   display page names and namespace in Proper Case (i.e. no _'s and Capitalised)
     * 9. border:   turn on borders
     *
     * All options are optional, and the list will default to a boring long 1-column list...
     */
	function handle($match, $state, $pos, &$handler) {
        global $conf;
        $this->dformat = $conf['dformat'];
        
		$match = substr($match, 12, -2); // strip markup incl. tagit>
		$args = explode(';', $match);
        $query = $args[0];
        $fulltext = false;
        $sort = array();
        $group = false;
        $limit = PAGE_LIMIT;
        $proper = false;
        $cols = 1;
        $border = false;
        foreach ($args as $arg) {
            list($key, $value) = explode('=', $arg);
            switch ($key) {
                case 'fulltext':
                    $fulltext = true;
                    break;
                case 'sort':
                    $values = explode(',', $value);
                    foreach ($values as $value) {
                        list($key, $dir) = explode(':', $value);
                        $sort[] = array($key, $dir);
                    }
                    break;
                case 'group':
                    $group = true;
                    break;
                case 'limit':
                    $limit = $value;
                    break;
                case 'inwords':
                    $inwords = true;
                    break;
                case 'proper':
                    $proper = true;
                    break;
                case 'cols':
                    $cols = ($value > 4) ? 4 : $value;
                    break;
                case 'border':
                    $border = true;
                    break;
            }
        }
		return array($query, $fulltext, $sort, $group, $limit, $proper, $cols, $inwords, $border);
	}

    function render($mode, &$renderer, $data) {
        $sortkeys = array();
        list($query, $fulltext, $sort, $group, $limit, $proper, $cols, $inwords, $border) = $data;
        $this->inwords = $inwords;
        if ($mode == 'xhtml') {
            if ($fulltext) {
                $results = array_keys(ft_pageSearch($query, $highlight));
            } else {
                list($ns_query, $pageonly) = $this->_parse_ns_query($query);
                $results = $this->_pageLookup($ns_query, $pageonly);
            }
            $border_css = ($border === false) ? ' style="border-style:none;"' : '';
            $renderer->doc .= '<div id="pagequery">' . DOKU_LF;
            $renderer->doc .= '<table><tbody><tr>' . DOKU_LF;

            if (empty($results)) {
                $renderer->doc .= '<td><p>' . $this->getLang("no_results") . 
                                  '"<strong>' . $query . '</strong>"</p></td>';
            } else {
                $sort_opts = $this->_get_sort_opts($results, $sort);
                $this->_sort_results($results, $sort_opts);
                if ($group) {
                    $results = $this->_group_results($results, $sort_opts);
                }
                $was_heading = false;
                $idx = 0;
                $rows = ceil(count($results) / $cols);
                $width = floor(100 / $cols);

                foreach ($results as $id) {
                    if ($idx % $rows == 0) {
                        $renderer->doc .= '<td' . $border_css . ' valign="top" width="' . $width . '%">' . DOKU_LF;
                        if ($idx > 0) {
                            $renderer->doc .= '<p>(cont...)</p>' . DOKU_LF;
                        }
                    }
                    if ($id[0] == '<') {
                        // deal with headers (already marked up)
                        if (!$was_heading) $renderer->doc .= '</ul>' . DOKU_LF;
                        if ($proper) {
                            $id = str_replace(':', ' : ', $id);
                            $id = str_replace('_', ' ', $id);
                            $id = ucwords($id);
                        }
                        $renderer->doc .= $id . DOKU_LF;
                        $was_heading = true;
                    } else {
                        // normal page links
                        $indent_css = ($group === false) ? ' class="nogroup"' : '';
                        if ($was_heading || $idx == 0) $renderer->doc .= '<ul' . $indent_css . '>';
                        $name = ($proper) ? ucwords(str_replace('_', ' ', noNS($id))) : '';
                        $id = (strpos($id, ':') === false) ? ':' . $id : $id;   // : needed for root pages
                        // swap normal link title (popup) for a more useful preview
                        $link = $this->_wikilink_preview_popup($id, $name);
                        $renderer->doc .= '<li>' . $link . '</li>' . DOKU_LF;
                        $was_heading = false;
                    }
                    if ($idx % $rows == ($rows - 1)) {
                        $renderer->doc .= '</ul></td>' . DOKU_LF;
                        $was_heading = true;
                    }
                    $idx++;
                }
                $renderer->doc .= '</ul></td>';
            }
            $renderer->doc .= '</tr>' . DOKU_LF;
            $renderer->doc .= '</tbody></table>';
            $renderer->doc .= '</div>' . DOKU_LF;
        } else {
            return false;
        }
    }

    private function _wikilink_preview_popup($id, $name) {
        // swap normal link title (popup) for a more useful preview
        $link = html_wikilink($id, $name);
        $meta = p_get_metadata($id, false, true);
        $preview = $meta['description']['abstract'] . '... ';
        $preview = str_replace("\n", '  ', $preview);
        $link = preg_replace('/title=\".+?\"/', 'title="' . $preview . '"', $link, 1);
        return $link;
    }

    private function _parse_ns_query($query) {
        $incl_ns = preg_match('`(@|ns:)(\w+(\:\w+)*)(\s.+)*`', $query, $matches);
        if ($incl_ns > 0) {
            $ns = $matches[2];
            $page = trim($matches[4]);
            if ($page == '*') $page = '.*';
            $ns_query = $ns . ".*" . $page;
            return array($ns_query, false);
        }
        $excl_ns = preg_match('`(\^|-ns:)(\w+(\:\w+)*)(\s.+)*`', $query, $matches);
        if ($excl_ns > 0) {
            $ns = $matches[2];
            $page = trim($matches[4]);
            if ($page == '*') $page = '.*';
            $ns_query = '^(?!' . $ns . ').*' . $page;
            return array($ns_query, false);
        }
		if ($query == '*') $query= '.*';
        return array($query, true);
    }

    /**
     * Builds a separate sorting array for each sortby key
     * @param string    $id         wiki page id
     * @param array     $sortby     keys to use for sorting
     * @param arrayref  $sortkeys   ref to sorting arrays
     * @return void
     */
    private function _get_sort_opts($ids, $sortkeys) {
        $sort_opts = array();
        // create the sorting arrays first
        foreach ($ids as $id) {
            $meta = p_get_metadata ($id, false, true);
            if (!isset($meta['date']['modified'])) {
                $meta['date']['modified'] = $meta['date']['created'];
            }
            $idx = 0;
            foreach ($sortkeys as $sortkey) {
                $key = $sortkey[0];
                switch ($key) {
                    case 'a':
                        $value = $this->_first(noNS($id), 1);
                        break;
                    case 'ab':
                        $value = $this->_first(noNS($id), 2);
                        break;
                    case 'abc':
                        $value = $this->_first(noNS($id), 3);
                        break;
                    case 'name':
                        $value = noNS($id);
                        break;
                    case 'id':
                    case 'page':
                        $value = $id;
                        break;
                    case 'ns':
                        $value = getNS($id);
                        if (empty($value)) $value = '(start)';
                        break;
                    case 'creator':
                        $value = $meta['creator'];
                        break;
                    case 'mdate':
                        $value = date($this->dformat, $meta['date']['modified']);
                        break;
                    case 'cdate':
                        $value = date($this->dformat, $meta['date']['created']);
                        break;
                    default:
                        $dtype = $key[0];
                        // the date formats are cached on first use; assumes one modifed & created per set
                        if ($dtype == 'c' || $dtype == 'm') {
                            if (!isset($dformat[$key])) {
                                $dformat[$key] = $this->_date_format($key);
                                $sort_opts[$idx]['format'] = $dformat[$key];
                            }
                            if ($dtype == 'c') {
                                $value = strftime($dformat[$key], $meta['date']['created']);
                            } elseif ($dtype == 'm') {
                                $value = strftime($dformat[$key], $meta['date']['modified']);
                            }
                        }
                }
                $sort_opts[$idx]['keys'][] = $value;
                $idx += 1;
            }
        }
        $idx = 0;
        foreach ($sortkeys as $sortkey) {
            list($key, $dir) = $sortkey;
            // now the sort direction
            switch ($dir) {
                case 'asc':
                    $dir = SORT_ASC;
                    break;
                case 'desc':
                    $dir = SORT_DESC;
                    break;
                default:
                    // sort descending by default; text ascending
                    if ($key[0] == 'c' || $key[0] == 'm') {
                        $dir = SORT_DESC;
                    } else {
                        $dir = SORT_ASC;
                    }
            }
            $sort_opts[$idx]['dir'] = $dir;
            // and finally the sort array's data type (for correct markup purposes)
            switch ($key) {
                // full-text and complete dates cannot meaningfully be grouped (no duplicates!)
                case 'mdate':
                case 'cdate':
                case 'name':
                case 'id':
                case 'page':
                    $group = false;
                    break;
                default:
                    $group = true;
            }
            $sort_opts[$idx]['group'] = $group;

            $idx += 1;
        }
        return $sort_opts;
    }


    private function _first($text, $count) {
        if ($count > 0) {
            return substr($text, 0, $count);
        }
    }
    private function _date_format($key) {
        $year = (strpos($key, 'year') !== false) ? '%Y' : '';
        $month = (strpos($key, 'month') !== false) ? '%m' : '';
        $day = (strpos($key, 'day') !== false) ? '%d' : '';
        $format = $year . (($year != '' && ($month != '' || $day != '')) ? '-' : '');
        $format .= $month . ($month != '' && $day != '' ? '-' : '');
        $format .= $day;
        return $format;
    }
    
    private function _sort_results(&$ids, &$sort_opts) {
        if (!empty($sort_opts)) {
            $args = array();
            foreach ($sort_opts as &$sort_opt) {
                $args[] = &$sort_opt['keys'];
                $args[] = &$sort_opt['dir'];
            }
            $args[] = &$ids;
            call_user_func_array('array_multisort', $args);
        }
    }
    
    private function _group_results(&$ids, &$sort_opts) {
        $prevs = array();
        $results = array();
        $level = count($sort_opts) - 1;
        $idx = 0;
        foreach($ids as $id) {
            $this->_add_heading($results, $sort_opts, $level, $idx, $prevs);
            $results[] = $id;
            $idx++;
        }
        return $results;
    }
    
    private function _add_heading(&$results, &$sort_opts, $level, $idx, &$prevs) {
        if ($level > 0) {
            $this->_add_heading($results, $sort_opts, $level - 1, $idx, $prevs);
        }
        $group = $sort_opts[$level]['group'];
        if ($group) {
            $prev = (isset($prevs[$level])) ? $prevs[$level] : '';
            $cur = $sort_opts[$level]['keys'][$idx];
            if ($cur != $prev) {
                $prevs[$level] = $cur;
                $h = 'h' . ($level + 1);
                if ($this->inwords) {
                    $format = $sort_opts[$level]['format'];
                    switch ($format) {
                        case '%m':
                            $cur = strftime("%B", mktime(0, 0, 0, $cur, 10));
                            break;
                        case '%d':
                            $cur = strftime("%#d, %A ", mktime(0, 0, 0, 0, $cur));
                            break;
                        case '%Y-%m':
                            $cur = strftime("%B %Y", mktime(0, 0, 0, substr($cur, 5, 2), 10, substr($cur, 0, 4)));
                            break;
                        case '%m-%d':
                            $cur = strftime("%B %#d, %A ", mktime(0, 0, 0, substr($cur, 0, 2), substr($cur, 3, 2)));
                            break;
                        case '%Y-%m-%d':
                            $cur = strftime("%A, %B %#d, %Y", mktime(0, 0, 0, substr($cur, 5, 2), substr($cur, 8, 2), substr($cur, 0, 4)));
                            break;
                    }
                }
                // space in front ensures that ucwords works
                $results[] = "<$h> $cur</$h>";
            }
        }
    }

    /**
     * based whole on _ft_pageLookup in inc/fulltext.php
     * I just removed the preg_quote line to enable regexes in search query...
     * and the unnecessary usort line as I have my own sort routines
     *
     */
    private function _pageLookup($query, $pageonly) {

        global $conf;
        //$id    = preg_quote($id,'/');
        //if (empty($query)) $query = '.*';   // defaults to everything
        $query = trim($query);
        $pages = file($conf['indexdir'].'/page.idx');
        $pages = array_values(preg_grep('/'.$query.'/',$pages));

        $cnt = count($pages);
        for($i=0; $i<$cnt; $i++){
            if($pageonly){
                if(!preg_match('/'.$query.'/',noNS($pages[$i]))){
                    unset($pages[$i]);
                    continue;
                }
            }
            if(!page_exists($pages[$i])){
                unset($pages[$i]);
                continue;
            }
        }

        $pages = array_filter($pages,'isVisiblePage'); // discard hidden pages
        if(!count($pages)) return array();

        // check ACL permissions
        foreach(array_keys($pages) as $idx){
            if(auth_quickaclcheck(trim($pages[$idx])) < AUTH_READ){
                unset($pages[$idx]);
            }
        }

        $pages = array_map('trim',$pages);
        //usort($pages,'ft_pagesorter');
        return $pages;
    }
}

blob
mark :7
data 19848
<?php
/**
 * PageQuery Plugin: search for and list pages
 *
 * @license    GPL 2 (http://www.gnu.org/licenses/gpl.html)
 * @author	   Symon Bent <symonbent@gmail.com>
 */
// must be run within Dokuwiki
if(!defined('DOKU_INC')) die();

if (!defined('DOKU_LF')) define('DOKU_LF', "\n");
if (!defined('DOKU_TAB')) define('DOKU_TAB', "\t");
if (!defined('DOKU_PLUGIN')) define('DOKU_PLUGIN',DOKU_INC.'lib/plugins/');

require_once(DOKU_PLUGIN.'syntax.php');
require_once(DOKU_INC.'inc/fulltext.php');

//Default max tagits displayed
define('PAGE_LIMIT', 50);

class syntax_plugin_pagequery extends DokuWiki_Syntax_Plugin {
    private $dformat = '';
    private $inwords = false;

	function getInfo() {
		$desc = file_get_contents(DOKU_PLUGIN . 'pagequery/readme.txt');
		return array(
			'author' => 'Symon Bent', 
			'email'  => 'symonbent@gmail.com',
			'date'   => '2010-04-09',
			'name'   => 'Pagequery Plugin',
			'desc'   => empty($desc) ? 'readme.txt is missing!' : $desc,
			'url'    => 'http://wiki.splitbrain.org/plugin:pagequery',
		);
	}

	function getType() {
		return 'substition';
	}
	
	function getPType() {
		return 'block';
	}
	
	function getSort() {
		return 98;
	}

	function connectTo($mode) {
		//Default is a word cloud style, looks good when combined with plugin:box
		$this->Lexer->addSpecialPattern('\{\{pagequery>.*?\}\}', $mode, 'plugin_pagequery');
	}
    /**
     * Parses all the pagequery options:
     * Insert the pagequery markup wherever you want your list to appear. E.g:
     *
     *   {{pagequery>}}
     *
     *   {{pagequery>[query];fulltext;sort=key:direction,key2:direction;group;limit=??;cols=?;inwords;proper}}
     * 
     * Parameters as follows:
     * 1. query:    any expression directly after the >; can use all Dokuwiki search options (see manual)
     * 2. fulltext: use a full-text search, instead of page_id only [default]
     * 3. sort:     keys to sort by, in order of sorting. Each key can be followed by prefered sorting order
     *              available keys:
     *                  a, ab, abc          by 1st letter, 2 letters, or 3 letters
     *                  name                by page name (no namespace) [not grouped]
     *                  page|id             by full page id, including namespace [not grouped]
     *                  ns                  by namespace (without page name)
     *                  mdate, cdate        by modified|created dates (full) [not grouped]
     *                  m[year][month][day] by modified [year][month][day]; any combination accepted
     *                  c[year][month][day] by created [year][month][day]; any combination accepted
     *                  creator             by page author
     *              date sort default to descending, string sorts to ascending
     * 4. group:    show group headers for each change in sort keys
     *              Note: keys with no duplicated cannot be grouped (i.e. name, page|id, mdate, cdate)
     * 5. limit:    maximum number of results to return
     * 6. inwords:  use real month and day names instead of just numbers
     * 7. cols:     number of columns in displayed list (max = 4)
     * 8. proper:   display page names and namespace in Proper Case (i.e. no _'s and Capitalised)
     * 9. border:   turn on borders
     *
     * All options are optional, and the list will default to a boring long 1-column list...
     */
	function handle($match, $state, $pos, &$handler) {
        global $conf;
        $this->dformat = $conf['dformat'];
        
		$match = substr($match, 12, -2); // strip markup incl. tagit>
		$args = explode(';', $match);
        $query = $args[0];
        $fulltext = false;
        $sort = array();
        $group = false;
        $limit = PAGE_LIMIT;
        $proper = false;
        $cols = 1;
        $border = false;
        foreach ($args as $arg) {
            list($key, $value) = explode('=', $arg);
            switch ($key) {
                case 'fulltext':
                    $fulltext = true;
                    break;
                case 'sort':
                    $values = explode(',', $value);
                    foreach ($values as $value) {
                        list($key, $dir) = explode(':', $value);
                        $sort[] = array($key, $dir);
                    }
                    break;
                case 'group':
                    $group = true;
                    break;
                case 'limit':
                    $limit = $value;
                    break;
                case 'inwords':
                    $inwords = true;
                    break;
                case 'proper':
                    $proper = true;
                    break;
                case 'cols':
                    $cols = ($value > 4) ? 4 : $value;
                    break;
                case 'border':
                    $border = true;
                    break;
            }
        }
		return array($query, $fulltext, $sort, $group, $limit, $proper, $cols, $inwords, $border);
	}

    function render($mode, &$renderer, $data) {
        $sortkeys = array();
        list($query, $fulltext, $sort, $group, $limit, $proper, $cols, $inwords, $border) = $data;
        $this->inwords = $inwords;
        if ($mode == 'xhtml') {
            // first get a raw list of matching results
            if ($fulltext) {
                $results = array_keys(ft_pageSearch($query, $highlight));
            } else {
                list($ns_query, $pageonly) = $this->_parse_ns_query($query);
                $results = $this->_pageLookup($ns_query, $pageonly);
            }
            // basic result page markup (always needed)
            $border_css = ($border === false) ? ' style="border-style:none;"' : '';
            $renderer->doc .= '<div id="pagequery">' . DOKU_LF;
            $renderer->doc .= '<table><tbody><tr>' . DOKU_LF;
            
            // display a "no results" message if empty
            if (empty($results)) {
                $renderer->doc .= '<td><p>' . $this->getLang("no_results") . 
                                  '"<strong>' . $query . '</strong>"</p></td>';
            } else {
                // prepare the necessary sorting arrays, as per options
                $sort_opts = $this->_get_sort_opts($results, $sort);
                // now do the sorting
                $this->_sort_results($results, $sort_opts);
                // and finally the grouping
                if ($group) {
                    $results = $this->_group_results($results, $sort_opts);
                }
                $was_heading = false;
                $idx = 0;
                $col = 0;
                $rows = ceil(count($results) / $cols);  // proposed column row size
                $width = floor(100 / $cols);
                // remove indenting if not grouped
                $indent_css = ($group === false) ? ' class="nogroup"' : '';

                foreach ($results as $id) {
                    // are we ready to start a new column? (up to max allowed)
                    if ($col < $cols && $idx % $rows == 0) {
                        $ready_for_col = true;
                        $col++;
                    }
                    $is_heading = ($id[0] == '<');
                    // Only start if we are at a heading or if there is no grouping
                    if ($ready_for_col && ($idx == 0 || $is_heading || !$group)) {
                        // close the previous column if necessary
                        $close = ($idx > 0) ? '</ul></td>' . DOKU_LF : '';
                        $renderer->doc .= $close . '<td' . $border_css . ' valign="top" width="' . $width . '%">' . DOKU_LF;
                        $ready_for_col = false;
                        $was_heading = true;    //needed to begin a new page id list
                    }
                    if ($is_heading) {
                        // deal with headers (already marked up)
                        if (!$was_heading) $renderer->doc .= '</ul>' . DOKU_LF;
                        if ($proper) $id = $this->_proper($id);
                        $renderer->doc .= $id . DOKU_LF;
                        $was_heading = true;
                    } else {
                        // normal page links
                        if ($was_heading || $idx == 0) $renderer->doc .= '<ul' . $indent_css . '>';
                        $name = ($proper) ? $this->_proper(noNS($id)) : '';
                        $id = (strpos($id, ':') === false) ? ':' . $id : $id;   // : needed for root pages
                        // swap normal link title (popup) for a more useful preview
                        $link = $this->_wikilink_preview_popup($id, $name);
                        $renderer->doc .= '<li>' . $link . '</li>' . DOKU_LF;
                        $was_heading = false;
                    }
                    $idx++;
                }
                $renderer->doc .= '</ul></td>';
            }
            $renderer->doc .= '</tr>' . DOKU_LF;
            $renderer->doc .= '</tbody></table>';
            $renderer->doc .= '</div>' . DOKU_LF;
        } else {
            return false;
        }
    }

    private function _proper($id) {
         $id = str_replace(':', ' : ', $id);
         $id = str_replace('_', ' ', $id);
         $id = ucwords($id);
         return $id;
    }
    /**
     * swap normal link title (popup) for a more useful preview
     *
     * @param string $id    page id
     * @param string $name  display name
     * @return complete href link 
     */
    private function _wikilink_preview_popup($id, $name) {
        $link = html_wikilink($id, $name);
        $meta = p_get_metadata($id, false, true);
        $preview = $meta['description']['abstract'] . '... ';
        $preview = str_replace("\n", '  ', $preview);
        $link = preg_replace('/title=\".+?\"/', 'title="' . $preview . '"', $link, 1);
        return $link;
    }

    /**
     * Parse out the namespace, and convert to a regex for array search
     *
     * @param string $query user page query
     * @return processed query with regex markup as needed for namespace recognition
     */
    private function _parse_ns_query($query) {
        $incl_ns = preg_match('`(@|ns:)(\w+(\:\w+)*)(\s.+)*`', $query, $matches);
        if ($incl_ns > 0) {
            $ns = $matches[2];
            $page = trim($matches[4]);
            if ($page == '*') $page = '.*';
            $ns_query = $ns . ".*" . $page;
            return array($ns_query, false);
        }
        $excl_ns = preg_match('`(\^|-ns:)(\w+(\:\w+)*)(\s.+)*`', $query, $matches);
        if ($excl_ns > 0) {
            $ns = $matches[2];
            $page = trim($matches[4]);
            if ($page == '*') $page = '.*';
            $ns_query = '^(?!' . $ns . ').*' . $page;
            return array($ns_query, false);
        }
		if ($query == '*') $query= '.*';
        return array($query, true);
    }

    /**
     * Builds a separate sorting array for each sortby key
     *
     * @param string    $id         wiki page id
     * @param array     $sortby     keys to use for sorting
     * @param arrayref  $sortkeys   ref to sorting arrays
     * @return void
     */
    private function _get_sort_opts($ids, $sortkeys) {
        $sort_opts = array();
        foreach ($ids as $id) {
            $meta = p_get_metadata ($id, false, true);
            if (!isset($meta['date']['modified'])) {
                $meta['date']['modified'] = $meta['date']['created'];
            }
            $idx = 0;
            foreach ($sortkeys as $sortkey) {
                $key = $sortkey[0];
                switch ($key) {
                    case 'a':
                        $value = $this->_first(noNS($id), 1);
                        break;
                    case 'ab':
                        $value = $this->_first(noNS($id), 2);
                        break;
                    case 'abc':
                        $value = $this->_first(noNS($id), 3);
                        break;
                    case 'name':
                        $value = noNS($id);
                        break;
                    case 'id':
                    case 'page':
                        $value = $id;
                        break;
                    case 'ns':
                        $value = getNS($id);
                        if (empty($value)) $value = '(start)';
                        break;
                    case 'creator':
                        $value = $meta['creator'];
                        break;
                    case 'mdate':
                        $value = date($this->dformat, $meta['date']['modified']);
                        break;
                    case 'cdate':
                        $value = date($this->dformat, $meta['date']['created']);
                        break;
                    default:
                        $dtype = $key[0];
                        // the date formats are cached on first use; assumes one modifed & created per set
                        if ($dtype == 'c' || $dtype == 'm') {
                            if (!isset($dformat[$key])) {
                                $dformat[$key] = $this->_date_format($key);
                                $sort_opts[$idx]['format'] = $dformat[$key];
                            }
                            if ($dtype == 'c') {
                                $value = strftime($dformat[$key], $meta['date']['created']);
                            } elseif ($dtype == 'm') {
                                $value = strftime($dformat[$key], $meta['date']['modified']);
                            }
                        }
                }
                $sort_opts[$idx]['keys'][] = $value;
                $idx += 1;
            }
        }
        $idx = 0;
        foreach ($sortkeys as $sortkey) {
            list($key, $dir) = $sortkey;
            // now the sort direction
            switch ($dir) {
                case 'asc':
                    $dir = SORT_ASC;
                    break;
                case 'desc':
                    $dir = SORT_DESC;
                    break;
                default:
                    // sort descending by default; text ascending
                    if ($key[0] == 'c' || $key[0] == 'm') {
                        $dir = SORT_DESC;
                    } else {
                        $dir = SORT_ASC;
                    }
            }
            $sort_opts[$idx]['dir'] = $dir;
            // and finally set the sort array's data type (for correct markup purposes)
            switch ($key) {
                // full-text and complete dates cannot meaningfully be grouped (no duplicates!)
                case 'mdate':
                case 'cdate':
                case 'name':
                case 'id':
                case 'page':
                    $group = false;
                    break;
                default:
                    $group = true;
            }
            $sort_opts[$idx]['group'] = $group;
            $idx += 1;
        }
        return $sort_opts;
    }

    // returns first $count letters from $text
    private function _first($text, $count) {
        if ($count > 0) {
            return substr($text, 0, $count);
        }
    }

    // parse the c|m-year-month-day option
    private function _date_format($key) {
        $year = (strpos($key, 'year') !== false) ? '%Y' : '';
        $month = (strpos($key, 'month') !== false) ? '%m' : '';
        $day = (strpos($key, 'day') !== false) ? '%d' : '';
        $format = $year . (($year != '' && ($month != '' || $day != '')) ? '-' : '');
        $format .= $month . ($month != '' && $day != '' ? '-' : '');
        $format .= $day;
        return $format;
    }

    // sort by each sorting array, in order
    private function _sort_results(&$ids, &$sort_opts) {
        if (!empty($sort_opts)) {
            $args = array();
            foreach ($sort_opts as &$sort_opt) {
                $args[] = &$sort_opt['keys'];
                $args[] = &$sort_opt['dir'];
            }
            $args[] = &$ids;
            call_user_func_array('array_multisort', $args);
        }
    }
    
    private function _group_results(&$ids, &$sort_opts) {
        $prevs = array();
        $results = array();
        $level = count($sort_opts) - 1;
        $idx = 0;
        foreach($ids as $id) {
            $this->_add_heading($results, $sort_opts, $level, $idx, $prevs);
            $results[] = $id;
            $idx++;
        }
        return $results;
    }
    
    private function _add_heading(&$results, &$sort_opts, $level, $idx, &$prevs) {
        if ($level > 0) {
            // recurse to find all parent headings
            $this->_add_heading($results, $sort_opts, $level - 1, $idx, $prevs);
        }
        $group = $sort_opts[$level]['group'];
        // only if this sort array can be grouped....
        if ($group) {
            $prev = (isset($prevs[$level])) ? $prevs[$level] : '';
            $cur = $sort_opts[$level]['keys'][$idx];
            if ($cur != $prev) {
                $prevs[$level] = $cur;
                $h = 'h' . ($level + 1);
                // display months and days in real words
                if ($this->inwords) {
                    $format = $sort_opts[$level]['format'];
                    switch ($format) {
                        case '%m':
                            $cur = strftime("%B", mktime(0, 0, 0, $cur, 10));
                            break;
                        case '%d':
                            $cur = strftime("%#d, %A ", mktime(0, 0, 0, 0, $cur));
                            break;
                        case '%Y-%m':
                            $cur = strftime("%B %Y", mktime(0, 0, 0, substr($cur, 5, 2), 10, substr($cur, 0, 4)));
                            break;
                        case '%m-%d':
                            $cur = strftime("%B %#d, %A ", mktime(0, 0, 0, substr($cur, 0, 2), substr($cur, 3, 2)));
                            break;
                        case '%Y-%m-%d':
                            $cur = strftime("%A, %B %#d, %Y", mktime(0, 0, 0, substr($cur, 5, 2), substr($cur, 8, 2), substr($cur, 0, 4)));
                            break;
                    }
                }
                // space in front ensures that ucwords works
                $results[] = "<$h> $cur</$h>";
            }
        }
    }

    /**
     * based wholely on _ft_pageLookup in inc/fulltext.php
     * I just removed the preg_quote line to enable regexes in search query...
     * and the unnecessary usort line as I have my own sort routines
     *
     */
    private function _pageLookup($query, $pageonly) {

        global $conf;
        //$id    = preg_quote($id,'/');
        //if (empty($query)) $query = '.*';   // defaults to everything
        $query = trim($query);
        $pages = file($conf['indexdir'].'/page.idx');
        $pages = array_values(preg_grep('/'.$query.'/',$pages));

        $cnt = count($pages);
        for($i=0; $i<$cnt; $i++){
            if($pageonly){
                if(!preg_match('/'.$query.'/',noNS($pages[$i]))){
                    unset($pages[$i]);
                    continue;
                }
            }
            if(!page_exists($pages[$i])){
                unset($pages[$i]);
                continue;
            }
        }

        $pages = array_filter($pages,'isVisiblePage'); // discard hidden pages
        if(!count($pages)) return array();

        // check ACL permissions
        foreach(array_keys($pages) as $idx){
            if(auth_quickaclcheck(trim($pages[$idx])) < AUTH_READ){
                unset($pages[$idx]);
            }
        }

        $pages = array_map('trim',$pages);
        //usort($pages,'ft_pagesorter');
        return $pages;
    }
}

blob
mark :9
data 965
div.dokuwiki div#pagequery h1,
div.dokuwiki div#pagequery h2,
div.dokuwiki div#pagequery h3,
div.dokuwiki div#pagequery h4,
div.dokuwiki div#pagequery h5 {
    padding:0.1em 0 0;
    margin:0;
    margin-bottom:0.4em;
    color:gray;
}
div.dokuwiki div#pagequery h1 {}
div.dokuwiki div#pagequery h2 {margin-left:0.5em}
div.dokuwiki div#pagequery h3 {margin-left:1em}
div.dokuwiki div#pagequery h4 {margin-left:1.5em}
div.dokuwiki div#pagequery h5 {margin-left:2em}

div.dokuwiki div#pagequery table {
    border-collapse:collapse;
    width:99%;
}
div.dokuwiki div#pagequery td {
	border-width:1px;
	padding:5px 10px;
	border-style:solid;
	border-color:#D7D5D4;
	background-color:white;
}
div.dokuwiki div#pagequery ul {
    list-style:none;
    margin:0 0 0.7em 2.5em;
	text-align:left;
}
div.dokuwiki div#pagequery li {
	padding-left:0.6em; 
	list-style-position:inside; 
	text-indent:-0.6em
}
div.dokuwiki div#pagequery ul.nogroup {
    margin:0 0 0.7em 0.2em;
}
blob
mark :10
data 19848
<?php
/**
 * PageQuery Plugin: search for and list pages
 *
 * @license    GPL 2 (http://www.gnu.org/licenses/gpl.html)
 * @author	   Symon Bent <symonbent@gmail.com>
 */
// must be run within Dokuwiki
if(!defined('DOKU_INC')) die();

if (!defined('DOKU_LF')) define('DOKU_LF', "\n");
if (!defined('DOKU_TAB')) define('DOKU_TAB', "\t");
if (!defined('DOKU_PLUGIN')) define('DOKU_PLUGIN',DOKU_INC.'lib/plugins/');

require_once(DOKU_PLUGIN.'syntax.php');
require_once(DOKU_INC.'inc/fulltext.php');

//Default max tagits displayed
define('PAGE_LIMIT', 50);

class syntax_plugin_pagequery extends DokuWiki_Syntax_Plugin {
    private $dformat = '';
    private $inwords = false;

	function getInfo() {
		$desc = file_get_contents(DOKU_PLUGIN . 'pagequery/readme.txt');
		return array(
			'author' => 'Symon Bent', 
			'email'  => 'symonbent@gmail.com',
			'date'   => '2010-04-09',
			'name'   => 'Pagequery Plugin',
			'desc'   => empty($desc) ? 'readme.txt is missing!' : $desc,
			'url'    => 'http://wiki.splitbrain.org/plugin:pagequery',
		);
	}

	function getType() {
		return 'substition';
	}
	
	function getPType() {
		return 'block';
	}
	
	function getSort() {
		return 98;
	}

	function connectTo($mode) {
		//Default is a word cloud style, looks good when combined with plugin:box
		$this->Lexer->addSpecialPattern('\{\{pagequery>.*?\}\}', $mode, 'plugin_pagequery');
	}
    /**
     * Parses all the pagequery options:
     * Insert the pagequery markup wherever you want your list to appear. E.g:
     *
     *   {{pagequery>}}
     *
     *   {{pagequery>[query];fulltext;sort=key:direction,key2:direction;group;limit=??;cols=?;inwords;proper}}
     * 
     * Parameters as follows:
     * 1. query:    any expression directly after the >; can use all Dokuwiki search options (see manual)
     * 2. fulltext: use a full-text search, instead of page_id only [default]
     * 3. sort:     keys to sort by, in order of sorting. Each key can be followed by prefered sorting order
     *              available keys:
     *                  a, ab, abc          by 1st letter, 2 letters, or 3 letters
     *                  name                by page name (no namespace) [not grouped]
     *                  page|id             by full page id, including namespace [not grouped]
     *                  ns                  by namespace (without page name)
     *                  mdate, cdate        by modified|created dates (full) [not grouped]
     *                  m[year][month][day] by modified [year][month][day]; any combination accepted
     *                  c[year][month][day] by created [year][month][day]; any combination accepted
     *                  creator             by page author
     *              date sort default to descending, string sorts to ascending
     * 4. group:    show group headers for each change in sort keys
     *              Note: keys with no duplicated cannot be grouped (i.e. name, page|id, mdate, cdate)
     * 5. limit:    maximum number of results to return
     * 6. inwords:  use real month and day names instead of just numbers
     * 7. cols:     number of columns in displayed list (max = 4)
     * 8. proper:   display page names and namespace in Proper Case (i.e. no _'s and Capitalised)
     * 9. border:   turn on borders
     *
     * All options are optional, and the list will default to a boring long 1-column list...
     */
	function handle($match, $state, $pos, &$handler) {
        global $conf;
        $this->dformat = $conf['dformat'];
        
		$match = substr($match, 12, -2); // strip markup incl. tagit>
		$args = explode(';', $match);
        $query = $args[0];
        $fulltext = false;
        $sort = array();
        $group = false;
        $limit = PAGE_LIMIT;
        $proper = false;
        $cols = 1;
        $border = false;
        foreach ($args as $arg) {
            list($key, $value) = explode('=', $arg);
            switch ($key) {
                case 'fulltext':
                    $fulltext = true;
                    break;
                case 'sort':
                    $values = explode(',', $value);
                    foreach ($values as $value) {
                        list($key, $dir) = explode(':', $value);
                        $sort[] = array($key, $dir);
                    }
                    break;
                case 'group':
                    $group = true;
                    break;
                case 'limit':
                    $limit = $value;
                    break;
                case 'inwords':
                    $inwords = true;
                    break;
                case 'proper':
                    $proper = true;
                    break;
                case 'cols':
                    $cols = ($value > 4) ? 4 : $value;
                    break;
                case 'border':
                    $border = true;
                    break;
            }
        }
		return array($query, $fulltext, $sort, $group, $limit, $proper, $cols, $inwords, $border);
	}

    function render($mode, &$renderer, $data) {
        $sortkeys = array();
        list($query, $fulltext, $sort, $group, $limit, $proper, $cols, $inwords, $border) = $data;
        $this->inwords = $inwords;
        if ($mode == 'xhtml') {
            // first get a raw list of matching results
            if ($fulltext) {
                $results = array_keys(ft_pageSearch($query, $highlight));
            } else {
                list($ns_query, $pageonly) = $this->_parse_ns_query($query);
                $results = $this->_pageLookup($ns_query, $pageonly);
            }
            // basic result page markup (always needed)
            $border_css = ($border === false) ? ' style="border-style:none;"' : '';
            $renderer->doc .= '<div id="pagequery">' . DOKU_LF;
            $renderer->doc .= '<table><tbody><tr>' . DOKU_LF;
            
            // display a "no results" message if empty
            if (empty($results)) {
                $renderer->doc .= '<td><p>' . $this->getLang("no_results") . 
                                  '"<strong>' . $query . '</strong>"</p></td>';
            } else {
                // prepare the necessary sorting arrays, as per options
                $sort_opts = $this->_get_sort_opts($results, $sort);
                // now do the sorting
                $this->_sort_results($results, $sort_opts);
                // and finally the grouping
                if ($group) {
                    $results = $this->_group_results($results, $sort_opts);
                }
                $was_heading = false;
                $idx = 0;
                $col = 0;
                $rows = ceil(count($results) / $cols);  // proposed column row size
                $width = floor(100 / $cols);
                // remove indenting if not grouped
                $indent_css = ($group === false) ? ' class="nogroup"' : '';

                foreach ($results as $id) {
                    // are we ready to start a new column? (up to max allowed)
                    if ($col < $cols && $idx % $rows == 0) {
                        $ready_for_col = true;
                        $col++;
                    }
                    $is_heading = ($id[0] == '<');
                    // Only start if we are at a heading or if there is no grouping
                    if ($ready_for_col && ($idx == 0 || $is_heading || !$group)) {
                        // close the previous column if necessary
                        $close = ($idx > 0) ? '</ul></td>' . DOKU_LF : '';
                        $renderer->doc .= $close . '<td' . $border_css . ' valign="top" width="' . $width . '%">' . DOKU_LF;
                        $ready_for_col = false;
                        $was_heading = true;    //needed to begin a new page id list
                    }
                    if ($is_heading) {
                        // deal with headers (already marked up)
                        if (!$was_heading) $renderer->doc .= '</ul>' . DOKU_LF;
                        if ($proper) $id = $this->_proper($id);
                        $renderer->doc .= $id . DOKU_LF;
                        $was_heading = true;
                    } else {
                        // normal page links
                        if ($was_heading || $idx == 0) $renderer->doc .= '<ul' . $indent_css . '>';
                        $name = ($proper) ? $this->_proper(noNS($id)) : '';
                        $id = (strpos($id, ':') === false) ? ':' . $id : $id;   // : needed for root pages
                        // swap normal link title (popup) for a more useful preview
                        $link = $this->_wikilink_preview_popup($id, $name);
                        $renderer->doc .= '<li>' . $link . '</li>' . DOKU_LF;
                        $was_heading = false;
                    }
                    $idx++;
                }
                $renderer->doc .= '</ul></td>';
            }
            $renderer->doc .= '</tr>' . DOKU_LF;
            $renderer->doc .= '</tbody></table>';
            $renderer->doc .= '</div>' . DOKU_LF;
        } else {
            return false;
        }
    }

    private function _proper($id) {
         $id = str_replace(':', ' : ', $id);
         $id = str_replace('_', ' ', $id);
         $id = ucwords($id);
         return $id;
    }
    /**
     * swap normal link title (popup) for a more useful preview
     *
     * @param string $id    page id
     * @param string $name  display name
     * @return complete href link 
     */
    private function _wikilink_preview_popup($id, $name) {
        $link = html_wikilink($id, $name);
        $meta = p_get_metadata($id, false, true);
        $preview = $meta['description']['abstract'] . '... ';
        $preview = str_replace("\n", '. ', $preview);
        $link = preg_replace('/title=\".+?\"/', 'title="' . $preview . '"', $link, 1);
        return $link;
    }

    /**
     * Parse out the namespace, and convert to a regex for array search
     *
     * @param string $query user page query
     * @return processed query with regex markup as needed for namespace recognition
     */
    private function _parse_ns_query($query) {
        $incl_ns = preg_match('`(@|ns:)(\w+(\:\w+)*)(\s.+)*`', $query, $matches);
        if ($incl_ns > 0) {
            $ns = $matches[2];
            $page = trim($matches[4]);
            if ($page == '*') $page = '.*';
            $ns_query = $ns . ".*" . $page;
            return array($ns_query, false);
        }
        $excl_ns = preg_match('`(\^|-ns:)(\w+(\:\w+)*)(\s.+)*`', $query, $matches);
        if ($excl_ns > 0) {
            $ns = $matches[2];
            $page = trim($matches[4]);
            if ($page == '*') $page = '.*';
            $ns_query = '^(?!' . $ns . ').*' . $page;
            return array($ns_query, false);
        }
		if ($query == '*') $query= '.*';
        return array($query, true);
    }

    /**
     * Builds a separate sorting array for each sortby key
     *
     * @param string    $id         wiki page id
     * @param array     $sortby     keys to use for sorting
     * @param arrayref  $sortkeys   ref to sorting arrays
     * @return void
     */
    private function _get_sort_opts($ids, $sortkeys) {
        $sort_opts = array();
        foreach ($ids as $id) {
            $meta = p_get_metadata ($id, false, true);
            if (!isset($meta['date']['modified'])) {
                $meta['date']['modified'] = $meta['date']['created'];
            }
            $idx = 0;
            foreach ($sortkeys as $sortkey) {
                $key = $sortkey[0];
                switch ($key) {
                    case 'a':
                        $value = $this->_first(noNS($id), 1);
                        break;
                    case 'ab':
                        $value = $this->_first(noNS($id), 2);
                        break;
                    case 'abc':
                        $value = $this->_first(noNS($id), 3);
                        break;
                    case 'name':
                        $value = noNS($id);
                        break;
                    case 'id':
                    case 'page':
                        $value = $id;
                        break;
                    case 'ns':
                        $value = getNS($id);
                        if (empty($value)) $value = '(start)';
                        break;
                    case 'creator':
                        $value = $meta['creator'];
                        break;
                    case 'mdate':
                        $value = date($this->dformat, $meta['date']['modified']);
                        break;
                    case 'cdate':
                        $value = date($this->dformat, $meta['date']['created']);
                        break;
                    default:
                        $dtype = $key[0];
                        // the date formats are cached on first use; assumes one modifed & created per set
                        if ($dtype == 'c' || $dtype == 'm') {
                            if (!isset($dformat[$key])) {
                                $dformat[$key] = $this->_date_format($key);
                                $sort_opts[$idx]['format'] = $dformat[$key];
                            }
                            if ($dtype == 'c') {
                                $value = strftime($dformat[$key], $meta['date']['created']);
                            } elseif ($dtype == 'm') {
                                $value = strftime($dformat[$key], $meta['date']['modified']);
                            }
                        }
                }
                $sort_opts[$idx]['keys'][] = $value;
                $idx += 1;
            }
        }
        $idx = 0;
        foreach ($sortkeys as $sortkey) {
            list($key, $dir) = $sortkey;
            // now the sort direction
            switch ($dir) {
                case 'asc':
                    $dir = SORT_ASC;
                    break;
                case 'desc':
                    $dir = SORT_DESC;
                    break;
                default:
                    // sort descending by default; text ascending
                    if ($key[0] == 'c' || $key[0] == 'm') {
                        $dir = SORT_DESC;
                    } else {
                        $dir = SORT_ASC;
                    }
            }
            $sort_opts[$idx]['dir'] = $dir;
            // and finally set the sort array's data type (for correct markup purposes)
            switch ($key) {
                // full-text and complete dates cannot meaningfully be grouped (no duplicates!)
                case 'mdate':
                case 'cdate':
                case 'name':
                case 'id':
                case 'page':
                    $group = false;
                    break;
                default:
                    $group = true;
            }
            $sort_opts[$idx]['group'] = $group;
            $idx += 1;
        }
        return $sort_opts;
    }

    // returns first $count letters from $text
    private function _first($text, $count) {
        if ($count > 0) {
            return substr($text, 0, $count);
        }
    }

    // parse the c|m-year-month-day option
    private function _date_format($key) {
        $year = (strpos($key, 'year') !== false) ? '%Y' : '';
        $month = (strpos($key, 'month') !== false) ? '%m' : '';
        $day = (strpos($key, 'day') !== false) ? '%d' : '';
        $format = $year . (($year != '' && ($month != '' || $day != '')) ? '-' : '');
        $format .= $month . ($month != '' && $day != '' ? '-' : '');
        $format .= $day;
        return $format;
    }

    // sort by each sorting array, in order
    private function _sort_results(&$ids, &$sort_opts) {
        if (!empty($sort_opts)) {
            $args = array();
            foreach ($sort_opts as &$sort_opt) {
                $args[] = &$sort_opt['keys'];
                $args[] = &$sort_opt['dir'];
            }
            $args[] = &$ids;
            call_user_func_array('array_multisort', $args);
        }
    }
    
    private function _group_results(&$ids, &$sort_opts) {
        $prevs = array();
        $results = array();
        $level = count($sort_opts) - 1;
        $idx = 0;
        foreach($ids as $id) {
            $this->_add_heading($results, $sort_opts, $level, $idx, $prevs);
            $results[] = $id;
            $idx++;
        }
        return $results;
    }
    
    private function _add_heading(&$results, &$sort_opts, $level, $idx, &$prevs) {
        if ($level > 0) {
            // recurse to find all parent headings
            $this->_add_heading($results, $sort_opts, $level - 1, $idx, $prevs);
        }
        $group = $sort_opts[$level]['group'];
        // only if this sort array can be grouped....
        if ($group) {
            $prev = (isset($prevs[$level])) ? $prevs[$level] : '';
            $cur = $sort_opts[$level]['keys'][$idx];
            if ($cur != $prev) {
                $prevs[$level] = $cur;
                $h = 'h' . ($level + 1);
                // display months and days in real words
                if ($this->inwords) {
                    $format = $sort_opts[$level]['format'];
                    switch ($format) {
                        case '%m':
                            $cur = strftime("%B", mktime(0, 0, 0, $cur, 10));
                            break;
                        case '%d':
                            $cur = strftime("%#d, %A ", mktime(0, 0, 0, 0, $cur));
                            break;
                        case '%Y-%m':
                            $cur = strftime("%B %Y", mktime(0, 0, 0, substr($cur, 5, 2), 10, substr($cur, 0, 4)));
                            break;
                        case '%m-%d':
                            $cur = strftime("%B %#d, %A ", mktime(0, 0, 0, substr($cur, 0, 2), substr($cur, 3, 2)));
                            break;
                        case '%Y-%m-%d':
                            $cur = strftime("%A, %B %#d, %Y", mktime(0, 0, 0, substr($cur, 5, 2), substr($cur, 8, 2), substr($cur, 0, 4)));
                            break;
                    }
                }
                // space in front ensures that ucwords works
                $results[] = "<$h> $cur</$h>";
            }
        }
    }

    /**
     * based wholely on _ft_pageLookup in inc/fulltext.php
     * I just removed the preg_quote line to enable regexes in search query...
     * and the unnecessary usort line as I have my own sort routines
     *
     */
    private function _pageLookup($query, $pageonly) {

        global $conf;
        //$id    = preg_quote($id,'/');
        //if (empty($query)) $query = '.*';   // defaults to everything
        $query = trim($query);
        $pages = file($conf['indexdir'].'/page.idx');
        $pages = array_values(preg_grep('/'.$query.'/',$pages));

        $cnt = count($pages);
        for($i=0; $i<$cnt; $i++){
            if($pageonly){
                if(!preg_match('/'.$query.'/',noNS($pages[$i]))){
                    unset($pages[$i]);
                    continue;
                }
            }
            if(!page_exists($pages[$i])){
                unset($pages[$i]);
                continue;
            }
        }

        $pages = array_filter($pages,'isVisiblePage'); // discard hidden pages
        if(!count($pages)) return array();

        // check ACL permissions
        foreach(array_keys($pages) as $idx){
            if(auth_quickaclcheck(trim($pages[$idx])) < AUTH_READ){
                unset($pages[$idx]);
            }
        }

        $pages = array_map('trim',$pages);
        //usort($pages,'ft_pagesorter');
        return $pages;
    }
}

blob
mark :12
data 21485
<?php
/**
 * PageQuery Plugin: search for and list pages
 *
 * @license    GPL 2 (http://www.gnu.org/licenses/gpl.html)
 * @author	   Symon Bent <symonbent@gmail.com>
 */
// must be run within Dokuwiki
if(!defined('DOKU_INC')) die();

if (!defined('DOKU_LF')) define('DOKU_LF', "\n");
if (!defined('DOKU_TAB')) define('DOKU_TAB', "\t");
if (!defined('DOKU_PLUGIN')) define('DOKU_PLUGIN',DOKU_INC.'lib/plugins/');

require_once(DOKU_PLUGIN.'syntax.php');
require_once(DOKU_INC.'inc/fulltext.php');

//Default max tagits displayed
define('PAGE_LIMIT', 50);

class syntax_plugin_pagequery extends DokuWiki_Syntax_Plugin {
    private $dformat = '';
    private $inwords = false;
    private $nostart = false;

	function getInfo() {
		$desc = file_get_contents(DOKU_PLUGIN . 'pagequery/readme.txt');
		return array(
			'author' => 'Symon Bent', 
			'email'  => 'symonbent@gmail.com',
			'date'   => '2010-04-09',
			'name'   => 'Pagequery Plugin',
			'desc'   => empty($desc) ? 'readme.txt is missing!' : $desc,
			'url'    => 'http://wiki.splitbrain.org/plugin:pagequery',
		);
	}

	function getType() {
		return 'substition';
	}
	
	function getPType() {
		return 'block';
	}
	
	function getSort() {
		return 98;
	}

	function connectTo($mode) {
		//Default is a word cloud style, looks good when combined with plugin:box
		$this->Lexer->addSpecialPattern('\{\{pagequery>.*?\}\}', $mode, 'plugin_pagequery');
	}
    /**
     * Parses all the pagequery options:
     * Insert the pagequery markup wherever you want your list to appear. E.g:
     *
     *   {{pagequery>}}
     *
     *   {{pagequery>[query];fulltext;sort=key:direction,key2:direction;group;limit=??;cols=?;inwords;proper}}
     * 
     * Parameters as follows:
     * 1. query:    any expression directly after the >; can use all Dokuwiki search options (see manual)
     * 2. fulltext: use a full-text search, instead of page_id only [default]
     * 3. sort:     keys to sort by, in order of sorting. Each key can be followed by prefered sorting order
     *              available keys:
     *                  a, ab, abc          by 1st letter, 2 letters, or 3 letters
     *                  name                by page name (no namespace) [not grouped]
     *                  page|id             by full page id, including namespace [not grouped]
     *                  ns                  by namespace (without page name)
     *                  mdate, cdate        by modified|created dates (full) [not grouped]
     *                  m[year][month][day] by modified [year][month][day]; any combination accepted
     *                  c[year][month][day] by created [year][month][day]; any combination accepted
     *                  creator             by page author
     *              date sort default to descending, string sorts to ascending
     * 4. group:    show group headers for each change in sort keys
     *              Note: keys with no duplicated cannot be grouped (i.e. name, page|id, mdate, cdate)
     * 5. limit:    maximum number of results to return
     * 6. inwords:  use real month and day names instead of just numbers
     * 7. cols:     number of columns in displayed list (max = 4)
     * 8. proper:   display page names and namespace in Proper Case (i.e. no _'s and Capitalised)
                    header/hdr = group headers only, name = page name only, both = both!
     * 9. border:   turn on borders
     *10. fullregex:only useful on page name searches; allows a raw regex mode on the full page idate
     *11. nostart:  ignore any 'start' pages in namespace
     *
     * All options are optional, and the list will default to a boring long 1-column list...
     */
	function handle($match, $state, $pos, &$handler) {
        global $conf;
        $this->dformat = $conf['dformat'];
        
		$match = substr($match, 12, -2); // strip markup incl. tagit>
		$args = explode(';', $match);
        $query = $args[0];
        $fulltext = false;
        $sort = array();
        $group = false;
        $limit = PAGE_LIMIT;
        $proper = 'none';
        $cols = 1;
        $border = false;
        foreach ($args as $arg) {
            list($key, $value) = explode('=', $arg);
            switch ($key) {
                case 'fulltext':
                    $fulltext = true;
                    break;
                case 'sort':
                    $values = explode(',', $value);
                    foreach ($values as $value) {
                        list($key, $dir) = explode(':', $value);
                        $sort[] = array($key, $dir);
                    }
                    break;
                case 'group':
                    $group = true;
                    break;
                case 'limit':
                    $limit = $value;
                    break;
                case 'inwords':
                    $inwords = true;
                    break;
                case 'proper':
                    switch ($value) {
                        case 'hdr':
                        case 'header':
                        case 'group':
                            $proper = 'header';
                            break;
                        case 'name':
                        case 'page':
                            $proper = 'name';
                            break;
                        default:
                            $proper = 'both';
                    }
                    break;
                case 'cols':
                    $cols = ($value > 4) ? 4 : $value;
                    break;
                case 'border':
                    $border = true;
                    break;
				case 'fullregex':
					$fullregex = true;
					break;
                case 'nostart':
                    $nostart = true;
                    break;
            }
        }
		return array($query, $fulltext, $sort, $group, $limit, $proper, $cols, $inwords, $border, $fullregex, $nostart);
	}

    function render($mode, &$renderer, $data) {
        $sortkeys = array();
        list($query, $fulltext, $sort, $group, $limit, $proper, $cols, $inwords, $border, $fullregex, $nostart) = $data;
        $this->inwords = $inwords;
        $this->nostart = $nostart;
        
        if ($mode == 'xhtml') {
            // first get a raw list of matching results
            if ($fulltext) {
                $results = array_keys(ft_pageSearch($query, $highlight));
            } else {
                // allow for raw regex mode, for power users, this searches the full page id
                if ($fullregex) {
                    $full_query = $query;
                    $pageonly = false;
                } else {
                    list($full_query, $pageonly) = $this->_parse_ns_query($query);
                }
                $results = $this->_pageLookup($full_query, $pageonly);
            }
            // basic result page markup (always needed)
            $border_css = ($border === false) ? ' style="border-style:none;"' : '';
            $renderer->doc .= '<div id="pagequery">' . DOKU_LF;
            $renderer->doc .= '<table><tbody><tr>' . DOKU_LF;
            
            // display a "no results" message if empty
            if (empty($results)) {
                $renderer->doc .= '<td><p>' . $this->getLang("no_results") . 
                                  '"<strong>' . $query . '</strong>"</p></td>';
            } else {
                // prepare the necessary sorting arrays, as per options
                $sort_opts = $this->_get_sort_opts($results, $sort);
                // now do the sorting
                $this->_sort_results($results, $sort_opts);
                // and finally the grouping
                if ($group) {
                    $results = $this->_group_results($results, $sort_opts);
                }
                $was_heading = false;
                $idx = 0;
                $col = 0;
                $rows = ceil(count($results) / $cols);  // proposed column row size
                $width = floor(100 / $cols);
                // remove indenting if not grouped
                $indent_css = ($group === false) ? ' class="nogroup"' : '';

                foreach ($results as $id) {
                    // are we ready to start a new column? (up to max allowed)
                    if ($col < $cols && $idx % $rows == 0) {
                        $ready_for_col = true;
                        $col++;
                    }
                    $is_heading = ($id[0] == '<');
                    // Only start if we are at a heading or if there is no grouping
                    if ($ready_for_col && ($idx == 0 || $is_heading || !$group)) {
                        // close the previous column if necessary
                        $close = ($idx > 0) ? '</ul></td>' . DOKU_LF : '';
                        $renderer->doc .= $close . '<td' . $border_css . ' valign="top" width="' . $width . '%">' . DOKU_LF;
                        $ready_for_col = false;
                        $was_heading = true;    //needed to begin a new page id list
                    }
                    if ($is_heading) {
                        // deal with headers (already marked up)
                        if (!$was_heading) $renderer->doc .= '</ul>' . DOKU_LF;
                        if ($proper == 'header' || $proper == 'both') $id = $this->_proper($id);
                        $renderer->doc .= $id . DOKU_LF;
                        $was_heading = true;
                    } else {
                        // normal page links
                        if ($was_heading || $idx == 0) $renderer->doc .= '<ul' . $indent_css . '>';
                        if ($proper == 'name' || $proper == 'both') {
                            $name = $this->_proper(noNS($id));
                        } else {
                            $name = '';
                        }
                        $id = (strpos($id, ':') === false) ? ':' . $id : $id;   // : needed for root pages
                        // swap normal link title (popup) for a more useful preview
                        $link = $this->_wikilink_preview_popup($id, $name);
                        $renderer->doc .= '<li>' . $link . '</li>' . DOKU_LF;
                        $was_heading = false;
                    }
                    $idx++;
                }
                $renderer->doc .= '</ul></td>';
            }
            $renderer->doc .= '</tr>' . DOKU_LF;
            $renderer->doc .= '</tbody></table>';
            $renderer->doc .= '</div>' . DOKU_LF;
        } else {
            return false;
        }
    }

    private function _proper($id) {
         $id = str_replace(':', ' : ', $id);
         $id = str_replace('_', ' ', $id);
         $id = ucwords($id);
         return $id;
    }
    /**
     * swap normal link title (popup) for a more useful preview
     *
     * @param string $id    page id
     * @param string $name  display name
     * @return complete href link 
     */
    private function _wikilink_preview_popup($id, $name) {
        $link = html_wikilink($id, $name);
        $meta = p_get_metadata($id, false, true);
        $preview = $meta['description']['abstract'] . '... ';
        $preview = str_replace("\n", '  ', $preview);
        $link = preg_replace('/title=\".+?\"/', 'title="' . $preview . '"', $link, 1);
        return $link;
    }

    /**
     * Parse out the namespace, and convert to a regex for array search
     * -or- ensures that normal search are only within pagename not its namespace
     *
     * @param string $query user page query
     * @return processed query with regex markup as needed for namespace recognition
     */
    private function _parse_ns_query($query) {
        $incl_ns = preg_match('`(@|ns:)(\w+(\:\w+)*)(\s.+)*`', $query, $matches);
        if ($incl_ns > 0) {
            $ns = $matches[2];
            $page = trim($matches[4]);
            if ($page == '*') $page = '.*';
            $ns_query = $ns . ":.*" . $page;
            return array($ns_query, false);
        }
        $excl_ns = preg_match('`(\^|-ns:)(\w+(\:\w+)*)(\s.+)*`', $query, $matches);
        if ($excl_ns > 0) {
            $ns = $matches[2];
            $page = trim($matches[4]);
            if ($page == '*') $page = '.*';
            $ns_query = '^(?!' . $ns . '):.*' . $page;
            return array($ns_query, false);
        }
		if ($query == '*') $query= '.*';
        return array($query, true);	// true => turns on pageonly lookup
    }

    /**
     * Builds a separate sorting array for each sortby key
     *
     * @param string    $id         wiki page id
     * @param array     $sortby     keys to use for sorting
     * @param arrayref  $sortkeys   ref to sorting arrays
     * @return void
     */
    private function _get_sort_opts($ids, $sortkeys) {
        $sort_opts = array();
        foreach ($ids as $id) {
            $meta = p_get_metadata ($id, false, true);
            if (!isset($meta['date']['modified'])) {
                $meta['date']['modified'] = $meta['date']['created'];
            }
            $idx = 0;
            foreach ($sortkeys as $sortkey) {
                $key = $sortkey[0];
                switch ($key) {
                    case 'a':
                        $value = $this->_first(noNS($id), 1);
                        break;
                    case 'ab':
                        $value = $this->_first(noNS($id), 2);
                        break;
                    case 'abc':
                        $value = $this->_first(noNS($id), 3);
                        break;
                    case 'name':
                        $value = noNS($id);
                        break;
                    case 'id':
                    case 'page':
                        $value = $id;
                        break;
                    case 'ns':
                        $value = getNS($id);
                        if (empty($value)) $value = '(start)';
                        break;
                    case 'creator':
                        $value = $meta['creator'];
                        break;
                    case 'mdate':
                        $value = date($this->dformat, $meta['date']['modified']);
                        break;
                    case 'cdate':
                        $value = date($this->dformat, $meta['date']['created']);
                        break;
                    default:
                        $dtype = $key[0];
                        // the date formats are cached on first use; assumes one modifed & created per set
                        if ($dtype == 'c' || $dtype == 'm') {
                            if (!isset($dformat[$key])) {
                                $dformat[$key] = $this->_date_format($key);
                                $sort_opts[$idx]['format'] = $dformat[$key];
                            }
                            if ($dtype == 'c') {
                                $value = strftime($dformat[$key], $meta['date']['created']);
                            } elseif ($dtype == 'm') {
                                $value = strftime($dformat[$key], $meta['date']['modified']);
                            }
                        }
                }
                $sort_opts[$idx]['keys'][] = $value;
                $idx += 1;
            }
        }
        $idx = 0;
        foreach ($sortkeys as $sortkey) {
            list($key, $dir) = $sortkey;
            // now the sort direction
            switch ($dir) {
                case 'asc':
                    $dir = SORT_ASC;
                    break;
                case 'desc':
                    $dir = SORT_DESC;
                    break;
                default:
                    // sort descending by default; text ascending
                    if ($key[0] == 'c' || $key[0] == 'm') {
                        $dir = SORT_DESC;
                    } else {
                        $dir = SORT_ASC;
                    }
            }
            $sort_opts[$idx]['dir'] = $dir;
            // and finally set the sort array's data type (for correct markup purposes)
            switch ($key) {
                // full-text and complete dates cannot meaningfully be grouped (no duplicates!)
                case 'mdate':
                case 'cdate':
                case 'name':
                case 'id':
                case 'page':
                    $group = false;
                    break;
                default:
                    $group = true;
            }
            $sort_opts[$idx]['group'] = $group;
            $idx += 1;
        }
        return $sort_opts;
    }

    // returns first $count letters from $text
    private function _first($text, $count) {
        if ($count > 0) {
            return substr($text, 0, $count);
        }
    }

    // parse the c|m-year-month-day option
    private function _date_format($key) {
        $year = (strpos($key, 'year') !== false) ? '%Y' : '';
        $month = (strpos($key, 'month') !== false) ? '%m' : '';
        $day = (strpos($key, 'day') !== false) ? '%d' : '';
        $format = $year . (($year != '' && ($month != '' || $day != '')) ? '-' : '');
        $format .= $month . ($month != '' && $day != '' ? '-' : '');
        $format .= $day;
        return $format;
    }

    // sort by each sorting array, in order
    private function _sort_results(&$ids, &$sort_opts) {
        if (!empty($sort_opts)) {
            $args = array();
            foreach ($sort_opts as &$sort_opt) {
                $args[] = &$sort_opt['keys'];
                $args[] = &$sort_opt['dir'];
            }
            $args[] = &$ids;
            call_user_func_array('array_multisort', $args);
        }
    }
    
    private function _group_results(&$ids, &$sort_opts) {
        $prevs = array();
        $results = array();
        $level = count($sort_opts) - 1;
        $idx = 0;
        foreach($ids as $id) {
            $this->_add_heading($results, $sort_opts, $level, $idx, $prevs);
            $results[] = $id;
            $idx++;
        }
        return $results;
    }
    
    private function _add_heading(&$results, &$sort_opts, $level, $idx, &$prevs) {
        if ($level > 0) {
            // recurse to find all parent headings
            $this->_add_heading($results, $sort_opts, $level - 1, $idx, $prevs);
        }
        $group = $sort_opts[$level]['group'];
        // only if this sort array can be grouped....
        if ($group) {
            $prev = (isset($prevs[$level])) ? $prevs[$level] : '';
            $cur = $sort_opts[$level]['keys'][$idx];
            if ($cur != $prev) {
                $prevs[$level] = $cur;
                $h = 'h' . ($level + 1);
                // display months and days in real words
                if ($this->inwords) {
                    $format = $sort_opts[$level]['format'];
                    switch ($format) {
                        case '%m':
                            $cur = strftime("%B", mktime(0, 0, 0, $cur, 10));
                            break;
                        case '%d':
                            $cur = strftime("%#d, %A ", mktime(0, 0, 0, 0, $cur));
                            break;
                        case '%Y-%m':
                            $cur = strftime("%B %Y", mktime(0, 0, 0, substr($cur, 5, 2), 10, substr($cur, 0, 4)));
                            break;
                        case '%m-%d':
                            $cur = strftime("%B %#d, %A ", mktime(0, 0, 0, substr($cur, 0, 2), substr($cur, 3, 2)));
                            break;
                        case '%Y-%m-%d':
                            $cur = strftime("%A, %B %#d, %Y", mktime(0, 0, 0, substr($cur, 5, 2), substr($cur, 8, 2), substr($cur, 0, 4)));
                            break;
                    }
                }
                // space in front ensures that ucwords works
                $results[] = "<$h> $cur</$h>";
            }
        }
    }

    /**
     * heavily customised version of _ft_pageLookup in inc/fulltext.php
     * I just removed the preg_quote line to enable regexes in search query...
     * and the unnecessary usort line as I have my own sort routines
     *
     */
    private function _pageLookup($query, $pageonly) {
        global $conf;
        
        $query = trim($query);
        $pages = file($conf['indexdir'].'/page.idx');
        $pages = array_values(preg_grep('/'.$query.'/', $pages));

        $cnt = count($pages);
        for($i = 0; $i < $cnt; $i++){
            if($pageonly){
                if(!preg_match('/'.$query.'/',noNS($pages[$i]))){
                    unset($pages[$i]);
                    continue;
                }
            }
            if(!page_exists($pages[$i])){
                unset($pages[$i]);
                continue;
            }
        }

        $pages = array_filter($pages, 'isVisiblePage'); // discard hidden pages
        if(!count($pages)) return array();

        $pages = array_map('trim',$pages);
        
        // check ACL permissions and remove any 'start' pages if req'd
        $start = $conf['start'];
        $pos = strlen($start);
        foreach($pages as $idx => $name) {
            if ($this->nostart && substr($name, -$pos) == $start) {
                unset($pages[$idx]);
            } elseif(auth_quickaclcheck(trim($pages[$idx])) < AUTH_READ){
                unset($pages[$idx]);
            }
        }
        return $pages;
    }
}

blob
mark :14
data 1931
Insert the pagequery markup wherever you want your list to appear.
--------
E.g.{{pagequery>[query];fulltext;sort=key:direction,key2:direction;group;limit=??;cols=?;inwords;proper}}
--------
Parameters as follows:
1. query: any expression directly after the >; can use all Dokuwiki search options (see manual)
Limit to namespace: @namespace.  Page name searches accept regex
2. fulltext: use a full-text search, instead of page_id only [default]
3. sort: keys to sort by, in order of sorting. Each key can be followed by prefered sorting order
E.g. sort=name:asc -or- sort=a,name [default direction = asc]
Available keys:
* a, ab, abc          by 1st letter, 2 letters, or 3 letters
* name                by page name (no namespace) [not grouped]
* page|id             by full page id, including namespace [not grouped]
* ns                  by namespace (without page name)
* mdate, cdate        by modified|created dates (full) [not grouped]
* m[year][month][day] by modified [year][month][day]; any combination accepted
* c[year][month][day] by created [year][month][day]; any combination accepted
* creator             by page author
Sort Directions:
* asc => ascending (A-Z); desc => descending (Z-A)
Note: date sort default to descending, string sorts to ascending
4. group: show group headers for each change in sort keys. Note: keys with no duplicated cannot be grouped (i.e. name, page|id, mdate, cdate)
5. limit: maximum number of results to return
6. inwords: use real month and day names instead of just numbers
7. cols: number of columns in displayed list (max = 4) e.g cols=3
8. proper: display page names and namespace in Proper Case; =header =name =both
9. nostart: ignore any start pages in the given namespace
10. fullregex: search full page id using regular expressions (power-user option)

----
All options are optional, and the list will default to a boring long 1-column list...
blob
mark :15
data 969
div.dokuwiki div#pagequery h1,
div.dokuwiki div#pagequery h2,
div.dokuwiki div#pagequery h3,
div.dokuwiki div#pagequery h4,
div.dokuwiki div#pagequery h5 {
    /*padding:0.1em 0 0;*/
    margin:0;
    margin-bottom:0.4em;
    color:gray;
}
div.dokuwiki div#pagequery h1 {}
div.dokuwiki div#pagequery h2 {margin-left:0.5em}
div.dokuwiki div#pagequery h3 {margin-left:1em}
div.dokuwiki div#pagequery h4 {margin-left:1.5em}
div.dokuwiki div#pagequery h5 {margin-left:2em}

div.dokuwiki div#pagequery table {
    border-collapse:collapse;
    width:99%;
}
div.dokuwiki div#pagequery td {
	border-width:1px;
	padding:5px 10px;
	border-style:solid;
	border-color:#D7D5D4;
	background-color:white;
}
div.dokuwiki div#pagequery ul {
    list-style:none;
    margin:0 0 0.7em 2.5em;
	text-align:left;
}
div.dokuwiki div#pagequery li {
	padding-left:0.6em; 
	list-style-position:inside; 
	text-indent:-0.6em
}
div.dokuwiki div#pagequery ul.nogroup {
    margin:0 0 0.7em 0.2em;
}
blob
mark :16
data 22111
<?php
/**
 * PageQuery Plugin: search for and list pages
 *
 * @license    GPL 2 (http://www.gnu.org/licenses/gpl.html)
 * @author	   Symon Bent <symonbent@gmail.com>
 */
// must be run within Dokuwiki
if(!defined('DOKU_INC')) die();

if (!defined('DOKU_LF')) define('DOKU_LF', "\n");
if (!defined('DOKU_TAB')) define('DOKU_TAB', "\t");
if (!defined('DOKU_PLUGIN')) define('DOKU_PLUGIN',DOKU_INC.'lib/plugins/');

require_once(DOKU_PLUGIN.'syntax.php');
require_once(DOKU_INC.'inc/fulltext.php');

class syntax_plugin_pagequery extends DokuWiki_Syntax_Plugin {
    private $dformat = '';
    private $inwords = false;
    private $nostart = false;

	function getInfo() {
		$desc = file_get_contents(DOKU_PLUGIN . 'pagequery/readme.txt');
		return array(
			'author' => 'Symon Bent', 
			'email'  => 'hendrybadao@gmail.com',
			'date'   => '2010-05-05',
			'name'   => 'Pagequery Plugin',
			'desc'   => empty($desc) ? 'readme.txt is missing!' : $desc,
			'url'    => 'http://wiki.splitbrain.org/plugin:pagequery',
		);
	}

	function getType() {
		return 'substition';
	}
	
	function getPType() {
		return 'block';
	}
	
	function getSort() {
		return 98;
	}

	function connectTo($mode) {
		//Default is a word cloud style, looks good when combined with plugin:box
		$this->Lexer->addSpecialPattern('\{\{pagequery>.*?\}\}', $mode, 'plugin_pagequery');
	}
    /**
     * Parses all the pagequery options:
     * Insert the pagequery markup wherever you want your list to appear. E.g:
     *
     *   {{pagequery>}}
     *
     *   {{pagequery>[query];fulltext;sort=key:direction,key2:direction;group;limit=??;cols=?;inwords;proper}}
     * 
     * Parameters as follows:
     * 1. query:    any expression directly after the >; can use all Dokuwiki search options (see manual)
     * 2. fulltext: use a full-text search, instead of page_id only [default]
     * 3. sort:     keys to sort by, in order of sorting. Each key can be followed by prefered sorting order
     *              available keys:
     *                  a, ab, abc          by 1st letter, 2 letters, or 3 letters
     *                  name                by page name (no namespace) [not grouped]
     *                  page|id             by full page id, including namespace [not grouped]
     *                  ns                  by namespace (without page name)
     *                  mdate, cdate        by modified|created dates (full) [not grouped]
     *                  m[year][month][day] by modified [year][month][day]; any combination accepted
     *                  c[year][month][day] by created [year][month][day]; any combination accepted
     *                  creator             by page author
     *              date sort default to descending, string sorts to ascending
     * 4. group:    show group headers for each change in sort keys
     *              Note: keys with no duplicated cannot be grouped (i.e. name, page|id, mdate, cdate)
     * 5. limit:    maximum number of results to return
     * 6. inwords:  use real month and day names instead of just numbers
     * 7. cols:     number of columns in displayed list (max = 4)
     * 8. proper:   display page names and namespace in Proper Case (i.e. no _'s and Capitalised)
                    header/hdr = group headers only, name = page name only, both = both!
     * 9. border:   turn on borders
     *10. fullregex:only useful on page name searches; allows a raw regex mode on the full page idate
     *11. nostart:  ignore any 'start' pages in namespace
     *
     * All options are optional, and the list will default to a boring long 1-column list...
     */
	function handle($match, $state, $pos, &$handler) {
        global $conf;
        $this->dformat = $conf['dformat'];
        
		$match = substr($match, 12, -2); // strip markup incl. tagit>
		$args = explode(';', $match);
        $query = $args[0];
        $fulltext = false;
        $sort = array();
        $group = false;
        //Default max tagits displayed. '0' => no limit
        $limit = 0;
        $proper = 'none';
        $cols = 1;
        $border = false;
        foreach ($args as $arg) {
            list($key, $value) = explode('=', $arg);
            switch ($key) {
                case 'fulltext':
                    $fulltext = true;
                    break;
                case 'sort':
                    $values = explode(',', $value);
                    foreach ($values as $value) {
                        list($key, $dir) = explode(':', $value);
                        $sort[] = array($key, $dir);
                    }
                    break;
                case 'group':
                    $group = true;
                    break;
                case 'limit':
                    $limit = $value;
                    break;
                case 'inwords':
                    $inwords = true;
                    break;
                case 'proper':
                    switch ($value) {
                        case 'hdr':
                        case 'header':
                        case 'group':
                            $proper = 'header';
                            break;
                        case 'name':
                        case 'page':
                            $proper = 'name';
                            break;
                        default:
                            $proper = 'both';
                    }
                    break;
                case 'cols':
                    $cols = ($value > 4) ? 4 : $value;
                    break;
                case 'border':
                    $border = true;
                    break;
				case 'fullregex':
					$fullregex = true;
					break;
                case 'nostart':
                    $nostart = true;
                    break;
            }
        }
		return array($query, $fulltext, $sort, $group, $limit, $proper, $cols, $inwords, $border, $fullregex, $nostart);
	}

    function render($mode, &$renderer, $data) {
        $sortkeys = array();
        list($query, $fulltext, $sort, $group, $limit, $proper, $cols, $inwords, $border, $fullregex, $nostart) = $data;
        $this->inwords = $inwords;
        $this->nostart = $nostart;
        
        if ($mode == 'xhtml') {
            // first get a raw list of matching results
            if ($fulltext) {
                $results = array_keys(ft_pageSearch($query, $highlight));
            } else {
                // allow for raw regex mode, for power users, this searches the full page id
                if ($fullregex) {
                    $full_query = $query;
                    $pageonly = false;
                } else {
                    list($full_query, $pageonly) = $this->_parse_ns_query($query);
                }
                $results = $this->_pageLookup($full_query, $pageonly);
            }
            // basic result page markup (always needed)
            $border_css = ($border === false) ? ' style="border-style:none;"' : '';
            $renderer->doc .= '<div id="pagequery">' . DOKU_LF;
            $renderer->doc .= '<table><tbody><tr>' . DOKU_LF;
            
            // display a "no results" message if empty
            if (empty($results)) {
                $renderer->doc .= '<td><p>' . $this->getLang("no_results") . 
                                  '"<strong>' . $query . '</strong>"</p></td>';
            } else {
                // prepare the necessary sorting arrays, as per options
                $sort_opts = $this->_get_sort_opts($results, $sort);
                // now do the sorting
                $this->_sort_results($results, $sort_opts);
                // limit the result list length if required
                // remember: this can only be done after sorting!
                $results = ($limit > 0) ? array_slice($results, 0, $limit) : $results;
                // and finally the grouping
                if ($group) {
                    $results = $this->_group_results($results, $sort_opts);
                }
                $was_heading = false;
                $idx = 0;
                $col = 0;
                $rows = ceil(count($results) / $cols);  // proposed column row size
                $width = floor(100 / $cols);
                // remove indenting if not grouped
                $indent_css = ($group === false) ? ' class="nogroup"' : '';

                foreach ($results as $id) {
                    // are we ready to start a new column? (up to max allowed)
                    if ($col < $cols && $idx % $rows == 0) {
                        $ready_for_col = true;
                        $col++;
                    }
                    $is_heading = ($id[0] == '<');
                    // Only start if we are at a heading or if there is no grouping
                    if ($ready_for_col && ($idx == 0 || $is_heading || !$group)) {
                        // close the previous column if necessary
                        $close = ($idx > 0) ? '</ul></td>' . DOKU_LF : '';
                        $renderer->doc .= $close . '<td' . $border_css . ' valign="top" width="' . $width . '%">' . DOKU_LF;
                        $ready_for_col = false;
                        $was_heading = true;    //needed to begin a new page id list
                    }
                    if ($is_heading) {
                        // deal with headers (already marked up)
                        if (!$was_heading) $renderer->doc .= '</ul>' . DOKU_LF;
                        if ($proper == 'header' || $proper == 'both') $id = $this->_proper($id);
                        $renderer->doc .= $id . DOKU_LF;
                        $was_heading = true;
                    } else {
                        // normal page links
                        if ($was_heading || $idx == 0) $renderer->doc .= '<ul' . $indent_css . '>';
                        if ($proper == 'name' || $proper == 'both') {
                            $name = $this->_proper(noNS($id));
                        } else {
                            $name = '';
                        }
                        $id = (strpos($id, ':') === false) ? ':' . $id : $id;   // : needed for root pages
                        // swap normal link title (popup) for a more useful preview
                        $link = $this->_wikilink_preview_popup($id, $name);
                        $renderer->doc .= '<li>' . $link . '</li>' . DOKU_LF;
                        $was_heading = false;
                    }
                    $idx++;
                }
                $renderer->doc .= '</ul></td>';
            }
            $renderer->doc .= '</tr>' . DOKU_LF;
            $renderer->doc .= '</tbody></table>';
            $renderer->doc .= '</div>' . DOKU_LF;
        } else {
            return false;
        }
    }

    private function _proper($id) {
         $id = str_replace(':', ': ', $id);
         $id = str_replace('_', ' ', $id);
         $id = ucwords($id);
         $id = str_replace(': ', ':', $id);
         return $id;
    }
    /**
     * swap normal link title (popup) for a more useful preview
     *
     * @param string $id    page id
     * @param string $name  display name
     * @return complete href link 
     */
    private function _wikilink_preview_popup($id, $name) {
        $link = html_wikilink($id, $name);
        $meta = p_get_metadata($id, false, true);
        $preview = $meta['description']['abstract'] . '... ';
        $preview = str_replace("\n", '  ', $preview);
        $link = preg_replace('/title=\".+?\"/', 'title="' . $preview . '"', $link, 1);
        return $link;
    }

    /**
     * Parse out the namespace, and convert to a regex for array search
     * -or- ensures that normal search are only within pagename not its namespace
     *
     * @param string $query user page query
     * @return processed query with regex markup as needed for namespace recognition
     */
    private function _parse_ns_query($query) {
        $incl_ns = preg_match('`(@|ns:)(\w+(\:\w+)*)(\s.+)*`', $query, $matches);
        if ($incl_ns > 0) {
            $ns = $matches[2];
            $page = trim($matches[4]);
            if ($page == '*') $page = '.*';
            $ns_query = $ns . ":.*" . $page;
            return array($ns_query, false);
        }
        $excl_ns = preg_match('`(\^|-ns:)(\w+(\:\w+)*)(\s.+)*`', $query, $matches);
        if ($excl_ns > 0) {
            $ns = $matches[2];
            $page = trim($matches[4]);
            if ($page == '*') $page = '.*';
            $ns_query = '^(?!' . $ns . '):.*' . $page;
            return array($ns_query, false);
        }
		if ($query == '*') $query= '.*';
        return array($query, true);	// true => turns on pageonly lookup
    }

    /**
     * Builds a separate sorting array for each sortby key
     *
     * @param string    $id         wiki page id
     * @param array     $sortby     keys to use for sorting
     * @param arrayref  $sortkeys   ref to sorting arrays
     * @return void
     */
    private function _get_sort_opts($ids, $sortkeys) {
        $sort_opts = array();
        foreach ($ids as $id) {
            $meta = p_get_metadata ($id, false, true);
            if (!isset($meta['date']['modified'])) {
                $meta['date']['modified'] = $meta['date']['created'];
            }
            $idx = 0;
            foreach ($sortkeys as $sortkey) {
                $key = $sortkey[0];
                switch ($key) {
                    case 'a':
                        $value = $this->_first(noNS($id), 1);
                        break;
                    case 'ab':
                        $value = $this->_first(noNS($id), 2);
                        break;
                    case 'abc':
                        $value = $this->_first(noNS($id), 3);
                        break;
                    case 'name':
                        $value = noNS($id);
                        break;
                    case 'id':
                    case 'page':
                        $value = $id;
                        break;
                    case 'ns':
                        $value = getNS($id);
                        if (empty($value)) $value = '(start)';
                        break;
                    case 'creator':
                        $value = $meta['creator'];
                        break;
                    case 'mdate':
                        $value = $meta['date']['modified'];
                        break;
                    case 'cdate':
                        $value = $meta['date']['created'];
                        break;
                    default:
                        $dtype = $key[0];
                        // the date formats are cached on first use; assumes one modifed & created per set
                        if ($dtype == 'c' || $dtype == 'm') {
                            if (!isset($dformat[$key])) {
                                $dformat[$key] = $this->_date_format($key);
                                $sort_opts[$idx]['format'] = $dformat[$key];
                            }
                            if ($dtype == 'c') {
                                $value = strftime($dformat[$key], $meta['date']['created']);
                            } elseif ($dtype == 'm') {
                                $value = strftime($dformat[$key], $meta['date']['modified']);
                            }
                        }
                }
                $sort_opts[$idx]['keys'][] = $value;
                $idx += 1;
            }
        }
        $idx = 0;
        foreach ($sortkeys as $sortkey) {
            list($key, $dir) = $sortkey;
            // now the sort direction
            switch ($dir) {
                case 'a':
                case 'asc':
                    $dir = SORT_ASC;
                    break;
                case 'd':
                case 'desc':
                    $dir = SORT_DESC;
                    break;
                default:
                    // sort descending by default; text ascending
                    if ($key[0] == 'c' || $key[0] == 'm') {
                        $dir = SORT_DESC;
                    } else {
                        $dir = SORT_ASC;
                    }
            }
            $sort_opts[$idx]['dir'] = $dir;
            // and finally set the sort array's data type (for correct markup purposes)
            switch ($key) {
                // full-text and complete dates cannot meaningfully be grouped (no duplicates!)
                case 'mdate':
                case 'cdate':
                case 'name':
                case 'id':
                case 'page':
                    $group = false;
                    break;
                default:
                    $group = true;
            }
            $sort_opts[$idx]['group'] = $group;
            // and now the sort data type
            switch ($key) {
                case 'mdate':
                case 'cdate':
                    $type = SORT_NUMERIC;
                    break;
                default:
                    $type = SORT_STRING;
            }
            $sort_opts[$idx]['type'] = $type;
            $idx += 1;
        }
        return $sort_opts;
    }

    // returns first $count letters from $text
    private function _first($text, $count) {
        if ($count > 0) {
            return substr($text, 0, $count);
        }
    }

    // parse the c|m-year-month-day option
    private function _date_format($key) {
        $year = (strpos($key, 'year') !== false) ? '%Y' : '';
        $month = (strpos($key, 'month') !== false) ? '%m' : '';
        $day = (strpos($key, 'day') !== false) ? '%d' : '';
        $format = $year . (($year != '' && ($month != '' || $day != '')) ? '-' : '');
        $format .= $month . ($month != '' && $day != '' ? '-' : '');
        $format .= $day;
        return $format;
    }

    // sort by each sorting array, in order
    private function _sort_results(&$ids, &$sort_opts) {
        if (!empty($sort_opts)) {
            $args = array();
            foreach ($sort_opts as &$sort_opt) {
                $args[] = &$sort_opt['keys'];
                $args[] = &$sort_opt['dir'];
                $args[] = &$sort_opt['type'];
            }
            $args[] = &$ids;
            call_user_func_array('array_multisort', $args);
        }
    }
    
    private function _group_results(&$ids, &$sort_opts) {
        $prevs = array();
        $results = array();
        $level = count($sort_opts) - 1;
        $idx = 0;
        foreach($ids as $id) {
            $this->_add_heading($results, $sort_opts, $level, $idx, $prevs);
            $results[] = $id;
            $idx++;
        }
        return $results;
    }
    
    private function _add_heading(&$results, &$sort_opts, $level, $idx, &$prevs) {
        if ($level > 0) {
            // recurse to find all parent headings
            $this->_add_heading($results, $sort_opts, $level - 1, $idx, $prevs);
        }
        $group = $sort_opts[$level]['group'];
        // only if this sort array can be grouped....
        if ($group) {
            $prev = (isset($prevs[$level])) ? $prevs[$level] : '';
            $cur = $sort_opts[$level]['keys'][$idx];
            if ($cur != $prev) {
                $prevs[$level] = $cur;
                $h = 'h' . ($level + 1);
                // display months and days in real words
                if ($this->inwords) {
                    $format = $sort_opts[$level]['format'];
                    switch ($format) {
                        case '%m':
                            $cur = strftime("%B", mktime(0, 0, 0, $cur, 10));
                            break;
                        case '%d':
                            $cur = strftime("%#d, %A ", mktime(0, 0, 0, 0, $cur));
                            break;
                        case '%Y-%m':
                            $cur = strftime("%B %Y", mktime(0, 0, 0, substr($cur, 5, 2), 10, substr($cur, 0, 4)));
                            break;
                        case '%m-%d':
                            $cur = strftime("%B %#d, %A ", mktime(0, 0, 0, substr($cur, 0, 2), substr($cur, 3, 2)));
                            break;
                        case '%Y-%m-%d':
                            $cur = strftime("%A, %B %#d, %Y", mktime(0, 0, 0, substr($cur, 5, 2), substr($cur, 8, 2), substr($cur, 0, 4)));
                            break;
                    }
                }
                // space in front ensures that ucwords works
                $results[] = "<$h> $cur</$h>";
            }
        }
    }

    /**
     * heavily customised version of _ft_pageLookup in inc/fulltext.php
     * I just removed the preg_quote line to enable regexes in search query...
     * and the unnecessary usort line as I have my own sort routines
     *
     */
    private function _pageLookup($query, $pageonly) {
        global $conf;
        
        $query = trim($query);
        $pages = file($conf['indexdir'].'/page.idx');
        $pages = array_values(preg_grep('/'.$query.'/', $pages));

        $cnt = count($pages);
        for($i = 0; $i < $cnt; $i++){
            if($pageonly){
                if(!preg_match('/'.$query.'/',noNS($pages[$i]))){
                    unset($pages[$i]);
                    continue;
                }
            }
            if(!page_exists($pages[$i])){
                unset($pages[$i]);
                continue;
            }
        }

        $pages = array_filter($pages, 'isVisiblePage'); // discard hidden pages
        if(!count($pages)) return array();

        $pages = array_map('trim',$pages);
        
        // check ACL permissions and remove any 'start' pages if req'd
        $start = $conf['start'];
        $pos = strlen($start);
        foreach($pages as $idx => $name) {
            if ($this->nostart && substr($name, -$pos) == $start) {
                unset($pages[$idx]);
            } elseif(auth_quickaclcheck(trim($pages[$idx])) < AUTH_READ){
                unset($pages[$idx]);
            }
        }
        return $pages;
    }
}

blob
mark :18
data 1282
div.dokuwiki div#pagequery h1,
div.dokuwiki div#pagequery h2,
div.dokuwiki div#pagequery h3,
div.dokuwiki div#pagequery h4,
div.dokuwiki div#pagequery h5 {
    /*padding:0.1em 0 0;*/
    margin:0;
    margin-bottom:0.4em;
    color:gray;
}
div.dokuwiki div#pagequery h1 {}
div.dokuwiki div#pagequery h2 {margin-left:0.5em}
div.dokuwiki div#pagequery h3 {margin-left:1em}
div.dokuwiki div#pagequery h4 {margin-left:1.5em}
div.dokuwiki div#pagequery h5 {margin-left:2em}

div.dokuwiki div#pagequery table {
    border-collapse:collapse;
    width:99%;
}
div.dokuwiki div#pagequery td {
	border-width:1px;
	padding:5px 10px;
	border-style:solid;
	border-color:#D7D5D4;
	background-color:white;
}
div.dokuwiki div#pagequery ul {
    list-style:none;
    margin:0 0 0.7em 2.5em;
	text-align:left;
}
div.dokuwiki div#pagequery li {
	padding-left:0.6em; 
	list-style-position:inside; 
	text-indent:-0.6em
}
div.dokuwiki div#pagequery ul.nogroup {
    margin:0 0 0.7em 0.2em;
}

div.dokuwiki div#pagequery blockquote {
    font-size:80%;
    -moz-border-radius: 6px;
    -webkit-border-radius: 6px;
	margin: 1em 3em 1em 3em !important;
	border: 1px dotted __border__ !important;
	background: #FAFACE url(images/blockquote.gif) no-repeat 0.3em 0.3em !important;
	padding: 1.2em !important;
}
blob
mark :19
data 24308
<?php
/**
 * PageQuery Plugin: search for and list pages
 *
 * @license    GPL 2 (http://www.gnu.org/licenses/gpl.html)
 * @author	   Symon Bent <symonbent@gmail.com>
 */
// must be run within Dokuwiki
if(!defined('DOKU_INC')) die();

if (!defined('DOKU_LF')) define('DOKU_LF', "\n");
if (!defined('DOKU_TAB')) define('DOKU_TAB', "\t");
if (!defined('DOKU_PLUGIN')) define('DOKU_PLUGIN',DOKU_INC.'lib/plugins/');

require_once(DOKU_PLUGIN.'syntax.php');
require_once(DOKU_INC.'inc/fulltext.php');

class syntax_plugin_pagequery extends DokuWiki_Syntax_Plugin {
    private $dformat = '';
    private $inwords = false;
    private $nostart = false;

	function getInfo() {
		$desc = file_get_contents(DOKU_PLUGIN . 'pagequery/readme.txt');
		return array(
			'author' => 'Symon Bent', 
			'email'  => 'hendrybadao@gmail.com',
			'date'   => '2010-05-05',
			'name'   => 'Pagequery Plugin',
			'desc'   => empty($desc) ? 'readme.txt is missing!' : $desc,
			'url'    => 'http://wiki.splitbrain.org/plugin:pagequery',
		);
	}

	function getType() {
		return 'substition';
	}
	
	function getPType() {
		return 'block';
	}
	
	function getSort() {
		return 98;
	}

	function connectTo($mode) {
		//Default is a word cloud style, looks good when combined with plugin:box
		$this->Lexer->addSpecialPattern('\{\{pagequery>.*?\}\}', $mode, 'plugin_pagequery');
	}
    /**
     * Parses all the pagequery options:
     * Insert the pagequery markup wherever you want your list to appear. E.g:
     *
     *   {{pagequery>}}
     *
     *   {{pagequery>[query];fulltext;sort=key:direction,key2:direction;group;limit=??;cols=?;inwords;proper}}
     * 
     * Parameters as follows:
     * 1. query:    any expression directly after the >; can use all Dokuwiki search options (see manual)
     * 2. fulltext: use a full-text search, instead of page_id only [default]
     * 3. sort:     keys to sort by, in order of sorting. Each key can be followed by prefered sorting order
     *              available keys:
     *                  a, ab, abc          by 1st letter, 2 letters, or 3 letters
     *                  name                by page name (no namespace) [not grouped]
     *                  page|id             by full page id, including namespace [not grouped]
     *                  ns                  by namespace (without page name)
     *                  mdate, cdate        by modified|created dates (full) [not grouped]
     *                  m[year][month][day] by modified [year][month][day]; any combination accepted
     *                  c[year][month][day] by created [year][month][day]; any combination accepted
     *                  creator             by page author
     *              date sort default to descending, string sorts to ascending
     * 4. group:    show group headers for each change in sort keys
     *              Note: keys with no duplicated cannot be grouped (i.e. name, page|id, mdate, cdate)
     * 5. limit:    maximum number of results to return
     * 6. inwords:  use real month and day names instead of just numbers
     * 7. cols:     number of columns in displayed list (max = 4)
     * 8. proper:   display page names and namespace in Proper Case (i.e. no _'s and Capitalised)
                    header/hdr = group headers only, name = page name only, both = both!
     * 9. border:   turn on borders
     *10. fullregex:only useful on page name searches; allows a raw regex mode on the full page idate
     *11. nostart:  ignore any 'start' pages in namespace
     *
     * All options are optional, and the list will default to a boring long 1-column list...
     */
	function handle($match, $state, $pos, &$handler) {
        global $conf;
        $this->dformat = $conf['dformat'];
        
		$match = substr($match, 12, -2); // strip markup incl. tagit>
		$args = explode(';', $match);
        $query = $args[0];
        $fulltext = false;
        $sort = array();
        $group = false;
        $limit = 0; //Default max tagits displayed. '0' => no limit
        $proper = 'none';
        $cols = 1;
        $border = false;
        $title = false; // use title instead of name
        $abstract = 'tooltip';
        
        foreach ($args as $arg) {
            list($key, $value) = explode('=', $arg);
            switch ($key) {
                case 'fulltext':
                    $fulltext = true;
                    break;
                case 'sort':
                    $values = explode(',', $value);
                    foreach ($values as $value) {
                        list($key, $dir) = explode(':', $value);
                        $sort[] = array($key, $dir);
                    }
                    break;
                case 'group':
                    $group = true;
                    break;
                case 'limit':
                    $limit = $value;
                    break;
                case 'inwords':
                    $inwords = true;
                    break;
                case 'proper':
                    switch ($value) {
                        case 'hdr':
                        case 'header':
                        case 'group':
                            $proper = 'header';
                            break;
                        case 'name':
                        case 'page':
                            $proper = 'name';
                            break;
                        default:
                            $proper = 'both';
                    }
                    break;
                case 'cols':
                    $cols = ($value > 4) ? 4 : $value;
                    break;
                case 'border':
                    $border = true;
                    break;
				case 'fullregex':
					$fullregex = true;
					break;
                case 'nostart':
                    $nostart = true;
                    break;
                case 'title':
                    $title = true;
                    break;
                case 'abstract':
                    switch ($value) {
                        case '':
                        case 'tooltip':
                            $abstract = 'tooltip';
                            break;
                        default:
                            if ($value >= 0) {
                                $abstract = $value;
                            }
                }
            }
        }
		return array($query, $fulltext, $sort, $group, $limit, $proper, 
                      $cols, $inwords, $border, $fullregex, $nostart, $title, $abstract);
	}

    function render($mode, &$renderer, $data) {
        $sortkeys = array();
        list($query, $fulltext, $sort, $group, $limit, $proper, 
              $cols, $inwords, $border, $fullregex, $nostart, $title, $abstract) = $data;
        $this->inwords = $inwords;
        $this->nostart = $nostart;
        
        if ($mode == 'xhtml') {
            // first get a raw list of matching results
            if ($fulltext) {
                $results = array_keys(ft_pageSearch($query, $highlight));
            } else {
                // allow for raw regex mode, for power users, this searches the full page id
                if ($fullregex) {
                    $full_query = $query;
                    $pageonly = false;
                } else {
                    list($full_query, $pageonly) = $this->_parse_ns_query($query);
                }
                $results = $this->_pageLookup($full_query, $pageonly);
            }
            // basic result page markup (always needed)
            $border_css = ($border === false) ? ' style="border-style:none;"' : '';
            $renderer->doc .= '<div id="pagequery">' . DOKU_LF;
            $renderer->doc .= '<table><tbody><tr>' . DOKU_LF;
            
            // display a "no results" message if empty
            if (empty($results)) {
                $renderer->doc .= '<td><p>' . $this->getLang("no_results") . 
                                  '"<strong>' . $query . '</strong>"</p></td>';
            } else {
                // prepare the necessary sorting arrays, as per options
                $sort_opts = $this->_get_sort_opts($results, $sort, $title);
                // now do the sorting
                $this->_sort_results($results, $sort_opts);
                // limit the result list length if required
                // remember: this can only be done after sorting!
                $results = ($limit > 0) ? array_slice($results, 0, $limit) : $results;
                // and finally the grouping
                if ($group) {
                    $results = $this->_group_results($results, $sort_opts);
                }
                $was_heading = false;
                $idx = 0;
                $col = 0;
                $rows = ceil(count($results) / $cols);  // proposed column row size
                $width = floor(100 / $cols);
                // remove indenting if not grouped
                $indent_css = ($group === false) ? ' class="nogroup"' : '';
                $abstract_count = 0;

                foreach ($results as $id) {
                    // are we ready to start a new column? (up to max allowed)
                    if ($col < $cols && $idx % $rows == 0) {
                        $ready_for_col = true;
                        $col++;
                    }
                    $is_heading = ($id[0] == '<');

                    // Only start if we are at a heading or if there is no grouping
                    if ($ready_for_col && ($idx == 0 || $is_heading || !$group)) {
                        // close the previous column if necessary
                        $close = ($idx > 0) ? '</ul></td>' . DOKU_LF : '';
                        $renderer->doc .= $close . '<td' . $border_css . ' valign="top" width="' . $width . '%">' . DOKU_LF;
                        $ready_for_col = false;
                        $was_heading = true;    //needed to begin a new page id list
                    }
                    if ($is_heading) {
                        // deal with headers (already marked up)
                        if (!$was_heading) $renderer->doc .= '</ul>' . DOKU_LF;
                        if ($proper == 'header' || $proper == 'both') $id = $this->_proper($id);
                        $renderer->doc .= $id . DOKU_LF;
                        $was_heading = true;
                    } else {
                        // normal page links
                        if ($was_heading || $idx == 0) $renderer->doc .= '<ul' . $indent_css . '>';
                        $id = (strpos($id, ':') === false) ? ':' . $id : $id;   // : needed for root pages

                        // does the user want to see the "title" instead "pagename"
                        if ($title) {
                            $value = p_get_metadata($id, 'title', true);
                            $name = (empty($value)) ? $this->_proper(noNS($id)) : $value;
                        } elseif ($proper == 'name' || $proper == 'both') {
                            $name = $this->_proper(noNS($id));
                        } else {
                            $name = '';
                        }

                        // show the "abstract" as a tooltip
                        // -or- as a nice quoted snippet ( la blockquote plugin)
                        if ($abstract == 'tooltip' || ($abstract > 0 && $abstract_count >= $abstract)) {
                            $link = $this->_wikilink_preview_popup($id, $name);
                        } else {
                            $link = html_wikilink($id, $name);
                            if ($abstract == 0 || ($abstract > 0 && $abstract_count < $abstract)) {
                                $abstract_count++;
                                $detail = $this->_abstract($id);
                                $detail = str_replace("\n\n", '<br/>', $detail);
                                $detail = '<blockquote>' . $detail . '</blockquote>';
                            } else {
                                $detail = '';
                            }
                        }
                        $renderer->doc .= '<li>' . $link . '</li>' . DOKU_LF;
                        $renderer->doc .= $detail . DOKU_LF;
                        $was_heading = false;
                    }
                    $idx++;
                }
                $renderer->doc .= '</ul></td>';
            }
            $renderer->doc .= '</tr>' . DOKU_LF;
            $renderer->doc .= '</tbody></table>';
            $renderer->doc .= '</div>' . DOKU_LF;
        } else {
            return false;
        }
    }

    private function _proper($id) {
         $id = str_replace(':', ': ', $id);
         $id = str_replace('_', ' ', $id);
         $id = ucwords($id);
         $id = str_replace(': ', ':', $id);
         return $id;
    }
    /**
     * swap normal link title (popup) for a more useful preview
     *
     * @param string $id    page id
     * @param string $name  display name
     * @return complete href link 
     */
    private function _wikilink_preview_popup($id, $name) {
        $link = html_wikilink($id, $name);
        $preview = $this->_abstract($id);
        $preview = str_replace("\n", '  ', $preview);
        $link = preg_replace('/title=\".+?\"/', 'title="' . $preview . '"', $link, 1);
        return $link;
    }

    private function _abstract($id) {
        $meta = p_get_metadata($id, 'description', true);
        return htmlspecialchars($meta['abstract'] . '... ', ENT_IGNORE, 'UTF-8');
    }

    /**
     * Parse out the namespace, and convert to a regex for array search
     * -or- ensures that normal search are only within pagename not its namespace
     *
     * @param string $query user page query
     * @return processed query with regex markup as needed for namespace recognition
     */
    private function _parse_ns_query($query) {
        $incl_ns = preg_match('`(@|ns:)(\w+(\:\w+)*)(\s.+)*`', $query, $matches);
        if ($incl_ns > 0) {
            $ns = $matches[2];
            $page = trim($matches[4]);
            if ($page == '*') $page = '.*';
            $ns_query = $ns . ":.*" . $page;
            return array($ns_query, false);
        }
        $excl_ns = preg_match('`(\^|-ns:)(\w+(\:\w+)*)(\s.+)*`', $query, $matches);
        if ($excl_ns > 0) {
            $ns = $matches[2];
            $page = trim($matches[4]);
            if ($page == '*') $page = '.*';
            $ns_query = '^(?!' . $ns . '):.*' . $page;
            return array($ns_query, false);
        }
		if ($query == '*') $query= '.*';
        return array($query, true);	// true => turns on pageonly lookup
    }

    /**
     * Builds a separate sorting array for each sortby key
     *
     * @param string    $id         wiki page id
     * @param array     $sortby     keys to use for sorting
     * @param arrayref  $sortkeys   ref to sorting arrays
     * @return void
     */
    private function _get_sort_opts($ids, $sortkeys, $title) {
        $sort_opts = array();
        foreach ($ids as $id) {
            $meta = p_get_metadata ($id, false, true);
            if (!isset($meta['date']['modified'])) {
                $meta['date']['modified'] = $meta['date']['created'];
            }
            if ($title && !isset($meta['title'])) {
                $meta['title'] = $this->_proper(noNS($id));
            }
            $idx = 0;
            foreach ($sortkeys as $sortkey) {
                $key = $sortkey[0];
                switch ($key) {
                    case 'a':
                        $value = $this->_first(noNS($id), 1);
                        break;
                    case 'ab':
                        $value = $this->_first(noNS($id), 2);
                        break;
                    case 'abc':
                        $value = $this->_first(noNS($id), 3);
                        break;
                    case 'name':
                        $value = ($title) ? $meta['title'] : noNS($id);
                        break;
                    case 'id':
                    case 'page':
                        $value = $id;
                        break;
                    case 'ns':
                        $value = getNS($id);
                        if (empty($value)) $value = '(start)';
                        break;
                    case 'creator':
                        $value = $meta['creator'];
                        break;
                    case 'mdate':
                        $value = $meta['date']['modified'];
                        break;
                    case 'cdate':
                        $value = $meta['date']['created'];
                        break;
                    default:
                        $dtype = $key[0];
                        // the date formats are cached on first use; assumes one modifed & created per set
                        if ($dtype == 'c' || $dtype == 'm') {
                            if (!isset($dformat[$key])) {
                                $dformat[$key] = $this->_date_format($key);
                                $sort_opts[$idx]['format'] = $dformat[$key];
                            }
                            if ($dtype == 'c') {
                                $value = strftime($dformat[$key], $meta['date']['created']);
                            } elseif ($dtype == 'm') {
                                $value = strftime($dformat[$key], $meta['date']['modified']);
                            }
                        }
                }
                $sort_opts[$idx]['keys'][] = $value;
                $idx += 1;
            }
        }
        $idx = 0;
        foreach ($sortkeys as $sortkey) {
            list($key, $dir) = $sortkey;
            // now the sort direction
            switch ($dir) {
                case 'a':
                case 'asc':
                    $dir = SORT_ASC;
                    break;
                case 'd':
                case 'desc':
                    $dir = SORT_DESC;
                    break;
                default:
                    // sort descending by default; text ascending
                    // watch for other options beginning with c or m ....!
                    if ($key[0] == 'c' || $key[0] == 'm') {
                        $dir = SORT_DESC;
                    } else {
                        $dir = SORT_ASC;
                    }
            }
            $sort_opts[$idx]['dir'] = $dir;
            // and finally set the sort array's data type (for correct markup purposes)
            switch ($key) {
                // full-text and full dates cannot meaningfully be grouped (no duplicates!)
                case 'mdate':
                case 'cdate':
                case 'name':
                case 'id':
                case 'page':
                    $group = false;
                    break;
                default:
                    $group = true;
            }
            $sort_opts[$idx]['group'] = $group;
            // and now the sort data type
            switch ($key) {
                case 'mdate':
                case 'cdate':
                    $type = SORT_NUMERIC;
                    break;
                default:
                    $type = SORT_STRING;
            }
            $sort_opts[$idx]['type'] = $type;
            $idx += 1;
        }
        return $sort_opts;
    }

    // returns first $count letters from $text
    private function _first($text, $count) {
        if ($count > 0) {
            return substr($text, 0, $count);
        }
    }

    // parse the c|m-year-month-day option
    private function _date_format($key) {
        $year = (strpos($key, 'year') !== false) ? '%Y' : '';
        $month = (strpos($key, 'month') !== false) ? '%m' : '';
        $day = (strpos($key, 'day') !== false) ? '%d' : '';
        $format = $year . (($year != '' && ($month != '' || $day != '')) ? '-' : '');
        $format .= $month . ($month != '' && $day != '' ? '-' : '');
        $format .= $day;
        return $format;
    }

    // sort by each sorting array, in order
    private function _sort_results(&$ids, &$sort_opts) {
        if (!empty($sort_opts)) {
            $args = array();
            foreach ($sort_opts as &$sort_opt) {
                $args[] = &$sort_opt['keys'];
                $args[] = &$sort_opt['dir'];
                $args[] = &$sort_opt['type'];
            }
            $args[] = &$ids;
            call_user_func_array('array_multisort', $args);
        }
    }
    
    private function _group_results(&$ids, &$sort_opts) {
        $prevs = array();
        $results = array();
        $level = count($sort_opts) - 1;
        $idx = 0;
        foreach($ids as $id) {
            $this->_add_heading($results, $sort_opts, $level, $idx, $prevs);
            $results[] = $id;
            $idx++;
        }
        return $results;
    }
    
    private function _add_heading(&$results, &$sort_opts, $level, $idx, &$prevs) {
        if ($level > 0) {
            // recurse to find all parent headings
            $this->_add_heading($results, $sort_opts, $level - 1, $idx, $prevs);
        }
        $group = $sort_opts[$level]['group'];
        // only if this sort array can be grouped....
        if ($group) {
            $prev = (isset($prevs[$level])) ? $prevs[$level] : '';
            $cur = $sort_opts[$level]['keys'][$idx];
            if ($cur != $prev) {
                $prevs[$level] = $cur;
                $h = 'h' . ($level + 1);
                // display months and days in real words
                if ($this->inwords) {
                    $format = $sort_opts[$level]['format'];
                    switch ($format) {
                        case '%m':
                            $cur = strftime("%B", mktime(0, 0, 0, $cur, 10));
                            break;
                        case '%d':
                            $cur = strftime("%#d, %A ", mktime(0, 0, 0, 0, $cur));
                            break;
                        case '%Y-%m':
                            $cur = strftime("%B %Y", mktime(0, 0, 0, substr($cur, 5, 2), 10, substr($cur, 0, 4)));
                            break;
                        case '%m-%d':
                            $cur = strftime("%B %#d, %A ", mktime(0, 0, 0, substr($cur, 0, 2), substr($cur, 3, 2)));
                            break;
                        case '%Y-%m-%d':
                            $cur = strftime("%A, %B %#d, %Y", mktime(0, 0, 0, substr($cur, 5, 2), substr($cur, 8, 2), substr($cur, 0, 4)));
                            break;
                    }
                }
                // space in front ensures that ucwords works
                $results[] = "<$h> $cur</$h>";
            }
        }
    }

    /**
     * heavily customised version of _ft_pageLookup in inc/fulltext.php
     * I just removed the preg_quote line to enable regexes in search query...
     * and the unnecessary usort line as I have my own sort routines
     *
     */
    private function _pageLookup($query, $pageonly) {
        global $conf;
        
        $query = trim($query);
        $pages = file($conf['indexdir'].'/page.idx');
        $pages = array_values(preg_grep('/'.$query.'/', $pages));

        $cnt = count($pages);
        for($i = 0; $i < $cnt; $i++){
            if($pageonly){
                if(!preg_match('/'.$query.'/',noNS($pages[$i]))){
                    unset($pages[$i]);
                    continue;
                }
            }
            if(!page_exists($pages[$i])){
                unset($pages[$i]);
                continue;
            }
        }

        $pages = array_filter($pages, 'isVisiblePage'); // discard hidden pages
        if(!count($pages)) return array();

        $pages = array_map('trim',$pages);
        
        // check ACL permissions and remove any 'start' pages if req'd
        $start = $conf['start'];
        $pos = strlen($start);
        foreach($pages as $idx => $name) {
            if ($this->nostart && substr($name, -$pos) == $start) {
                unset($pages[$idx]);
            } elseif(auth_quickaclcheck(trim($pages[$idx])) < AUTH_READ){
                unset($pages[$idx]);
            }
        }
        return $pages;
    }
}

blob
mark :20
data 2872
PNG

   IHDR         a  
OiCCPPhotoshop ICC profile  xSgTS=BKKoR RB&*!	J!QEEQ,
!{k>H3Q5B.@
$p d!s# ~<<+" x M0B\t8K @zB @F&S  `cb P- `' { [!  eD h; VE X0 fK9 - 0IWfH    0Q) { `##x  FW<+*  x<$9E[-qWW.(I+6aa@.y24  x6_-"bbp@  t~,/;m%h^uf@ Wp~<<EJB[aW}g_Wl~<$2]GL	bG"IbX*QqD2"B)%d,>5 j>{-]cK'Xt  o(hw?G% fIq  ^D$.T?  D*A,`6B$BB
dr`)B(*`/@4Qhp.U=pa(	Aa!bX#!H$ Q"K5H1RT UH=r9\F; 2G1Q=C7Fdt1r=6h>C03l0.B8,	c"VcwE	6wB aAHXLXNH $4	7	Q'"K&b21XH,#/{C7$C2'ITFnR#,4H#dk9, +3![
b@qS(RjJ4e2AURT5ZBRQ4u9IKhhitNWGwg(gwLT071oUX**|
J&*/TUUT^S}FU3S	UPSSg;goT?~YYLOCQ_ cx,!ku5&|v*=9C3J3WRf?qtN	(~))4L1e\kXHQG6EYAJ'\'GgSS
M=:.kDwn^Loy}/TmGX$<5qo</QC]@Caa<FFi\$mm&&!&KMMRM);L;L5=12`ZxZ,eIZYnZ9YXUZ]F%NNgm}agbg}}=Z~sr:V:?}/gX3)iSGggsK.>.Jtq]z6i4)Y3sCQ?0k~OCOg#/c/Wwa>>r><72Y_7Oo_C#dz %gA[z|!?:eAAA!h!iP~aa~'W?pX15wCsDDDg1O9-J5*>.j<74?.fYXXIlK9.*6nl{/]py.,:@LN8A*%w%
yg"/6C\*NH*Mz5y$3,'LL:v m2=:1qB!Mggfven/kY-
BTZ(*geWf9+7KW-Xj9<qy
+V<*mOW~&zMk^kU
}]OX/Ya>(xodff-[nVE/(C<e;?TTTT6an{4[>UUMfeI?m]Nmq#=TR+Gw-6U#pDy	:v{vg/jBFS[b[O>zG4<YyJTig}~.`{cjotE;;\tWW:_mt<O\kz{f7y9=zo~r'w'O_@AC?[jwGC8>99?rCd&/~m|x31^VwwO| (hSc3-   bKGD      	pHYs        tIME~b   jIDAT81 E9 WGdnAV^^)^&ks>YPUc, '<i|lW7MUm>W CN7    IENDB`
blob
mark :21
data 313
GIF89a.                                              !   ,    .   `$$ ht	t79uH_qXr,QC=[d\?u
b!Y{8&]<lc|KoTKk-O*#($){#s%
"m"#y	OA#_Gh6-\p=@x=r=r%']! ;
blob
mark :23
data 2108
Insert the pagequery markup wherever you want your list to appear.
--------
E.g.{{pagequery>[query];fulltext;sort=key:direction,key2:direction;group;limit=??;cols=?;inwords;proper}}
--------
Parameters as follows:
1. query: any expression directly after the >; can use all Dokuwiki search options (see manual)
Limit to namespace: @namespace.  Page name searches accept regex
2. fulltext: use a full-text search, instead of page_id only [default]
3. sort: keys to sort by, in order of sorting. Each key can be followed by prefered sorting order
E.g. sort=name:asc -or- sort=a,name [default direction = asc]
Available keys:
* a, ab, abc          by 1st letter, 2 letters, or 3 letters
* name                by page name (no namespace) [not grouped]
* page|id             by full page id, including namespace [not grouped]
* ns                  by namespace (without page name)
* mdate, cdate        by modified|created dates (full) [not grouped]
* m[year][month][day] by modified [year][month][day]; any combination accepted
* c[year][month][day] by created [year][month][day]; any combination accepted
* creator             by page author
Sort Directions:
* asc => ascending (A-Z); desc => descending (Z-A)
Note: date sort default to descending, string sorts to ascending
4. group: show group headers for each change in sort keys. Note: keys with no duplicated cannot be grouped (i.e. name, page|id, mdate, cdate)
5. limit: maximum number of results to return
6. inwords: use real month and day names instead of just numbers
7. cols: number of columns in displayed list (max = 4) e.g cols=3
8. proper: display page names and namespace in Proper Case; =header =name =both
9. nostart: ignore any start pages in the given namespace
10. fullregex: search full page id using regular expressions (power-user option)
11. title: use page 'title' rather than 'name' in links
12. abstract: show preview of page coontent; =tootip (as popup); =<limit> (as snippet below link, up to <limit> links)

----
All options are optional, and the list will default to a boring long 1-column list...
blob
mark :24
data 1377
div.dokuwiki div#pagequery h1,
div.dokuwiki div#pagequery h2,
div.dokuwiki div#pagequery h3,
div.dokuwiki div#pagequery h4,
div.dokuwiki div#pagequery h5 {
    /*padding:0.1em 0 0;*/
    margin:0;
    margin-bottom:0.4em;
    color:gray;
}
div.dokuwiki div#pagequery h1 {}
div.dokuwiki div#pagequery h2 {margin-left:0.5em}
div.dokuwiki div#pagequery h3 {margin-left:1em}
div.dokuwiki div#pagequery h4 {margin-left:1.5em}
div.dokuwiki div#pagequery h5 {margin-left:2em}

div.dokuwiki div#pagequery table {
    border-collapse:collapse;
    width:99%;
}
div.dokuwiki div#pagequery td {
	border-width:1px;
	padding:5px 10px;
	border-style:solid;
	border-color:#D7D5D4;
	background-color:white;
}
div.dokuwiki div#pagequery ul {
    list-style:none;
    margin:0 0 0.7em 2.5em;
	text-align:left;
}
div.dokuwiki div#pagequery ul.nogroup {
    margin:0 0 0.7em 0.2em;
}
div.dokuwiki div#pagequery li {
	padding-left:0.6em;
	list-style-position:inside;
	text-indent:-0.6em
}
/* credit: blockquote:plugin */
div.dokuwiki div#pagequery blockquote {
    font-size:80%;
	margin: 1em 3em 1em 3em !important;
	border: 1px dotted __border__ !important;
	background: #FAFACE url(images/blockquote.gif) no-repeat 0.3em 0.3em !important;
	padding: 1.2em !important;
    -moz-border-radius: 6px;
    -webkit-border-radius: 6px;
}
div.dokuwiki div#pagequery blockquote a {
    margin-left:12px;
}
blob
mark :25
data 24526
<?php
/**
 * PageQuery Plugin: search for and list pages
 *
 * @license    GPL 2 (http://www.gnu.org/licenses/gpl.html)
 * @author	   Symon Bent <symonbent@gmail.com>
 */
// must be run within Dokuwiki
if(!defined('DOKU_INC')) die();

if (!defined('DOKU_LF')) define('DOKU_LF', "\n");
if (!defined('DOKU_TAB')) define('DOKU_TAB', "\t");
if (!defined('DOKU_PLUGIN')) define('DOKU_PLUGIN',DOKU_INC.'lib/plugins/');

require_once(DOKU_PLUGIN.'syntax.php');
require_once(DOKU_INC.'inc/fulltext.php');

class syntax_plugin_pagequery extends DokuWiki_Syntax_Plugin {
    private $dformat = '';
    private $inwords = false;
    private $nostart = false;

	function getInfo() {
		$desc = file_get_contents(DOKU_PLUGIN . 'pagequery/readme.txt');
		return array(
			'author' => 'Symon Bent', 
			'email'  => 'hendrybadao@gmail.com',
			'date'   => '2010-05-05',
			'name'   => 'Pagequery Plugin',
			'desc'   => empty($desc) ? 'readme.txt is missing!' : $desc,
			'url'    => 'http://wiki.splitbrain.org/plugin:pagequery',
		);
	}

	function getType() {
		return 'substition';
	}
	
	function getPType() {
		return 'block';
	}
	
	function getSort() {
		return 98;
	}

	function connectTo($mode) {
		//Default is a word cloud style, looks good when combined with plugin:box
		$this->Lexer->addSpecialPattern('\{\{pagequery>.*?\}\}', $mode, 'plugin_pagequery');
	}
    /**
     * Parses all the pagequery options:
     * Insert the pagequery markup wherever you want your list to appear. E.g:
     *
     *   {{pagequery>}}
     *
     *   {{pagequery>[query];fulltext;sort=key:direction,key2:direction;group;limit=??;cols=?;inwords;proper}}
     * 
     * Parameters as follows:
     * 1. query:    any expression directly after the >; can use all Dokuwiki search options (see manual)
     * 2. fulltext: use a full-text search, instead of page_id only [default]
     * 3. sort:     keys to sort by, in order of sorting. Each key can be followed by prefered sorting order
     *              available keys:
     *                  a, ab, abc          by 1st letter, 2 letters, or 3 letters
     *                  name                by page name (no namespace) [not grouped]
     *                  page|id             by full page id, including namespace [not grouped]
     *                  ns                  by namespace (without page name)
     *                  mdate, cdate        by modified|created dates (full) [not grouped]
     *                  m[year][month][day] by modified [year][month][day]; any combination accepted
     *                  c[year][month][day] by created [year][month][day]; any combination accepted
     *                  creator             by page author
     *              date sort default to descending, string sorts to ascending
     * 4. group:    show group headers for each change in sort keys
     *              Note: keys with no duplicated cannot be grouped (i.e. name, page|id, mdate, cdate)
     * 5. limit:    maximum number of results to return
     * 6. inwords:  use real month and day names instead of just numbers
     * 7. cols:     number of columns in displayed list (max = 4)
     * 8. proper:   display page names and namespace in Proper Case (i.e. no _'s and Capitalised)
                    header/hdr = group headers only, name = page name only, both = both!
     * 9. border:   turn on borders
     *10. fullregex:only useful on page name searches; allows a raw regex mode on the full page idate
     *11. nostart:  ignore any 'start' pages in namespace
     *
     * All options are optional, and the list will default to a boring long 1-column list...
     */
	function handle($match, $state, $pos, &$handler) {
        global $conf;
        $this->dformat = $conf['dformat'];
        
		$match = substr($match, 12, -2); // strip markup incl. tagit>
		$args = explode(';', $match);
        $query = $args[0];
        $fulltext = false;
        $sort = array();
        $group = false;
        $limit = 0; //Default max tagits displayed. '0' => no limit
        $proper = 'none';
        $cols = 1;
        $border = false;
        $title = false; // use title instead of name
        $abstract = 'tooltip';
        
        foreach ($args as $arg) {
            list($key, $value) = explode('=', $arg);
            switch ($key) {
                case 'fulltext':
                    $fulltext = true;
                    break;
                case 'sort':
                    $values = explode(',', $value);
                    foreach ($values as $value) {
                        list($key, $dir) = explode(':', $value);
                        $sort[] = array($key, $dir);
                    }
                    break;
                case 'group':
                    $group = true;
                    break;
                case 'limit':
                    $limit = $value;
                    break;
                case 'inwords':
                    $inwords = true;
                    break;
                case 'proper':
                    switch ($value) {
                        case 'hdr':
                        case 'header':
                        case 'group':
                            $proper = 'header';
                            break;
                        case 'name':
                        case 'page':
                            $proper = 'name';
                            break;
                        default:
                            $proper = 'both';
                    }
                    break;
                case 'cols':
                    $cols = ($value > 4) ? 4 : $value;
                    break;
                case 'border':
                    $border = true;
                    break;
				case 'fullregex':
					$fullregex = true;
					break;
                case 'nostart':
                    $nostart = true;
                    break;
                case 'title':
                    $title = true;
                    break;
                case 'abstract':
                    switch ($value) {
                        case '':
                        case 'tooltip':
                            $abstract = 'tooltip';
                            break;
                        default:
                            if ($value >= 0) {
                                $abstract = $value;
                            }
                }
            }
        }
		return array($query, $fulltext, $sort, $group, $limit, $proper, 
                      $cols, $inwords, $border, $fullregex, $nostart, $title, $abstract);
	}

    function render($mode, &$renderer, $data) {
        $sortkeys = array();
        list($query, $fulltext, $sort, $group, $limit, $proper, 
              $cols, $inwords, $border, $fullregex, $nostart, $title, $abstract) = $data;
        $this->inwords = $inwords;
        $this->nostart = $nostart;
        
        if ($mode == 'xhtml') {
            // first get a raw list of matching results
            if ($fulltext) {
                $results = array_keys(ft_pageSearch($query, $highlight));
            } else {
                // allow for raw regex mode, for power users, this searches the full page id
                if ($fullregex) {
                    $full_query = $query;
                    $pageonly = false;
                } else {
                    list($full_query, $pageonly) = $this->_parse_ns_query($query);
                }
                $results = $this->_pageLookup($full_query, $pageonly);
            }
            // basic result page markup (always needed)
            $border_css = ($border === false) ? ' style="border-style:none;"' : '';
            $renderer->doc .= '<div id="pagequery">' . DOKU_LF;
            $renderer->doc .= '<table><tbody><tr>' . DOKU_LF;
            
            // display a "no results" message if empty
            if (empty($results)) {
                $renderer->doc .= '<td><p>' . $this->getLang("no_results") . 
                                  '"<strong>' . $query . '</strong>"</p></td>';
            } else {
                // prepare the necessary sorting arrays, as per options
                $sort_opts = $this->_get_sort_opts($results, $sort, $title);
                // now do the sorting
                $this->_sort_results($results, $sort_opts);
                // limit the result list length if required
                // remember: this can only be done after sorting!
                $results = ($limit > 0) ? array_slice($results, 0, $limit) : $results;
                // and finally the grouping
                if ($group) {
                    $results = $this->_group_results($results, $sort_opts);
                }
                $was_heading = false;
                $idx = 0;
                $col = 0;
                $rows = ceil(count($results) / $cols);  // proposed column row size
                $width = floor(100 / $cols);
                // remove indenting if not grouped
                $indent_css = ($group === false) ? ' class="nogroup"' : '';
                $link_count = 0;    // needed by the abstract snippet section

                foreach ($results as $id) {
                    // are we ready to start a new column? (up to max allowed)
                    if ($col < $cols && $idx % $rows == 0) {
                        $ready_for_col = true;
                        $col++;
                    }
                    $is_heading = ($id[0] == '<');

                    // Begin new column if: we are at the start, at a heading or if there is no grouping
                    if ($ready_for_col && ($idx == 0 || $is_heading || !$group)) {
                        // close the previous column if necessary
                        $close = ($idx > 0) ? '</ul></td>' . DOKU_LF : '';
                        $renderer->doc .= $close . '<td' . $border_css . ' valign="top" width="' . $width . '%">' . DOKU_LF;
                        $ready_for_col = false;
                        $was_heading = true;    //needed to begin a new page id list
                    }
                    if ($is_heading) {
                        // close previous sub list if necessary
                        if (!$was_heading) $renderer->doc .= '</ul>' . DOKU_LF;

                        // deal with headers (already marked up)
                        if ($proper == 'header' || $proper == 'both') $id = $this->_proper($id);
                        $renderer->doc .= $id . DOKU_LF;
                        $was_heading = true;
                    } else {
                        // open a new sub list if necessary
                        if ($was_heading || $idx == 0) $renderer->doc .= '<ul' . $indent_css . '>';

                        // deal with normal page links
                        $link = $this->_render_wikilink($id, $proper, $title, $abstract, $link_count);
                        $link_count++;
                        $renderer->doc .= $link;
                        $was_heading = false;
                    }
                    $idx++;
                }
                $renderer->doc .= '</ul></td>';
            }
            $renderer->doc .= '</tr>' . DOKU_LF;
            $renderer->doc .= '</tbody></table>';
            $renderer->doc .= '</div>' . DOKU_LF;
        } else {
            return false;
        }
    }
    /**
     * Renders the page link, plus tooltip, abstract, casing, etc...
     * @param string $id
     * @param bool  $proper
     * @param bool  $title
     * @param mixed $abstract
     */
    private function _render_wikilink($id, $proper, $title, $abstract, $link_count) {

        $id = (strpos($id, ':') === false) ? ':' . $id : $id;   // : needed for root pages

        // does the user want to see the "title" instead "pagename"
        if ($title) {
            $value = p_get_metadata($id, 'title', true);
            $name = (empty($value)) ? $this->_proper(noNS($id)) : $value;
        } elseif ($proper == 'name' || $proper == 'both') {
            $name = $this->_proper(noNS($id));
        } else {
            $name = '';
        }

        // show the "abstract" as a tooltip
        // -or- as a nice quoted snippet ( la blockquote plugin)
        if ($abstract == 'tooltip' || ($abstract > 0 && $link_count >= $abstract)) {
            $link = $this->_html_wikilink_tooltip($id, $name);
        } else {
            $link = html_wikilink($id, $name);
            if ($abstract == 0 || ($abstract > 0 && $link_count < $abstract)) {
                $detail = $this->_abstract($id);
                $detail = str_replace("\n\n", '<br/>', $detail);
                $more = html_wikilink($id, 'more...');
                $detail = '<blockquote>' . $detail . $more . '</blockquote>' . DOKU_LF;
            } else {
                $detail = '';
            }
        }
        return '<li>' . $link . '</li>' . DOKU_LF . $detail;
    }

    private function _proper($id) {
         $id = str_replace(':', ': ', $id);
         $id = str_replace('_', ' ', $id);
         $id = ucwords($id);
         $id = str_replace(': ', ':', $id);
         return $id;
    }
    /**
     * swap normal link title (popup) for a more useful preview
     *
     * @param string $id    page id
     * @param string $name  display name
     * @return complete href link 
     */
    private function _html_wikilink_tooltip($id, $name) {
        $link = html_wikilink($id, $name);
        $tooltip = $this->_abstract($id);
        $tooltip = str_replace("\n", '  ', $tooltip);
        $link = preg_replace('/title=\".+?\"/', 'title="' . $tooltip . '"', $link, 1);
        return $link;
    }

    private function _abstract($id) {
        $meta = p_get_metadata($id, 'description', true);
        return htmlspecialchars($meta['abstract'], ENT_IGNORE, 'UTF-8');
    }

    /**
     * Parse out the namespace, and convert to a regex for array search
     * -or- ensures that normal search are only within pagename not its namespace
     *
     * @param string $query user page query
     * @return processed query with regex markup as needed for namespace recognition
     */
    private function _parse_ns_query($query) {
        $incl_ns = preg_match('`(@|ns:)(\w+(\:\w+)*)(\s.+)*`', $query, $matches);
        if ($incl_ns > 0) {
            $ns = $matches[2];
            $page = trim($matches[4]);
            if ($page == '*') $page = '.*';
            $ns_query = $ns . ":.*" . $page;
            return array($ns_query, false);
        }
        $excl_ns = preg_match('`(\^|-ns:)(\w+(\:\w+)*)(\s.+)*`', $query, $matches);
        if ($excl_ns > 0) {
            $ns = $matches[2];
            $page = trim($matches[4]);
            if ($page == '*') $page = '.*';
            $ns_query = '^(?!' . $ns . '):.*' . $page;
            return array($ns_query, false);
        }
		if ($query == '*') $query= '.*';
        return array($query, true);	// true => turns on pageonly lookup
    }

    /**
     * Builds a separate sorting array for each sortby key
     *
     * @param string    $id         wiki page id
     * @param array     $sortby     keys to use for sorting
     * @param arrayref  $sortkeys   ref to sorting arrays
     * @return void
     */
    private function _get_sort_opts($ids, $sortkeys, $title) {
        $sort_opts = array();
        foreach ($ids as $id) {
            $meta = p_get_metadata ($id, false, true);
            if (!isset($meta['date']['modified'])) {
                $meta['date']['modified'] = $meta['date']['created'];
            }
            if ($title && !isset($meta['title'])) {
                $meta['title'] = $this->_proper(noNS($id));
            }
            $idx = 0;
            foreach ($sortkeys as $sortkey) {
                $key = $sortkey[0];
                switch ($key) {
                    case 'a':
                        $value = $this->_first(noNS($id), 1);
                        break;
                    case 'ab':
                        $value = $this->_first(noNS($id), 2);
                        break;
                    case 'abc':
                        $value = $this->_first(noNS($id), 3);
                        break;
                    case 'name':
                        $value = ($title) ? $meta['title'] : noNS($id);
                        break;
                    case 'id':
                    case 'page':
                        $value = $id;
                        break;
                    case 'ns':
                        $value = getNS($id);
                        if (empty($value)) $value = '(start)';
                        break;
                    case 'creator':
                        $value = $meta['creator'];
                        break;
                    case 'mdate':
                        $value = $meta['date']['modified'];
                        break;
                    case 'cdate':
                        $value = $meta['date']['created'];
                        break;
                    default:
                        $dtype = $key[0];
                        // the date formats are cached on first use; assumes one modifed & created per set
                        if ($dtype == 'c' || $dtype == 'm') {
                            if (!isset($dformat[$key])) {
                                $dformat[$key] = $this->_date_format($key);
                                $sort_opts[$idx]['format'] = $dformat[$key];
                            }
                            if ($dtype == 'c') {
                                $value = strftime($dformat[$key], $meta['date']['created']);
                            } elseif ($dtype == 'm') {
                                $value = strftime($dformat[$key], $meta['date']['modified']);
                            }
                        }
                }
                $sort_opts[$idx]['keys'][] = $value;
                $idx += 1;
            }
        }
        $idx = 0;
        foreach ($sortkeys as $sortkey) {
            list($key, $dir) = $sortkey;
            // now the sort direction
            switch ($dir) {
                case 'a':
                case 'asc':
                    $dir = SORT_ASC;
                    break;
                case 'd':
                case 'desc':
                    $dir = SORT_DESC;
                    break;
                default:
                    // sort descending by default; text ascending
                    // watch for other options beginning with c or m ....!
                    if ($key[0] == 'c' || $key[0] == 'm') {
                        $dir = SORT_DESC;
                    } else {
                        $dir = SORT_ASC;
                    }
            }
            $sort_opts[$idx]['dir'] = $dir;
            // and finally set the sort array's data type (for correct markup purposes)
            switch ($key) {
                // full-text and full dates cannot meaningfully be grouped (no duplicates!)
                case 'mdate':
                case 'cdate':
                case 'name':
                case 'id':
                case 'page':
                    $group = false;
                    break;
                default:
                    $group = true;
            }
            $sort_opts[$idx]['group'] = $group;
            // and now the sort data type
            switch ($key) {
                case 'mdate':
                case 'cdate':
                    $type = SORT_NUMERIC;
                    break;
                default:
                    $type = SORT_STRING;
            }
            $sort_opts[$idx]['type'] = $type;
            $idx += 1;
        }
        return $sort_opts;
    }

    // returns first $count letters from $text
    private function _first($text, $count) {
        if ($count > 0) {
            return substr($text, 0, $count);
        }
    }

    // parse the c|m-year-month-day option
    private function _date_format($key) {
        $year = (strpos($key, 'year') !== false) ? '%Y' : '';
        $month = (strpos($key, 'month') !== false) ? '%m' : '';
        $day = (strpos($key, 'day') !== false) ? '%d' : '';
        $format = $year . (($year != '' && ($month != '' || $day != '')) ? '-' : '');
        $format .= $month . ($month != '' && $day != '' ? '-' : '');
        $format .= $day;
        return $format;
    }

    // sort by each sorting array, in order
    private function _sort_results(&$ids, &$sort_opts) {
        if (!empty($sort_opts)) {
            $args = array();
            foreach ($sort_opts as &$sort_opt) {
                $args[] = &$sort_opt['keys'];
                $args[] = &$sort_opt['dir'];
                $args[] = &$sort_opt['type'];
            }
            $args[] = &$ids;
            call_user_func_array('array_multisort', $args);
        }
    }
    
    private function _group_results(&$ids, &$sort_opts) {
        $prevs = array();
        $results = array();
        $level = count($sort_opts) - 1;
        $idx = 0;
        foreach($ids as $id) {
            $this->_add_heading($results, $sort_opts, $level, $idx, $prevs);
            $results[] = $id;
            $idx++;
        }
        return $results;
    }
    
    private function _add_heading(&$results, &$sort_opts, $level, $idx, &$prevs) {
        if ($level > 0) {
            // recurse to find all parent headings
            $this->_add_heading($results, $sort_opts, $level - 1, $idx, $prevs);
        }
        $group = $sort_opts[$level]['group'];
        // only if this sort array can be grouped....
        if ($group) {
            $prev = (isset($prevs[$level])) ? $prevs[$level] : '';
            $cur = $sort_opts[$level]['keys'][$idx];
            if ($cur != $prev) {
                $prevs[$level] = $cur;
                $h = 'h' . ($level + 1);
                // display months and days in real words
                if ($this->inwords) {
                    $format = $sort_opts[$level]['format'];
                    switch ($format) {
                        case '%m':
                            $cur = strftime("%B", mktime(0, 0, 0, $cur, 10));
                            break;
                        case '%d':
                            $cur = strftime("%#d, %A ", mktime(0, 0, 0, 0, $cur));
                            break;
                        case '%Y-%m':
                            $cur = strftime("%B %Y", mktime(0, 0, 0, substr($cur, 5, 2), 10, substr($cur, 0, 4)));
                            break;
                        case '%m-%d':
                            $cur = strftime("%B %#d, %A ", mktime(0, 0, 0, substr($cur, 0, 2), substr($cur, 3, 2)));
                            break;
                        case '%Y-%m-%d':
                            $cur = strftime("%A, %B %#d, %Y", mktime(0, 0, 0, substr($cur, 5, 2), substr($cur, 8, 2), substr($cur, 0, 4)));
                            break;
                    }
                }
                // space in front ensures that ucwords works
                $results[] = "<$h> $cur</$h>";
            }
        }
    }

    /**
     * heavily customised version of _ft_pageLookup in inc/fulltext.php
     * I just removed the preg_quote line to enable regexes in search query...
     * and the unnecessary usort line as I have my own sort routines
     *
     */
    private function _pageLookup($query, $pageonly) {
        global $conf;
        
        $query = trim($query);
        $pages = file($conf['indexdir'].'/page.idx');
        $pages = array_values(preg_grep('/'.$query.'/', $pages));

        $cnt = count($pages);
        for($i = 0; $i < $cnt; $i++){
            if($pageonly){
                if(!preg_match('/'.$query.'/',noNS($pages[$i]))){
                    unset($pages[$i]);
                    continue;
                }
            }
            if(!page_exists($pages[$i])){
                unset($pages[$i]);
                continue;
            }
        }

        $pages = array_filter($pages, 'isVisiblePage'); // discard hidden pages
        if(!count($pages)) return array();

        $pages = array_map('trim',$pages);
        
        // check ACL permissions and remove any 'start' pages if req'd
        $start = $conf['start'];
        $pos = strlen($start);
        foreach($pages as $idx => $name) {
            if ($this->nostart && substr($name, -$pos) == $start) {
                unset($pages[$idx]);
            } elseif(auth_quickaclcheck(trim($pages[$idx])) < AUTH_READ){
                unset($pages[$idx]);
            }
        }
        return $pages;
    }
}

blob
mark :27
data 24567
<?php
/**
 * PageQuery Plugin: search for and list pages
 *
 * @license    GPL 2 (http://www.gnu.org/licenses/gpl.html)
 * @author	   Symon Bent <symonbent@gmail.com>
 */
// must be run within Dokuwiki
if(!defined('DOKU_INC')) die();

if (!defined('DOKU_LF')) define('DOKU_LF', "\n");
if (!defined('DOKU_TAB')) define('DOKU_TAB', "\t");
if (!defined('DOKU_PLUGIN')) define('DOKU_PLUGIN',DOKU_INC.'lib/plugins/');

require_once(DOKU_PLUGIN.'syntax.php');
require_once(DOKU_INC.'inc/fulltext.php');

class syntax_plugin_pagequery extends DokuWiki_Syntax_Plugin {
    private $dformat = '';
    private $inwords = false;
    private $nostart = false;

	function getInfo() {
		$desc = file_get_contents(DOKU_PLUGIN . 'pagequery/readme.txt');
		return array(
			'author' => 'Symon Bent', 
			'email'  => 'hendrybadao@gmail.com',
			'date'   => '2010-05-05',
			'name'   => 'Pagequery Plugin',
			'desc'   => empty($desc) ? 'readme.txt is missing!' : $desc,
			'url'    => 'http://wiki.splitbrain.org/plugin:pagequery',
		);
	}

	function getType() {
		return 'substition';
	}
	
	function getPType() {
		return 'block';
	}
	
	function getSort() {
		return 98;
	}

	function connectTo($mode) {
		//Default is a word cloud style, looks good when combined with plugin:box
		$this->Lexer->addSpecialPattern('\{\{pagequery>.*?\}\}', $mode, 'plugin_pagequery');
	}
    /**
     * Parses all the pagequery options:
     * Insert the pagequery markup wherever you want your list to appear. E.g:
     *
     *   {{pagequery>}}
     *
     *   {{pagequery>[query];fulltext;sort=key:direction,key2:direction;group;limit=??;cols=?;inwords;proper}}
     * 
     * Parameters as follows:
     * 1. query:    any expression directly after the >; can use all Dokuwiki search options (see manual)
     * 2. fulltext: use a full-text search, instead of page_id only [default]
     * 3. sort:     keys to sort by, in order of sorting. Each key can be followed by prefered sorting order
     *              available keys:
     *                  a, ab, abc          by 1st letter, 2 letters, or 3 letters
     *                  name                by page name (no namespace) [not grouped]
     *                  page|id             by full page id, including namespace [not grouped]
     *                  ns                  by namespace (without page name)
     *                  mdate, cdate        by modified|created dates (full) [not grouped]
     *                  m[year][month][day] by modified [year][month][day]; any combination accepted
     *                  c[year][month][day] by created [year][month][day]; any combination accepted
     *                  creator             by page author
     *              date sort default to descending, string sorts to ascending
     * 4. group:    show group headers for each change in sort keys
     *              Note: keys with no duplicated cannot be grouped (i.e. name, page|id, mdate, cdate)
     * 5. limit:    maximum number of results to return
     * 6. inwords:  use real month and day names instead of just numbers
     * 7. cols:     number of columns in displayed list (max = 4)
     * 8. proper:   display page names and namespace in Proper Case (i.e. no _'s and Capitalised)
                    header/hdr = group headers only, name = page name only, both = both!
     * 9. border:   turn on borders
     *10. fullregex:only useful on page name searches; allows a raw regex mode on the full page idate
     *11. nostart:  ignore any 'start' pages in namespace
     *
     * All options are optional, and the list will default to a boring long 1-column list...
     */
	function handle($match, $state, $pos, &$handler) {
        global $conf;
        $this->dformat = $conf['dformat'];
        
		$match = substr($match, 12, -2); // strip markup incl. tagit>
		$args = explode(';', $match);
        $query = $args[0];
        $fulltext = false;
        $sort = array();
        $group = false;
        $limit = 0; //Default max tagits displayed. '0' => no limit
        $proper = 'none';
        $cols = 1;
        $border = false;
        $title = false; // use title instead of name
        $abstract = 'tooltip';
        
        foreach ($args as $arg) {
            list($key, $value) = explode('=', $arg);
            switch ($key) {
                case 'fulltext':
                    $fulltext = true;
                    break;
                case 'sort':
                    $values = explode(',', $value);
                    foreach ($values as $value) {
                        list($key, $dir) = explode(':', $value);
                        $sort[] = array($key, $dir);
                    }
                    break;
                case 'group':
                    $group = true;
                    break;
                case 'limit':
                    $limit = $value;
                    break;
                case 'inwords':
                    $inwords = true;
                    break;
                case 'proper':
                    switch ($value) {
                        case 'hdr':
                        case 'header':
                        case 'group':
                            $proper = 'header';
                            break;
                        case 'name':
                        case 'page':
                            $proper = 'name';
                            break;
                        default:
                            $proper = 'both';
                    }
                    break;
                case 'cols':
                    $cols = ($value > 4) ? 4 : $value;
                    break;
                case 'border':
                    $border = true;
                    break;
				case 'fullregex':
					$fullregex = true;
					break;
                case 'nostart':
                    $nostart = true;
                    break;
                case 'title':
                    $title = true;
                    break;
                case 'abstract':
                    switch ($value) {
                        case '':
                        case 'tooltip':
                            $abstract = 'tooltip';
                            break;
                        default:
                            if ($value >= 0) {
                                $abstract = $value;
                            }
                }
            }
        }
		return array($query, $fulltext, $sort, $group, $limit, $proper, 
                      $cols, $inwords, $border, $fullregex, $nostart, $title, $abstract);
	}

    function render($mode, &$renderer, $data) {
        $sortkeys = array();
        list($query, $fulltext, $sort, $group, $limit, $proper, 
              $cols, $inwords, $border, $fullregex, $nostart, $title, $abstract) = $data;
        $this->inwords = $inwords;
        $this->nostart = $nostart;
        
        if ($mode == 'xhtml') {
            // first get a raw list of matching results
            if ($fulltext) {
                $results = array_keys(ft_pageSearch($query, $highlight));
            } else {
                // allow for raw regex mode, for power users, this searches the full page id
                if ($fullregex) {
                    $full_query = $query;
                    $pageonly = false;
                } else {
                    list($full_query, $pageonly) = $this->_parse_ns_query($query);
                }
                $results = $this->_pageLookup($full_query, $pageonly);
            }
            // basic result page markup (always needed)
            $border_css = ($border === false) ? ' style="border-style:none;"' : '';
            $renderer->doc .= '<div id="pagequery">' . DOKU_LF;
            $renderer->doc .= '<table><tbody><tr>' . DOKU_LF;
            
            // display a "no results" message if empty
            if (empty($results)) {
                $renderer->doc .= '<td><p>' . $this->getLang("no_results") . 
                                  '"<strong>' . $query . '</strong>"</p></td>';
            } else {
                // prepare the necessary sorting arrays, as per options
                $sort_opts = $this->_get_sort_opts($results, $sort, $title);
                // now do the sorting
                $this->_sort_results($results, $sort_opts);
                // limit the result list length if required
                // remember: this can only be done after sorting!
                $results = ($limit > 0) ? array_slice($results, 0, $limit) : $results;
                // and finally the grouping
                if ($group) {
                    $results = $this->_group_results($results, $sort_opts);
                }
                $was_heading = false;
                $idx = 0;
                $col = 0;
                $rows = ceil(count($results) / $cols);  // proposed column row size
                $width = floor(100 / $cols);
                // remove indenting if not grouped
                $indent_css = ($group === false) ? ' class="nogroup"' : '';
                $link_count = 0;    // needed by the abstract snippet section

                foreach ($results as $id) {
                    // are we ready to start a new column? (up to max allowed)
                    if ($col < $cols && $idx % $rows == 0) {
                        $ready_for_col = true;
                        $col++;
                    }
                    $is_heading = ($id[0] == '<');

                    // Begin new column if: we are at the start, at a heading or if there is no grouping
                    if ($ready_for_col && ($idx == 0 || $is_heading || !$group)) {
                        // close the previous column if necessary
                        $close = ($idx > 0) ? '</ul></td>' . DOKU_LF : '';
                        $renderer->doc .= $close . '<td' . $border_css . ' valign="top" width="' . $width . '%">' . DOKU_LF;
                        $ready_for_col = false;
                        $was_heading = true;    //needed to begin a new page id list
                    }
                    if ($is_heading) {
                        // close previous sub list if necessary
                        if (!$was_heading) $renderer->doc .= '</ul>' . DOKU_LF;

                        // deal with headers (already marked up)
                        if ($proper == 'header' || $proper == 'both') $id = $this->_proper($id);
                        $renderer->doc .= $id . DOKU_LF;
                        $was_heading = true;
                    } else {
                        // open a new sub list if necessary
                        if ($was_heading || $idx == 0) $renderer->doc .= '<ul' . $indent_css . '>';

                        // deal with normal page links
                        $link = $this->_render_wikilink($id, $proper, $title, $abstract, $link_count);
                        $link_count++;
                        $renderer->doc .= $link;
                        $was_heading = false;
                    }
                    $idx++;
                }
                $renderer->doc .= '</ul></td>';
            }
            $renderer->doc .= '</tr>' . DOKU_LF;
            $renderer->doc .= '</tbody></table>';
            $renderer->doc .= '</div>' . DOKU_LF;
        } else {
            return false;
        }
    }
    /**
     * Renders the page link, plus tooltip, abstract, casing, etc...
     * @param string $id
     * @param bool  $proper
     * @param bool  $title
     * @param mixed $abstract
     */
    private function _render_wikilink($id, $proper, $title, $abstract, $link_count) {

        $id = (strpos($id, ':') === false) ? ':' . $id : $id;   // : needed for root pages

        // does the user want to see the "title" instead "pagename"
        if ($title) {
            $value = p_get_metadata($id, 'title', true);
            $name = (empty($value)) ? $this->_proper(noNS($id)) : $value;
        } elseif ($proper == 'name' || $proper == 'both') {
            $name = $this->_proper(noNS($id));
        } else {
            $name = '';
        }

        // show the "abstract" as a tooltip
        // -or- as a nice quoted snippet ( la blockquote plugin)
        $detail = '';
        if ($abstract == 'none') {
            $link = html_wikilink($id, $name);
        } elseif ($abstract == 'tooltip' || ($abstract > 0 && $link_count >= $abstract)) {
            $link = $this->_html_wikilink_tooltip($id, $name);
        } elseif ($abstract == 'all' || $abstract == 0 || ($abstract > 0 && $link_count < $abstract)) {
            $link = html_wikilink($id, $name);
            $detail = str_replace("\n\n", '<br/>', $this->_abstract($id));
            $more = html_wikilink($id, 'more...');
            $detail = '<blockquote>' . $detail . $more . '</blockquote>' . DOKU_LF;
        }
        return '<li>' . $link . '</li>' . DOKU_LF . $detail;
    }

    private function _proper($id) {
         $id = str_replace(':', ': ', $id);
         $id = str_replace('_', ' ', $id);
         $id = ucwords($id);
         $id = str_replace(': ', ':', $id);
         return $id;
    }
    /**
     * swap normal link title (popup) for a more useful preview
     *
     * @param string $id    page id
     * @param string $name  display name
     * @return complete href link 
     */
    private function _html_wikilink_tooltip($id, $name) {
        $link = html_wikilink($id, $name);
        $tooltip = $this->_abstract($id);
        $tooltip = str_replace("\n", '  ', $tooltip);
        $link = preg_replace('/title=\".+?\"/', 'title="' . $tooltip . '"', $link, 1);
        return $link;
    }

    private function _abstract($id) {
        $abstract = p_get_metadata($id, 'description abstract', true);
        $abstract = htmlspecialchars($abstract, ENT_QUOTES, 'UTF-8');
        return $abstract;
    }

    /**
     * Parse out the namespace, and convert to a regex for array search
     * -or- ensures that normal search are only within pagename not its namespace
     *
     * @param string $query user page query
     * @return processed query with regex markup as needed for namespace recognition
     */
    private function _parse_ns_query($query) {
        $incl_ns = preg_match('`(@|ns:)(\w+(\:\w+)*)(\s.+)*`', $query, $matches);
        if ($incl_ns > 0) {
            $ns = $matches[2];
            $page = trim($matches[4]);
            if ($page == '*') $page = '.*';
            $ns_query = $ns . ":.*" . $page;
            return array($ns_query, false);
        }
        $excl_ns = preg_match('`(\^|-ns:)(\w+(\:\w+)*)(\s.+)*`', $query, $matches);
        if ($excl_ns > 0) {
            $ns = $matches[2];
            $page = trim($matches[4]);
            if ($page == '*') $page = '.*';
            $ns_query = '^(?!' . $ns . '):.*' . $page;
            return array($ns_query, false);
        }
		if ($query == '*') $query= '.*';
        return array($query, true);	// true => turns on pageonly lookup
    }

    /**
     * Builds a separate sorting array for each sortby key
     *
     * @param string    $id         wiki page id
     * @param array     $sortby     keys to use for sorting
     * @param arrayref  $sortkeys   ref to sorting arrays
     * @return void
     */
    private function _get_sort_opts($ids, $sortkeys, $title) {
        $sort_opts = array();
        foreach ($ids as $id) {
            $meta = p_get_metadata ($id, false, true);
            if (!isset($meta['date']['modified'])) {
                $meta['date']['modified'] = $meta['date']['created'];
            }
            if ($title && !isset($meta['title'])) {
                $meta['title'] = $this->_proper(noNS($id));
            }
            $idx = 0;
            foreach ($sortkeys as $sortkey) {
                $key = $sortkey[0];
                switch ($key) {
                    case 'a':
                        $value = $this->_first(noNS($id), 1);
                        break;
                    case 'ab':
                        $value = $this->_first(noNS($id), 2);
                        break;
                    case 'abc':
                        $value = $this->_first(noNS($id), 3);
                        break;
                    case 'name':
                        $value = ($title) ? $meta['title'] : noNS($id);
                        break;
                    case 'id':
                    case 'page':
                        $value = $id;
                        break;
                    case 'ns':
                        $value = getNS($id);
                        if (empty($value)) $value = '(start)';
                        break;
                    case 'creator':
                        $value = $meta['creator'];
                        break;
                    case 'mdate':
                        $value = $meta['date']['modified'];
                        break;
                    case 'cdate':
                        $value = $meta['date']['created'];
                        break;
                    default:
                        $dtype = $key[0];
                        // the date formats are cached on first use; assumes one modifed & created per set
                        if ($dtype == 'c' || $dtype == 'm') {
                            if (!isset($dformat[$key])) {
                                $dformat[$key] = $this->_date_format($key);
                                $sort_opts[$idx]['format'] = $dformat[$key];
                            }
                            if ($dtype == 'c') {
                                $value = strftime($dformat[$key], $meta['date']['created']);
                            } elseif ($dtype == 'm') {
                                $value = strftime($dformat[$key], $meta['date']['modified']);
                            }
                        }
                }
                $sort_opts[$idx]['keys'][] = $value;
                $idx += 1;
            }
        }
        $idx = 0;
        foreach ($sortkeys as $sortkey) {
            list($key, $dir) = $sortkey;
            // now the sort direction
            switch ($dir) {
                case 'a':
                case 'asc':
                    $dir = SORT_ASC;
                    break;
                case 'd':
                case 'desc':
                    $dir = SORT_DESC;
                    break;
                default:
                    // sort descending by default; text ascending
                    // watch for other options beginning with c or m ....!
                    if ($key[0] == 'c' || $key[0] == 'm') {
                        $dir = SORT_DESC;
                    } else {
                        $dir = SORT_ASC;
                    }
            }
            $sort_opts[$idx]['dir'] = $dir;
            // and finally set the sort array's data type (for correct markup purposes)
            switch ($key) {
                // full-text and full dates cannot meaningfully be grouped (no duplicates!)
                case 'mdate':
                case 'cdate':
                case 'name':
                case 'id':
                case 'page':
                    $group = false;
                    break;
                default:
                    $group = true;
            }
            $sort_opts[$idx]['group'] = $group;
            // and now the sort data type
            switch ($key) {
                case 'mdate':
                case 'cdate':
                    $type = SORT_NUMERIC;
                    break;
                default:
                    $type = SORT_STRING;
            }
            $sort_opts[$idx]['type'] = $type;
            $idx += 1;
        }
        return $sort_opts;
    }

    // returns first $count letters from $text
    private function _first($text, $count) {
        if ($count > 0) {
            return substr($text, 0, $count);
        }
    }

    // parse the c|m-year-month-day option
    private function _date_format($key) {
        $year = (strpos($key, 'year') !== false) ? '%Y' : '';
        $month = (strpos($key, 'month') !== false) ? '%m' : '';
        $day = (strpos($key, 'day') !== false) ? '%d' : '';
        $format = $year . (($year != '' && ($month != '' || $day != '')) ? '-' : '');
        $format .= $month . ($month != '' && $day != '' ? '-' : '');
        $format .= $day;
        return $format;
    }

    // sort by each sorting array, in order
    private function _sort_results(&$ids, &$sort_opts) {
        if (!empty($sort_opts)) {
            $args = array();
            foreach ($sort_opts as &$sort_opt) {
                $args[] = &$sort_opt['keys'];
                $args[] = &$sort_opt['dir'];
                $args[] = &$sort_opt['type'];
            }
            $args[] = &$ids;
            call_user_func_array('array_multisort', $args);
        }
    }
    
    private function _group_results(&$ids, &$sort_opts) {
        $prevs = array();
        $results = array();
        $level = count($sort_opts) - 1;
        $idx = 0;
        foreach($ids as $id) {
            $this->_add_heading($results, $sort_opts, $level, $idx, $prevs);
            $results[] = $id;
            $idx++;
        }
        return $results;
    }
    
    private function _add_heading(&$results, &$sort_opts, $level, $idx, &$prevs) {
        if ($level > 0) {
            // recurse to find all parent headings
            $this->_add_heading($results, $sort_opts, $level - 1, $idx, $prevs);
        }
        $group = $sort_opts[$level]['group'];
        // only if this sort array can be grouped....
        if ($group) {
            $prev = (isset($prevs[$level])) ? $prevs[$level] : '';
            $cur = $sort_opts[$level]['keys'][$idx];
            if ($cur != $prev) {
                $prevs[$level] = $cur;
                $h = 'h' . ($level + 1);
                // display months and days in real words
                if ($this->inwords) {
                    $format = $sort_opts[$level]['format'];
                    switch ($format) {
                        case '%m':
                            $cur = strftime("%B", mktime(0, 0, 0, $cur, 10));
                            break;
                        case '%d':
                            $cur = strftime("%#d, %A ", mktime(0, 0, 0, 0, $cur));
                            break;
                        case '%Y-%m':
                            $cur = strftime("%B %Y", mktime(0, 0, 0, substr($cur, 5, 2), 10, substr($cur, 0, 4)));
                            break;
                        case '%m-%d':
                            $cur = strftime("%B %#d, %A ", mktime(0, 0, 0, substr($cur, 0, 2), substr($cur, 3, 2)));
                            break;
                        case '%Y-%m-%d':
                            $cur = strftime("%A, %B %#d, %Y", mktime(0, 0, 0, substr($cur, 5, 2), substr($cur, 8, 2), substr($cur, 0, 4)));
                            break;
                    }
                }
                // space in front ensures that ucwords works
                $results[] = "<$h> $cur</$h>";
            }
        }
    }

    /**
     * heavily customised version of _ft_pageLookup in inc/fulltext.php
     * I just removed the preg_quote line to enable regexes in search query...
     * and the unnecessary usort line as I have my own sort routines
     *
     */
    private function _pageLookup($query, $pageonly) {
        global $conf;
        
        $query = trim($query);
        $pages = file($conf['indexdir'].'/page.idx');
        $pages = array_values(preg_grep('/'.$query.'/', $pages));

        $cnt = count($pages);
        for($i = 0; $i < $cnt; $i++){
            if($pageonly){
                if(!preg_match('/'.$query.'/',noNS($pages[$i]))){
                    unset($pages[$i]);
                    continue;
                }
            }
            if(!page_exists($pages[$i])){
                unset($pages[$i]);
                continue;
            }
        }

        $pages = array_filter($pages, 'isVisiblePage'); // discard hidden pages
        if(!count($pages)) return array();

        $pages = array_map('trim',$pages);
        
        // check ACL permissions and remove any 'start' pages if req'd
        $start = $conf['start'];
        $pos = strlen($start);
        foreach($pages as $idx => $name) {
            if ($this->nostart && substr($name, -$pos) == $start) {
                unset($pages[$idx]);
            } elseif(auth_quickaclcheck(trim($pages[$idx])) < AUTH_READ){
                unset($pages[$idx]);
            }
        }
        return $pages;
    }
}

blob
mark :29
data 1629
div.dokuwiki div#pagequery h1,
div.dokuwiki div#pagequery h2,
div.dokuwiki div#pagequery h3,
div.dokuwiki div#pagequery h4,
div.dokuwiki div#pagequery h5,
div.dokuwiki div#pagequery h6 {
    padding:0.2em 0 0.1em 0;
    margin:0;
    margin-bottom:4px;
    color:gray;
}
div.dokuwiki div#pagequery h3,
div.dokuwiki div#pagequery h4,
div.dokuwiki div#pagequery h5,
div.dokuwiki div#pagequery h6 {
    font-weight:normal;
}
div.dokuwiki div#pagequery h1 {}
div.dokuwiki div#pagequery h2 {margin-left:8px; font-weight:bold;}
div.dokuwiki div#pagequery h3 {margin-left:16px}
div.dokuwiki div#pagequery h4 {margin-left:24px}
div.dokuwiki div#pagequery h5 {margin-left:30px}
div.dokuwiki div#pagequery h6 {margin-left:36px}

div.dokuwiki div#pagequery table {
    border-collapse:collapse;
    width:99%;
}
div.dokuwiki div#pagequery td {
	border-width:1px;
	padding:5px 10px;
	border-style:solid;
	border-color:#D7D5D4;
	background-color:white;
}
div.dokuwiki div#pagequery ul {
    list-style:none;
    margin:0 0 8px 36px;
	text-align:left;
}
div.dokuwiki div#pagequery ul.nogroup {
    margin:0 0 5px 3px;
}
div.dokuwiki div#pagequery li {
	padding-left:7px;
	list-style-position:inside;
	text-indent:-7px;
}
/* credit: blockquote:plugin */
div.dokuwiki div#pagequery blockquote {
    font-size:80%;
	margin: 5px 15px 10px 15px !important;
	border: 1px dotted __border__ !important;
	background: #FAFACE url(images/blockquote.gif) no-repeat 5px 5px !important;
	padding: 10px 15px 15px 18px !important;
    -moz-border-radius: 6px;
    -webkit-border-radius: 6px;
}
div.dokuwiki div#pagequery blockquote a {
    margin-left:12px;
}
blob
mark :30
data 25698
<?php
/**
 * PageQuery Plugin: search for and list pages
 *
 * @license    GPL 2 (http://www.gnu.org/licenses/gpl.html)
 * @author	   Symon Bent <symonbent@gmail.com>
 */
// must be run within Dokuwiki
if(!defined('DOKU_INC')) die();

if (!defined('DOKU_LF')) define('DOKU_LF', "\n");
if (!defined('DOKU_TAB')) define('DOKU_TAB', "\t");
if (!defined('DOKU_PLUGIN')) define('DOKU_PLUGIN',DOKU_INC.'lib/plugins/');

require_once(DOKU_PLUGIN.'syntax.php');
require_once(DOKU_INC.'inc/fulltext.php');

class syntax_plugin_pagequery extends DokuWiki_Syntax_Plugin {
    private $dformat = '';
    private $inwords = false;
    private $nostart = false;

	function getInfo() {
		$desc = file_get_contents(DOKU_PLUGIN . 'pagequery/readme.txt');
		return array(
			'author' => 'Symon Bent', 
			'email'  => 'hendrybadao@gmail.com',
			'date'   => '2010-05-05',
			'name'   => 'Pagequery Plugin',
			'desc'   => empty($desc) ? 'readme.txt is missing!' : $desc,
			'url'    => 'http://wiki.splitbrain.org/plugin:pagequery',
		);
	}

	function getType() {
		return 'substition';
	}
	
	function getPType() {
		return 'block';
	}
	
	function getSort() {
		return 98;
	}

	function connectTo($mode) {
		//Default is a word cloud style, looks good when combined with plugin:box
		$this->Lexer->addSpecialPattern('\{\{pagequery>.*?\}\}', $mode, 'plugin_pagequery');
	}
    /**
     * Parses all the pagequery options:
     * Insert the pagequery markup wherever you want your list to appear. E.g:
     *
     *   {{pagequery>}}
     *
     *   {{pagequery>[query];fulltext;sort=key:direction,key2:direction;group;limit=??;cols=?;inwords;proper}}
     * 
     * Parameters as follows:
     * 1. query:    any expression directly after the >; can use all Dokuwiki search options (see manual)
     * 2. fulltext: use a full-text search, instead of page_id only [default]
     * 3. sort:     keys to sort by, in order of sorting. Each key can be followed by prefered sorting order
     *              available keys:
     *                  a, ab, abc          by 1st letter, 2 letters, or 3 letters
     *                  name                by page name (no namespace) [not grouped]
     *                  page|id             by full page id, including namespace [not grouped]
     *                  ns                  by namespace (without page name)
     *                  mdate, cdate        by modified|created dates (full) [not grouped]
     *                  m[year][month][day] by modified [year][month][day]; any combination accepted
     *                  c[year][month][day] by created [year][month][day]; any combination accepted
     *                  creator             by page author
     *              date sort default to descending, string sorts to ascending
     * 4. group:    show group headers for each change in sort keys
     *              Note: keys with no duplicated cannot be grouped (i.e. name, page|id, mdate, cdate)
     * 5. limit:    maximum number of results to return
     * 6. inwords:  use real month and day names instead of just numbers
     * 7. cols:     number of columns in displayed list (max = 4)
     * 8. proper:   display page names and namespace in Proper Case (i.e. no _'s and Capitalised)
                    header/hdr = group headers only, name = page name only, both = both!
     * 9. border:   turn on borders
     *10. fullregex:only useful on page name searches; allows a raw regex mode on the full page idate
     *11. nostart:  ignore any 'start' pages in namespace
     *
     * All options are optional, and the list will default to a boring long 1-column list...
     */
	function handle($match, $state, $pos, &$handler) {
        global $conf;
        $this->dformat = $conf['dformat'];
        
		$match = substr($match, 12, -2); // strip markup incl. tagit>
		$args = explode(';', $match);
        $query = $args[0];
        $fulltext = false;
        $sort = array();
        $group = false;
        $limit = 0; //Default max tagits displayed. '0' => no limit
        $proper = 'none';
        $cols = 1;
        $border = false;
        $title = false; // use title instead of name
        $abstract = 'tooltip';
        
        foreach ($args as $arg) {
            list($key, $value) = explode('=', $arg);
            switch ($key) {
                case 'fulltext':
                    $fulltext = true;
                    break;
                case 'sort':
                    $values = explode(',', $value);
                    foreach ($values as $value) {
                        list($key, $dir) = explode(':', $value);
                        $sort[] = array($key, $dir);
                    }
                    break;
                case 'group':
                    $group = true;
                    break;
                case 'limit':
                    $limit = $value;
                    break;
                case 'inwords':
                    $inwords = true;
                    break;
                case 'proper':
                    switch ($value) {
                        case 'hdr':
                        case 'header':
                        case 'group':
                            $proper = 'header';
                            break;
                        case 'name':
                        case 'page':
                            $proper = 'name';
                            break;
                        default:
                            $proper = 'both';
                    }
                    break;
                case 'cols':
                    $cols = ($value > 4) ? 4 : $value;
                    break;
                case 'border':
                    $border = true;
                    break;
				case 'fullregex':
					$fullregex = true;
					break;
                case 'nostart':
                    $nostart = true;
                    break;
                case 'title':
                    $title = true;
                    break;
                case 'abstract':
                    switch ($value) {
                        case '':
                        case 'tooltip':
                            $abstract = 'tooltip';
                            break;
                        default:
                            if ($value >= 0) {
                                $abstract = $value;
                            }
                }
            }
        }
		return array($query, $fulltext, $sort, $group, $limit, $proper, 
                      $cols, $inwords, $border, $fullregex, $nostart, $title, $abstract);
	}

    function render($mode, &$renderer, $data) {
        $sortkeys = array();
        list($query, $fulltext, $sort, $group, $limit, $proper, 
              $cols, $inwords, $border, $fullregex, $nostart, $title, $abstract) = $data;
        $this->inwords = $inwords;
        $this->nostart = $nostart;
        
        if ($mode == 'xhtml') {
            // first get a raw list of matching results
            if ($fulltext) {
                $results = array_keys(ft_pageSearch($query, $highlight));
            } else {
                // allow for raw regex mode, for power users, this searches the full page id
                if ($fullregex) {
                    $full_query = $query;
                    $pageonly = false;
                } else {
                    list($full_query, $pageonly) = $this->_parse_ns_query($query);
                }
                $results = $this->_pageLookup($full_query, $pageonly);
            }
            // basic result page markup (always needed)
            $border_css = ($border === false) ? ' style="border-style:none;"' : '';
            $renderer->doc .= '<div id="pagequery">' . DOKU_LF;
            $renderer->doc .= '<table><tbody><tr>' . DOKU_LF;
            
            // display a "no results" message if empty
            if (empty($results)) {
                $renderer->doc .= '<td><p>' . $this->getLang("no_results") . 
                                  '"<strong>' . $query . '</strong>"</p></td>';
            } else {
                // prepare the necessary sorting arrays, as per options
                $sort_opts = $this->_get_sort_opts($results, $sort, $title);
                // now do the sorting
                $this->_sort_results($results, $sort_opts);
                // limit the result list length if required
                // remember: this can only be done after sorting!
                $results = ($limit > 0) ? array_slice($results, 0, $limit) : $results;
                // and finally the grouping
                if ($group) {
                    $results = $this->_group_results($results, $sort_opts);
                }
                $was_heading = false;
                $idx = 0;
                $col = 0;
                $rows = ceil(count($results) / $cols);  // proposed column row size
                $width = floor(100 / $cols);
                // remove indenting if not grouped
                $indent_css = ($group === false) ? ' class="nogroup"' : '';
                $link_count = 0;    // needed by the abstract snippet section

                foreach ($results as $id) {
                    // are we ready to start a new column? (up to max allowed)
                    if ($col < $cols && $idx % $rows == 0) {
                        $ready_for_col = true;
                        $col++;
                    }
                    $is_heading = ($id[1] == '|');
                    if ($is_heading) {
                        list($hl, $heading) = explode('|', $id);
                        if ($proper == 'header' || $proper == 'both') $heading = $this->_proper($heading);
                    }

                    // Begin new column if: we are at the start, at a heading or if there is no grouping
                    if ($ready_for_col && !$was_heading) {
                        // close the previous column if necessary
                        $cont_close = (!$is_heading) ? '<strong> ... </strong>' : '';
                        $cont_open = ($idx > 0 && !$is_heading) ? "<h$hl>$heading ...</h$hl>" : '';
                        $close = ($idx > 0) ? $cont_close . '</ul></td>' . DOKU_LF : '';
                        $renderer->doc .= $close . '<td' . $border_css . ' valign="top" width="' . $width . '%">' . $cont_open . DOKU_LF;
                        $ready_for_col = false;
                        $was_heading = true;    //needed to begin a new page id list
                    }
                    if ($is_heading) {
                        // close previous sub list if necessary
                        if (!$was_heading) $renderer->doc .= '</ul>' . DOKU_LF;
                        $renderer->doc .= "<h$hl>$heading</h$hl>" . DOKU_LF;
                        $was_heading = true;
                    } else {
                        // open a new sub list if necessary
                        if ($was_heading || $idx == 0) $renderer->doc .= '<ul' . $indent_css . '>';

                        // deal with normal page links
                        $link = $this->_render_wikilink($id, $proper, $title, $abstract, $link_count);
                        $link_count++;
                        $renderer->doc .= $link;
                        $was_heading = false;
                    }
                    $idx++;
                }
                $renderer->doc .= '</ul></td>';
            }
            $renderer->doc .= '</tr>' . DOKU_LF;
            $renderer->doc .= '</tbody></table>';
            $renderer->doc .= '</div>' . DOKU_LF;
        } else {
            return false;
        }
    }
    /**
     * Renders the page link, plus tooltip, abstract, casing, etc...
     * @param string $id
     * @param bool  $proper
     * @param bool  $title
     * @param mixed $abstract
     */
    private function _render_wikilink($id, $proper, $title, $abstract, $link_count) {

        $id = (strpos($id, ':') === false) ? ':' . $id : $id;   // : needed for root pages

        // does the user want to see the "title" instead "pagename"
        if ($title) {
            $value = p_get_metadata($id, 'title', true);
            $name = (empty($value)) ? $this->_proper(noNS($id)) : $value;
        } elseif ($proper == 'name' || $proper == 'both') {
            $name = $this->_proper(noNS($id));
        } else {
            $name = '';
        }

        // show the "abstract" as a tooltip
        // -or- as a nice quoted snippet ( la blockquote plugin)
        $detail = '';
        if ($abstract == 'none') {
            $link = html_wikilink($id, $name);
        } elseif ($abstract == 'tooltip' || ($abstract > 0 && $link_count >= $abstract)) {
            $link = $this->_html_wikilink_tooltip($id, $name);
        } elseif ($abstract == 'all' || $abstract == 0 || ($abstract > 0 && $link_count < $abstract)) {
            $link = html_wikilink($id, $name);
            $detail = str_replace("\n\n", '<br/>', $this->_abstract($id));
            $more = html_wikilink($id, 'more...');
            $detail = '<blockquote>' . $detail . $more . '</blockquote>' . DOKU_LF;
        }
        return '<li>' . $link . '</li>' . DOKU_LF . $detail;
    }

    private function _proper($id) {
         $id = str_replace(':', ': ', $id);
         $id = str_replace('_', ' ', $id);
         $id = ucwords($id);
         $id = str_replace(': ', ':', $id);
         return $id;
    }
    /**
     * swap normal link title (popup) for a more useful preview
     *
     * @param string $id    page id
     * @param string $name  display name
     * @return complete href link 
     */
    private function _html_wikilink_tooltip($id, $name) {
        $link = html_wikilink($id, $name);
        $tooltip = $this->_abstract($id);
        $tooltip = str_replace("\n", '  ', $tooltip);
        $link = preg_replace('/title=\".+?\"/', 'title="' . $tooltip . '"', $link, 1);
        return $link;
    }

    private function _abstract($id) {
        $abstract = p_get_metadata($id, 'description abstract', true);
        $abstract = htmlspecialchars($abstract, ENT_QUOTES, 'UTF-8');
        return $abstract;
    }

    /**
     * Parse out the namespace, and convert to a regex for array search
     * -or- ensures that normal search are only within pagename not its namespace
     *
     * @param string $query user page query
     * @return processed query with regex markup as needed for namespace recognition
     */
    private function _parse_ns_query($query) {
        $incl_ns = preg_match('`(@|ns:)(\w+(\:\w+)*)(\s.+)*`', $query, $matches);
        if ($incl_ns > 0) {
            $ns = $matches[2];
            $page = trim($matches[4]);
            if ($page == '*') $page = '.*';
            $ns_query = $ns . ":.*" . $page;
            return array($ns_query, false);
        }
        $excl_ns = preg_match('`(\^|-ns:)(\w+(\:\w+)*)(\s.+)*`', $query, $matches);
        if ($excl_ns > 0) {
            $ns = $matches[2];
            $page = trim($matches[4]);
            if ($page == '*') $page = '.*';
            $ns_query = '^(?!' . $ns . '):.*' . $page;
            return array($ns_query, false);
        }
		if ($query == '*') $query= '.*';
        return array($query, true);	// true => turns on pageonly lookup
    }

    /**
     * Builds a separate sorting array for each sortby key
     *
     * @param string    $id         wiki page id
     * @param array     $sortby     keys to use for sorting
     * @param arrayref  $sortkeys   ref to sorting arrays
     * @return void
     */
    private function _get_sort_opts($ids, $sortkeys, $title) {
        global $conf;
        $sort_opts = array();
        
        foreach ($ids as $id) {
            $meta = p_get_metadata ($id, false, true);
            if (!isset($meta['date']['modified'])) {
                $meta['date']['modified'] = $meta['date']['created'];
            }
            if ($title && !isset($meta['title'])) {
                $meta['title'] = $this->_proper(noNS($id));
            }
            $idx = 0;
            foreach ($sortkeys as $sortkey) {
                $key = $sortkey[0];
                switch ($key) {
                    case 'a':
                        $value = $this->_first(noNS($id), 1);
                        break;
                    case 'ab':
                        $value = $this->_first(noNS($id), 2);
                        break;
                    case 'abc':
                        $value = $this->_first(noNS($id), 3);
                        break;
                    case 'name':
                        $value = ($title) ? $meta['title'] : noNS($id);
                        break;
                    case 'id':
                    case 'page':
                        $value = $id;
                        break;
                    case 'ns':
                        $value = getNS($id);
                        if (empty($value)) $value = '(' . $conf['start'] . ')';
                        break;
                    case 'creator':
                        $value = $meta['creator'];
                        break;
                    case 'mdate':
                        $value = $meta['date']['modified'];
                        break;
                    case 'cdate':
                        $value = $meta['date']['created'];
                        break;
                    default:
                        $dtype = $key[0];
                        // the date formats are cached on first use; assumes one modifed & created per set
                        if ($dtype == 'c' || $dtype == 'm') {
                            if (!isset($dformat[$key])) {
                                $dformat[$key] = $this->_date_format($key);
                                $sort_opts[$idx]['format'] = $dformat[$key];
                            }
                            if ($dtype == 'c') {
                                $value = strftime($dformat[$key], $meta['date']['created']);
                            } elseif ($dtype == 'm') {
                                $value = strftime($dformat[$key], $meta['date']['modified']);
                            }
                        }
                }
                $sort_opts[$idx]['keys'][] = $value;
                $idx += 1;
            }
        }
        $idx = 0;
        foreach ($sortkeys as $sortkey) {
            list($key, $dir) = $sortkey;
            // now the sort direction
            switch ($dir) {
                case 'a':
                case 'asc':
                    $dir = SORT_ASC;
                    break;
                case 'd':
                case 'desc':
                    $dir = SORT_DESC;
                    break;
                default:
                    // sort descending by default; text ascending
                    // watch for other options beginning with c or m ....!
                    if ($key[0] == 'c' || $key[0] == 'm') {
                        $dir = SORT_DESC;
                    } else {
                        $dir = SORT_ASC;
                    }
            }
            $sort_opts[$idx]['dir'] = $dir;
            // and finally set the sort array's data type (for correct markup purposes)
            switch ($key) {
                // full-text and full dates cannot meaningfully be grouped (no duplicates!)
                case 'mdate':
                case 'cdate':
                case 'name':
                case 'id':
                case 'page':
                    $group = false;
                    break;
                case 'ns':
                    $group = 'ns';
                    break;
                default:
                    $group = true;
            }
            $sort_opts[$idx]['group'] = $group;
            // and now the sort data type
            $is_ns = false;
            switch ($key) {
                case 'mdate':
                case 'cdate':
                    $type = SORT_NUMERIC;
                    break;
                default:
                    $type = SORT_STRING;
            }
            $sort_opts[$idx]['type'] = $type;
            $idx += 1;
        }
        return $sort_opts;
    }

    // returns first $count letters from $text
    private function _first($text, $count) {
        if ($count > 0) {
            return substr($text, 0, $count);
        }
    }

    // parse the c|m-year-month-day option
    private function _date_format($key) {
        $year = (strpos($key, 'year') !== false) ? '%Y' : '';
        $month = (strpos($key, 'month') !== false) ? '%m' : '';
        $day = (strpos($key, 'day') !== false) ? '%d' : '';
        $format = $year . (($year != '' && ($month != '' || $day != '')) ? '-' : '');
        $format .= $month . ($month != '' && $day != '' ? '-' : '');
        $format .= $day;
        return $format;
    }

    // sort by each sorting array, in order
    private function _sort_results(&$ids, &$sort_opts) {
        if (!empty($sort_opts)) {
            $args = array();
            foreach ($sort_opts as &$sort_opt) {
                $args[] = &$sort_opt['keys'];
                $args[] = &$sort_opt['dir'];
                $args[] = &$sort_opt['type'];
            }
            $args[] = &$ids;
            call_user_func_array('array_multisort', $args);
        }
    }
    
    private function _group_results(&$ids, &$sort_opts) {
        $prevs = array();
        $results = array();
        $level = count($sort_opts) - 1;
        $idx = 0;
        foreach($ids as $id) {
            $this->_add_heading($results, $sort_opts, $level, $idx, $prevs);
            $results[] = $id;
            $idx++;
        }
        return $results;
    }
    
    private function _add_heading(&$results, &$sort_opts, $level, $idx, &$prevs) {
        if ($level > 0) {
            // recurse to find all parent headings
            $this->_add_heading($results, $sort_opts, $level - 1, $idx, $prevs);
        }
        $group = $sort_opts[$level]['group'];
        // only if this sort array can be grouped....
        if ($group === true) {
            $prev = (isset($prevs[$level])) ? $prevs[$level] : '';
            $cur = $sort_opts[$level]['keys'][$idx];
            if ($cur != $prev) {
                $prevs[$level] = $cur;
                $hl = ($level + 1);
                // display months and days in real words
                if ($this->inwords) {
                    $format = $sort_opts[$level]['format'];
                    switch ($format) {
                        case '%m':
                            $cur = strftime("%B", mktime(0, 0, 0, $cur, 10));
                            break;
                        case '%d':
                            $cur = strftime("%#d, %A ", mktime(0, 0, 0, 0, $cur));
                            break;
                        case '%Y-%m':
                            $cur = strftime("%B %Y", mktime(0, 0, 0, substr($cur, 5, 2), 10, substr($cur, 0, 4)));
                            break;
                        case '%m-%d':
                            $cur = strftime("%B %#d, %A ", mktime(0, 0, 0, substr($cur, 0, 2), substr($cur, 3, 2)));
                            break;
                        case '%Y-%m-%d':
                            $cur = strftime("%A, %B %#d, %Y", mktime(0, 0, 0, substr($cur, 5, 2), substr($cur, 8, 2), substr($cur, 0, 4)));
                            break;
                    }
                }
                $results[] = $hl . '|' . $cur;
            }
        } elseif ($group == 'ns') {
            $prev = (isset($prevs[$level])) ? $prevs[$level] : '';
            $cur = $sort_opts[$level]['keys'][$idx];
            if ($cur != $prev) {
                $prevs[$level] = $cur;
                $cur_ns = explode(':', $cur);
                $prev_ns = explode(':', $prev);
                // we only show namespaces that are different from the previous heading
                for ($i= 0; $i < count($cur_ns); $i++) {
                    if ($cur_ns[$i] != $prev_ns[$i]) {
                        $hl = $level + $i + 1;
                        $hl = ($hl > 6) ? 6 : $hl;
                        $results[] = $hl . '|' . $cur_ns[$i];
                    }
                }
            }
        }
    }

    
    /**
     * heavily customised version of _ft_pageLookup in inc/fulltext.php
     * I just removed the preg_quote line to enable regexes in search query...
     * and the unnecessary usort line as I have my own sort routines
     *
     */
    private function _pageLookup($query, $pageonly) {
        global $conf;
        
        $query = trim($query);
        $pages = file($conf['indexdir'].'/page.idx');
        $pages = array_values(preg_grep('/'.$query.'/', $pages));

        $cnt = count($pages);
        for($i = 0; $i < $cnt; $i++){
            if($pageonly){
                if(!preg_match('/'.$query.'/',noNS($pages[$i]))){
                    unset($pages[$i]);
                    continue;
                }
            }
            if(!page_exists($pages[$i])){
                unset($pages[$i]);
                continue;
            }
        }

        $pages = array_filter($pages, 'isVisiblePage'); // discard hidden pages
        if(!count($pages)) return array();

        $pages = array_map('trim',$pages);
        
        // check ACL permissions and remove any 'start' pages if req'd
        $start = $conf['start'];
        $pos = strlen($start);
        foreach($pages as $idx => $name) {
            if ($this->nostart && substr($name, -$pos) == $start) {
                unset($pages[$idx]);
            } elseif(auth_quickaclcheck(trim($pages[$idx])) < AUTH_READ){
                unset($pages[$idx]);
            }
        }
        return $pages;
    }
}

blob
mark :32
data 25674
<?php
/**
 * PageQuery Plugin: search for and list pages, sorted by name, date, creator, etc
 *
 * @license    GPL 2 (http://www.gnu.org/licenses/gpl.html)
 * @author	   Symon Bent <hendrybadao@gmail.com>
 */
// must be run within Dokuwiki
if(!defined('DOKU_INC')) die();

if (!defined('DOKU_LF')) define('DOKU_LF', "\n");
if (!defined('DOKU_TAB')) define('DOKU_TAB', "\t");
if (!defined('DOKU_PLUGIN')) define('DOKU_PLUGIN',DOKU_INC.'lib/plugins/');

require_once(DOKU_PLUGIN.'syntax.php');
require_once(DOKU_INC.'inc/fulltext.php');

class syntax_plugin_pagequery extends DokuWiki_Syntax_Plugin {
    private $dformat = '';
    private $inwords = false;
    private $nostart = false;

	function getType() {
		return 'substition';
	}

	function getPType() {
		return 'block';
	}

	function getSort() {
		return 98;
	}

	function connectTo($mode) {
		//Default is a word cloud style, looks good when combined with plugin:box
		$this->Lexer->addSpecialPattern('\{\{pagequery>.*?\}\}', $mode, 'plugin_pagequery');
	}
    /**
     * Parses all the pagequery options:
     * Insert the pagequery markup wherever you want your list to appear. E.g:
     *
     *   {{pagequery>}}
     *
     *   {{pagequery>[query];fulltext;sort=key:direction,key2:direction;group;limit=??;cols=?;inwords;proper}}
     *
     * Parameters as follows:
     * 1. query:    any expression directly after the >; can use all Dokuwiki search options (see manual)
     * 2. fulltext: use a full-text search, instead of page_id only [default]
     * 3. sort:     keys to sort by, in order of sorting. Each key can be followed by prefered sorting order
     *              available keys:
     *                  a, ab, abc          by 1st letter, 2 letters, or 3 letters
     *                  name                by page name (no namespace) [not grouped]
     *                  page|id             by full page id, including namespace [not grouped]
     *                  ns                  by namespace (without page name)
     *                  mdate, cdate        by modified|created dates (full) [not grouped]
     *                  m[year][month][day] by modified [year][month][day]; any combination accepted
     *                  c[year][month][day] by created [year][month][day]; any combination accepted
     *                  creator             by page author
     *              date sort default to descending, string sorts to ascending
     * 4. group:    show group headers for each change in sort keys
     *              Note: keys with no duplicated cannot be grouped (i.e. name, page|id, mdate, cdate)
     * 5. limit:    maximum number of results to return
     * 6. inwords:  use real month and day names instead of just numbers
     * 7. cols:     number of columns in displayed list (max = 4)
     * 8. proper:   display page names and namespace in Proper Case (i.e. no _'s and Capitalised)
                    header/hdr = group headers only, name = page name only, both = both!
     * 9. border:   turn on borders
     *10. fullregex:only useful on page name searches; allows a raw regex mode on the full page idate
     *11. nostart:  ignore any 'start' pages in namespace
     *
     * All options are optional, and the list will default to a boring long 1-column list...
     */
	function handle($match, $state, $pos, &$handler) {
        global $conf;
        $this->dformat = $conf['dformat'];

		$match = substr($match, 12, -2); // strip markup incl. pagequery>
		$args = explode(';', $match);
        $query = $args[0];
        $fulltext = false;
        $sort = array();
        $group = false;
        $limit = 0; //Default max items displayed. '0' => no limit
        $proper = 'none';
        $cols = 1;
        $border = false;
        $title = false; // use title instead of name
        $abstract = 'tooltip';

        foreach ($args as $arg) {
            list($key, $value) = explode('=', $arg);
            switch ($key) {
                case 'fulltext':
                    $fulltext = true;
                    break;
                case 'sort':
                    $values = explode(',', $value);
                    foreach ($values as $value) {
                        list($key, $dir) = explode(':', $value);
                        $sort[] = array($key, $dir);
                    }
                    break;
                case 'group':
                    $group = true;
                    break;
                case 'limit':
                    $limit = $value;
                    break;
                case 'inwords':
                    $inwords = true;
                    break;
                case 'proper':
                    switch ($value) {
                        case 'hdr':
                        case 'header':
                        case 'group':
                            $proper = 'header';
                            break;
                        case 'name':
                        case 'page':
                            $proper = 'name';
                            break;
                        default:
                            $proper = 'both';
                    }
                    break;
                case 'cols':
                    $cols = ($value > 4) ? 4 : $value;
                    break;
                case 'border':
                    $border = true;
                    break;
				case 'fullregex':
					$fullregex = true;
					break;
                case 'nostart':
                    $nostart = true;
                    break;
                case 'title':
                    $title = true;
                    break;
                case 'abstract':
                    switch ($value) {
                        case '':
                        case 'tooltip':
                            $abstract = 'tooltip';
                            break;
                        default:
                            if ($value >= 0) {
                                $abstract = $value;
                            }
                }
            }
        }
		return array($query, $fulltext, $sort, $group, $limit, $proper,
                      $cols, $inwords, $border, $fullregex, $nostart, $title, $abstract);
	}

    function render($mode, &$renderer, $data) {
        $sortkeys = array();
        list($query, $fulltext, $sort, $group, $limit, $proper,
              $cols, $inwords, $border, $fullregex, $nostart, $title, $abstract) = $data;
        $this->inwords = $inwords;
        $this->nostart = $nostart;

        if ($mode == 'xhtml') {
            // first get a raw list of matching results
            if ($fulltext) {
                $results = array_keys(ft_pageSearch($query, $highlight));
            } else {
                // allow for raw regex mode, for power users, this searches the full page id
                if ($fullregex) {
                    $full_query = $query;
                    $pageonly = false;
                } else {
                    list($full_query, $pageonly) = $this->_parse_ns_query($query);
                }
                $results = $this->_pageLookup($full_query, $pageonly);
            }
            // basic result page markup (always needed)
            $border_css = ($border === false) ? ' style="border-style:none;"' : '';
            $renderer->doc .= '<div id="pagequery">' . DOKU_LF;
            $renderer->doc .= '<table><tbody><tr>' . DOKU_LF;

            // display a "no results" message if empty
            if (empty($results)) {
                $renderer->doc .= '<td><p>' . $this->getLang("no_results") .
                                  '"<strong>' . $query . '</strong>"</p></td>';
            } else {
                // prepare the necessary sorting arrays, as per options
                list($sort_opts, $dates) = $this->_get_sort_opts($results, $sort, $title);
                // now do the sorting
                $this->_sort_results($results, $sort_opts, $dates);
                // limit the result list length if required
                // remember: this can only be done after sorting!
                $results = ($limit > 0) ? array_slice($results, 0, $limit) : $results;
                // and finally the grouping
                if ($group) {
                    $results = $this->_group_results($results, $sort_opts, $dates);
                }
                $was_heading = false;
                $idx = 0;
                $col = 0;
                $rows = ceil(count($results) / $cols);  // proposed column row size
                $width = floor(100 / $cols);
                // remove indenting if not grouped
                $indent_css = ($group === false) ? ' class="nogroup"' : '';
                $link_count = 0;    // needed by the abstract snippet section

                foreach ($results as $id) {
                    // are we ready to start a new column? (up to max allowed)
                    if ($col < $cols && $idx % $rows == 0) {
                        $ready_for_col = true;
                        $col++;
                    }
                    $is_heading = ($id[1] == '|');
                    if ($is_heading) {
                        list($hl, $heading) = explode('|', $id);
                        if ($proper == 'header' || $proper == 'both') $heading = $this->_proper($heading);
                    }

                    // Begin new column if: we are at the start, at a heading or if there is no grouping
                    if ($ready_for_col && !$was_heading) {
                        // close the previous column if necessary
                        $cont_close = (!$is_heading) ? '<strong> ... </strong>' : '';
                        $cont_open = ($idx > 0 && !$is_heading) ? "<h$hl>$heading ...</h$hl>" : '';
                        $close = ($idx > 0) ? $cont_close . '</ul></td>' . DOKU_LF : '';
                        $renderer->doc .= $close . '<td' . $border_css . ' valign="top" width="' . $width . '%">' . $cont_open . DOKU_LF;
                        $ready_for_col = false;
                        $was_heading = true;    //needed to begin a new page id list
                    }
                    if ($is_heading) {
                        // close previous sub list if necessary
                        if (!$was_heading) $renderer->doc .= '</ul>' . DOKU_LF;
                        $renderer->doc .= "<h$hl>$heading</h$hl>" . DOKU_LF;
                        $was_heading = true;
                    } else {
                        // open a new sub list if necessary
                        if ($was_heading || $idx == 0) $renderer->doc .= '<ul' . $indent_css . '>';

                        // deal with normal page links
                        $link = $this->_render_wikilink($id, $proper, $title, $abstract, $link_count);
                        $link_count++;
                        $renderer->doc .= $link;
                        $was_heading = false;
                    }
                    $idx++;
                }
                $renderer->doc .= '</ul></td>';
            }
            $renderer->doc .= '</tr>' . DOKU_LF;
            $renderer->doc .= '</tbody></table>';
            $renderer->doc .= '</div>' . DOKU_LF;
        } else {
            return false;
        }
    }
    /**
     * Renders the page link, plus tooltip, abstract, casing, etc...
     * @param string $id
     * @param bool  $proper
     * @param bool  $title
     * @param mixed $abstract
     */
    private function _render_wikilink($id, $proper, $title, $abstract, $link_count) {

        $id = (strpos($id, ':') === false) ? ':' . $id : $id;   // : needed for root pages

        // does the user want to see the "title" instead "pagename"
        if ($title) {
            $value = p_get_metadata($id, 'title', true);
            $name = (empty($value)) ? $this->_proper(noNS($id)) : $value;
        } elseif ($proper == 'name' || $proper == 'both') {
            $name = $this->_proper(noNS($id));
        } else {
            $name = '';
        }

        // show the "abstract" as a tooltip
        // -or- as a nice quoted snippet ( la blockquote plugin)
        $detail = '';
        if ($abstract == 'none') {
            $link = html_wikilink($id, $name);
        } elseif ($abstract == 'tooltip' || ($abstract > 0 && $link_count >= $abstract)) {
            $link = $this->_html_wikilink_tooltip($id, $name);
        } elseif ($abstract == 'all' || $abstract == 0 || ($abstract > 0 && $link_count < $abstract)) {
            $link = html_wikilink($id, $name);
            $detail = str_replace("\n\n", '<br/>', $this->_abstract($id));
            $more = html_wikilink($id, 'more...');
            $detail = '<blockquote>' . $detail . $more . '</blockquote>' . DOKU_LF;
        }
        return '<li>' . $link . '</li>' . DOKU_LF . $detail;
    }

    private function _proper($id) {
         $id = str_replace(':', ': ', $id);
         $id = str_replace('_', ' ', $id);
         $id = ucwords($id);
         $id = str_replace(': ', ':', $id);
         return $id;
    }
    /**
     * swap normal link title (popup) for a more useful preview
     *
     * @param string $id    page id
     * @param string $name  display name
     * @return complete href link
     */
    private function _html_wikilink_tooltip($id, $name) {
        $link = html_wikilink($id, $name);
        $tooltip = $this->_abstract($id);
        $tooltip = str_replace("\n", '  ', $tooltip);
        $link = preg_replace('/title=\".+?\"/', 'title="' . $tooltip . '"', $link, 1);
        return $link;
    }

    private function _abstract($id) {
        $abstract = p_get_metadata($id, 'description abstract', true);
        $abstract = htmlspecialchars($abstract, ENT_QUOTES, 'UTF-8');
        return $abstract;
    }

    /**
     * Parse out the namespace, and convert to a regex for array search
     * -or- ensures that normal search are only within pagename not its namespace
     *
     * @param string $query user page query
     * @return processed query with regex markup as needed for namespace recognition
     */
    private function _parse_ns_query($query) {
        $incl_ns = preg_match('`(@|ns:)(\w+(\:\w+)*)(\s.+)*`', $query, $matches);
        if ($incl_ns > 0) {
            $ns = $matches[2];
            $page = trim($matches[4]);
            if ($page == '*') $page = '.*';
            $ns_query = $ns . ":.*" . $page;
            return array($ns_query, false);
        }
        $excl_ns = preg_match('`(\^|-ns:)(\w+(\:\w+)*)(\s.+)*`', $query, $matches);
        if ($excl_ns > 0) {
            $ns = $matches[2];
            $page = trim($matches[4]);
            if ($page == '*') $page = '.*';
            $ns_query = '^(?!' . $ns . '):.*' . $page;
            return array($ns_query, false);
        }
		if ($query == '*') $query= '.*';
        return array($query, true);	// true => turns on pageonly lookup
    }

    /**
     * Builds a separate sorting array for each sortby key
     *
     * @param string    $id         wiki page id
     * @param array     $sortby     keys to use for sorting
     * @param arrayref  $sortkeys   ref to sorting arrays
     * @return void
     */
    private function _get_sort_opts($ids, $sortkeys, $title) {
        global $conf;
        $sort_opts = array();
        $dformat = array();
        $dates = array();

        $cnt = 0;
        foreach ($ids as $id) {
            $meta = p_get_metadata ($id, false, true);
            if (!isset($meta['date']['modified'])) {
                $meta['date']['modified'] = $meta['date']['created'];
            }
            if ($title && !isset($meta['title'])) {
                $meta['title'] = $this->_proper(noNS($id));
            }
            $idx = 0;
            foreach ($sortkeys as $sortkey) {
                $key = $sortkey[0];
                switch ($key) {
                    case 'a':
                        $value = $this->_first(noNS($id), 1);
                        break;
                    case 'ab':
                        $value = $this->_first(noNS($id), 2);
                        break;
                    case 'abc':
                        $value = $this->_first(noNS($id), 3);
                        break;
                    case 'name':
                        $value = ($title) ? $meta['title'] : noNS($id);
                        break;
                    case 'id':
                    case 'page':
                        $value = $id;
                        break;
                    case 'ns':
                        $value = getNS($id);
                        if (empty($value)) $value = '(' . $conf['start'] . ')';
                        break;
                    case 'creator':
                        $value = $meta['creator'];
                        break;
                    case 'mdate':
                        $value = $meta['date']['modified'];
                        break;
                    case 'cdate':
                        $value = $meta['date']['created'];
                        break;
                    default:
                        $dtype = $key[0];
                        if ($dtype == 'c' || $dtype == 'm') {
                            // only set date once per id (not per sort column--date remains same across columns)
                            if ( ! isset($dates[$cnt])) {
                                if ($dtype == 'c') {
                                    $date = $meta['date']['created'];
                                } else {
                                    $date = $meta['date']['modified'];
                                }
                                $dates[$cnt] = $date;
                            } else {
                                $date = $dates[$cnt];
                            }
                            // the date formats are cached on first use; allows one of each key type per set
                            if ( ! isset($dformat[$key])) {
                                $dformat[$key] = $this->_date_format($key, $this->inwords);
                                $sort_opts[$idx]['inwords'] = $dformat[$key][1];
                            }
                            $value = strftime($dformat[$key][0], $date);
                        }
                }
                $sort_opts[$idx]['keys'][] = $value;
                $idx++;
            }
            $cnt++;
        }
        $idx = 0;
        foreach ($sortkeys as $sortkey) {
            list($key, $dir) = $sortkey;
            // now the sort direction
            switch ($dir) {
                case 'a':
                case 'asc':
                    $dir = SORT_ASC;
                    break;
                case 'd':
                case 'desc':
                    $dir = SORT_DESC;
                    break;
                default:
                    // sort descending by default; text ascending
                    // watch for other options beginning with c or m ....!
                    if ($key[0] == 'c' || $key[0] == 'm') {
                        $dir = SORT_DESC;
                    } else {
                        $dir = SORT_ASC;
                    }
            }
            $sort_opts[$idx]['dir'] = $dir;
            // and finally set the sort array's data type (for correct markup purposes)
            switch ($key) {
                // full-text and full dates cannot meaningfully be grouped (no duplicates!)
                case 'mdate':
                case 'cdate':
                case 'name':
                case 'id':
                case 'page':
                    $group = false;
                    break;
                case 'ns':
                    $group = 'ns';
                    break;
                default:
                    $group = true;
            }
            $sort_opts[$idx]['group'] = $group;
            // and now the sort data type
            $is_ns = false;
            switch ($key) {
                case 'mdate':
                case 'cdate':
                    $type = SORT_NUMERIC;
                    break;
                default:
                    $type = SORT_STRING;
            }
            $sort_opts[$idx]['type'] = $type;
            $idx++;
        }
        return array($sort_opts, $dates);
    }

    // returns first $count letters from $text
    private function _first($text, $count) {
        if ($count > 0) {
            return substr($text, 0, $count);
        }
    }

    // parse the c|m-year-month-day option
    private function _date_format($key, $inwords = false) {
        $year = (strpos($key, 'year') !== false) ? '%Y' : '';
        $month = (strpos($key, 'month') !== false) ? '%m' : '';
        $day = (strpos($key, 'day') !== false) ? '%d' : '';
        $format = $year . (($year != '' && ($month != '' || $day != '')) ? '-' : '');
        $format .= $month . ($month != '' && $day != '' ? '-' : '');
        $format .= $day;
        // provide month and day format in real words if required
        // used for display only, the $key is used for sorting!
        $wformat = '';
        if ($inwords) {
            switch ($format) {
                case '%m':
                    $wformat = "%B";
                    break;
                case '%d':
                    $wformat = "%#d, %A ";
                    break;
                case '%Y-%m':
                    $wformat = "%B %Y";
                    break;
                case '%m-%d':
                    $wformat= "%B %#d, %A ";
                    break;
                case '%Y-%m-%d':
                    $wformat = "%A, %B %#d, %Y";
                    break;
            }
        }
        return array($format, $wformat);
    }

    // sort by each sorting array, in order
    private function _sort_results(&$ids, &$sort_opts, &$dates) {
        if ( ! empty($sort_opts)) {
            $args = array();
            foreach ($sort_opts as &$sort_opt) {
                $args[] = &$sort_opt['keys'];
                $args[] = &$sort_opt['dir'];
                $args[] = &$sort_opt['type'];
            }
            $args[] = &$dates;
            $args[] = &$ids;
            call_user_func_array('array_multisort', $args);
        }
    }

    private function _group_results(&$ids, &$sort_opts, &$dates) {
        $prevs = array();
        $results = array();
        $level = count($sort_opts) - 1;
        $idx = 0;
        foreach($ids as $id) {
            $this->_add_heading($results, $sort_opts, $dates, $level, $idx, $prevs);
            $results[] = $id;
            $idx++;
        }
        return $results;
    }

    private function _add_heading(&$results, &$sort_opts, &$dates, $level, $idx, &$prevs) {
        if ($level > 0) {
            // recurse to find all parent headings
            $this->_add_heading($results, $sort_opts, $dates, $level - 1, $idx, $prevs);
        }
        $group = $sort_opts[$level]['group'];
        // only if this sort array can be grouped....
        if ($group === true) {
            $prev = (isset($prevs[$level])) ? $prevs[$level] : '';
            $cur = $sort_opts[$level]['keys'][$idx];
            if ($cur != $prev) {
                $prevs[$level] = $cur;
                $hl = ($level + 1);
                $inwords = $sort_opts[$level]['inwords'];
                if ($this->inwords && ! empty($inwords)) $cur = strftime($inwords, $dates[$idx]);
                $results[] = $hl . '|' . $cur;
            }
        } elseif ($group == 'ns') {
            $prev = (isset($prevs[$level])) ? $prevs[$level] : '';
            $cur = $sort_opts[$level]['keys'][$idx];
            if ($cur != $prev) {
                $prevs[$level] = $cur;
                $cur_ns = explode(':', $cur);
                $prev_ns = explode(':', $prev);
                // we only show namespaces that are different from the previous heading
                for ($i= 0; $i < count($cur_ns); $i++) {
                    if ($cur_ns[$i] != $prev_ns[$i]) {
                        $hl = $level + $i + 1;
                        $hl = ($hl > 6) ? 6 : $hl;
                        $results[] = $hl . '|' . $cur_ns[$i];
                    }
                }
            }
        }
    }


    /**
     * heavily customised version of _ft_pageLookup in inc/fulltext.php
     * I just removed the preg_quote line to enable regexes in search query...
     * and the unnecessary usort line as I have my own sort routines
     *
     */
    private function _pageLookup($query, $pageonly) {
        global $conf;

        $query = trim($query);
        $pages = file($conf['indexdir'].'/page.idx');
        $pages = array_values(preg_grep('/'.$query.'/', $pages));

        $cnt = count($pages);
        for($i = 0; $i < $cnt; $i++){
            if($pageonly){
                if(!preg_match('/'.$query.'/',noNS($pages[$i]))){
                    unset($pages[$i]);
                    continue;
                }
            }
            if(!page_exists($pages[$i])){
                unset($pages[$i]);
                continue;
            }
        }

        $pages = array_filter($pages, 'isVisiblePage'); // discard hidden pages
        if(!count($pages)) return array();

        $pages = array_map('trim',$pages);

        // check ACL permissions and remove any 'start' pages if req'd
        $start = $conf['start'];
        $pos = strlen($start);
        foreach($pages as $idx => $name) {
            if ($this->nostart && substr($name, -$pos) == $start) {
                unset($pages[$idx]);
            } elseif(auth_quickaclcheck(trim($pages[$idx])) < AUTH_READ){
                unset($pages[$idx]);
            }
        }
        return $pages;
    }
}

blob
mark :34
data 25559
<?php
/**
 * PageQuery Plugin: search for and list pages, sorted by name, date, creator, etc
 *
 * @license    GPL 2 (http://www.gnu.org/licenses/gpl.html)
 * @author	   Symon Bent <hendrybadao@gmail.com>
 */
// must be run within Dokuwiki
if(!defined('DOKU_INC')) die();

if (!defined('DOKU_LF')) define('DOKU_LF', "\n");
if (!defined('DOKU_TAB')) define('DOKU_TAB', "\t");
if (!defined('DOKU_PLUGIN')) define('DOKU_PLUGIN',DOKU_INC.'lib/plugins/');

require_once(DOKU_PLUGIN.'syntax.php');
require_once(DOKU_INC.'inc/fulltext.php');

class syntax_plugin_pagequery extends DokuWiki_Syntax_Plugin {
    private $dformat = '';
    private $inwords = false;
    private $nostart = false;

	function getType() {
		return 'substition';
	}

	function getPType() {
		return 'block';
	}

	function getSort() {
		return 98;
	}

	function connectTo($mode) {
		//Default is a word cloud style, looks good when combined with plugin:box
		$this->Lexer->addSpecialPattern('\{\{pagequery>.*?\}\}', $mode, 'plugin_pagequery');
	}
    /**
     * Parses all the pagequery options:
     * Insert the pagequery markup wherever you want your list to appear. E.g:
     *
     *   {{pagequery>}}
     *
     *   {{pagequery>[query];fulltext;sort=key:direction,key2:direction;group;limit=??;cols=?;inwords;proper}}
     *
     * Parameters as follows:
     * 1. query:    any expression directly after the >; can use all Dokuwiki search options (see manual)
     * 2. fulltext: use a full-text search, instead of page_id only [default]
     * 3. sort:     keys to sort by, in order of sorting. Each key can be followed by prefered sorting order
     *              available keys:
     *                  a, ab, abc          by 1st letter, 2 letters, or 3 letters
     *                  name                by page name (no namespace) [not grouped]
     *                  page|id             by full page id, including namespace [not grouped]
     *                  ns                  by namespace (without page name)
     *                  mdate, cdate        by modified|created dates (full) [not grouped]
     *                  m[year][month][day] by modified [year][month][day]; any combination accepted
     *                  c[year][month][day] by created [year][month][day]; any combination accepted
     *                  creator             by page author
     *              date sort default to descending, string sorts to ascending
     * 4. group:    show group headers for each change in sort keys
     *              Note: keys with no duplicated cannot be grouped (i.e. name, page|id, mdate, cdate)
     * 5. limit:    maximum number of results to return
     * 6. inwords:  use real month and day names instead of just numbers
     * 7. cols:     number of columns in displayed list (max = 4)
     * 8. proper:   display page names and namespace in Proper Case (i.e. no _'s and Capitalised)
                    header/hdr = group headers only, name = page name only, both = both!
     * 9. border:   turn on borders
     *10. fullregex:only useful on page name searches; allows a raw regex mode on the full page id
     *11. nostart:  ignore any 'start' pages in namespace
     *
     * All options are optional, and the list will default to a boring long 1-column list...
     */
	function handle($match, $state, $pos, &$handler) {
        global $conf;
        $this->dformat = $conf['dformat'];

		$match = substr($match, 12, -2); // strip markup incl. pagequery>
		$args = explode(';', $match);
        $query = $args[0];
        $fulltext = false;
        $sort = array();
        $group = false;
        $limit = 0; //Default max items displayed. '0' => no limit
        $proper = 'none';
        $cols = 1;
        $border = false;
        $title = false; // use title instead of name
        $abstract = 'tooltip';

        foreach ($args as $arg) {
            list($key, $value) = explode('=', $arg);
            switch ($key) {
                case 'fulltext':
                    $fulltext = true;
                    break;
                case 'sort':
                    $values = explode(',', $value);
                    foreach ($values as $value) {
                        list($key, $dir) = explode(':', $value);
                        $sort[] = array($key, $dir);
                    }
                    break;
                case 'group':
                    $group = true;
                    break;
                case 'limit':
                    $limit = $value;
                    break;
                case 'inwords':
                    $inwords = true;
                    break;
                case 'proper':
                    switch ($value) {
                        case 'hdr':
                        case 'header':
                        case 'group':
                            $proper = 'header';
                            break;
                        case 'name':
                        case 'page':
                            $proper = 'name';
                            break;
                        default:
                            $proper = 'both';
                    }
                    break;
                case 'cols':
                    $cols = ($value > 6) ? 6 : $value;
                    break;
                case 'border':
                    $border = true;
                    break;
				case 'fullregex':
					$fullregex = true;
					break;
                case 'nostart':
                    $nostart = true;
                    break;
                case 'title':
                    $title = true;
                    break;
                case 'abstract':
                    switch ($value) {
                        case '':
                        case 'tooltip':
                            $abstract = 'tooltip';
                            break;
                        default:
                            if ($value >= 0) {
                                $abstract = $value;
                            }
                }
            }
        }
		return array($query, $fulltext, $sort, $group, $limit, $proper,
                      $cols, $inwords, $border, $fullregex, $nostart, $title, $abstract);
	}

    function render($mode, &$renderer, $data) {
        $sortkeys = array();
        list($query, $fulltext, $sort, $group, $limit, $proper,
              $cols, $inwords, $border, $fullregex, $nostart, $title, $abstract) = $data;
        $this->inwords = $inwords;
        $this->nostart = $nostart;

        if ($mode == 'xhtml') {
            // first get a raw list of matching results
            if ($fulltext) {
                $results = array_keys(ft_pageSearch($query, $highlight));
            } else {
                // allow for raw regex mode, for power users, this searches the full page id
                if ($fullregex) {
                    $full_query = $query;
                    $pageonly = false;
                } else {
                    list($full_query, $pageonly) = $this->_parse_ns_query($query);
                }
                $results = $this->_pageLookup($full_query, $pageonly);
            }
            // basic result page markup (always needed)
            $border_css = ($border === false) ? ' style="border-style:none;"' : '';
            $renderer->doc .= '<div id="pagequery">' . DOKU_LF;
            $renderer->doc .= '<table><tbody><tr>' . DOKU_LF;

            // display a "no results" message if empty
            if (empty($results)) {
                $renderer->doc .= '<td><p>' . $this->getLang("no_results") .
                                  '"<strong>' . $query . '</strong>"</p></td>';
            } else {
                // prepare the necessary sorting arrays, as per options
                list($sort_opts, $dates) = $this->_get_sort_opts($results, $sort, $title);
                // now do the sorting
                $this->_sort_results($results, $sort_opts, $dates);
                // limit the result list length if required
                // remember: this can only be done after sorting!
                $results = ($limit > 0) ? array_slice($results, 0, $limit) : $results;
                // and finally the grouping
                if ($group) {
                    $results = $this->_group_results($results, $sort_opts, $dates);
                }
                $was_heading = false;
                $idx = 0;
                $col = 0;
                $rows = ceil(count($results) / $cols);  // proposed column row size
                $width = floor(100 / $cols);
                // remove indenting if not grouped
                $indent_css = ($group === false) ? ' class="nogroup"' : '';
                $link_count = 0;    // needed by the abstract snippet section

                foreach ($results as $id) {
                    // are we ready to start a new column? (up to max allowed)
                    if ($col < $cols && $idx % $rows == 0) {
                        $ready_for_col = true;
                        $col++;
                    }
                    $is_heading = ($id[1] == '|');
                    if ($is_heading) {
                        list($hl, $heading) = explode('|', $id);
                        if ($proper == 'header' || $proper == 'both') $heading = $this->_proper($heading);
                    }

                    // Begin new column if: we are at the start, at a heading or if there is no grouping
                    if ($ready_for_col && !$was_heading) {
                        // close the previous column if necessary
                        $cont_close = (!$is_heading) ? '<strong> ... </strong>' : '';
                        $cont_open = ($idx > 0 && !$is_heading) ? "<h$hl>$heading ...</h$hl>" : '';
                        $close = ($idx > 0) ? $cont_close . '</ul></td>' . DOKU_LF : '';
                        $renderer->doc .= $close . '<td' . $border_css . ' valign="top" width="' . $width . '%">' . $cont_open . DOKU_LF;
                        $ready_for_col = false;
                        $was_heading = true;    //needed to begin a new page id list
                    }
                    if ($is_heading) {
                        // close previous sub list if necessary
                        if (!$was_heading) $renderer->doc .= '</ul>' . DOKU_LF;
                        $renderer->doc .= "<h$hl>$heading</h$hl>" . DOKU_LF;
                        $was_heading = true;
                    } else {
                        // open a new sub list if necessary
                        if ($was_heading || $idx == 0) $renderer->doc .= '<ul' . $indent_css . '>';

                        // deal with normal page links
                        $link = $this->_render_wikilink($id, $proper, $title, $abstract, $link_count);
                        $link_count++;
                        $renderer->doc .= $link;
                        $was_heading = false;
                    }
                    $idx++;
                }
                $renderer->doc .= '</ul></td>';
            }
            $renderer->doc .= '</tr>' . DOKU_LF;
            $renderer->doc .= '</tbody></table>';
            $renderer->doc .= '</div>' . DOKU_LF;
        } else {
            return false;
        }
    }
    /**
     * Renders the page link, plus tooltip, abstract, casing, etc...
     * @param string $id
     * @param bool  $proper
     * @param bool  $title
     * @param mixed $abstract
     */
    private function _render_wikilink($id, $proper, $title, $abstract, $link_count) {

        $id = (strpos($id, ':') === false) ? ':' . $id : $id;   // : needed for root pages

        // does the user want to see the "title" instead "pagename"
        if ($title) {
            $value = p_get_metadata($id, 'title', true);
            $name = (empty($value)) ? $this->_proper(noNS($id)) : $value;
        } elseif ($proper == 'name' || $proper == 'both') {
            $name = $this->_proper(noNS($id));
        } else {
            $name = '';
        }

        // show the "abstract" as a tooltip
        // -or- as a nice quoted snippet ( la blockquote plugin)
        $detail = '';
        if ($abstract == 'none') {
            $link = html_wikilink($id, $name);
        } elseif ($abstract == 'tooltip' || ($abstract > 0 && $link_count >= $abstract)) {
            $link = $this->_html_wikilink_tooltip($id, $name);
        } elseif ($abstract == 'all' || $abstract == 0 || ($abstract > 0 && $link_count < $abstract)) {
            $link = html_wikilink($id, $name);
            $detail = str_replace("\n\n", '<br/>', $this->_abstract($id));
            $more = html_wikilink($id, 'more...');
            $detail = '<blockquote>' . $detail . $more . '</blockquote>' . DOKU_LF;
        }
        return '<li>' . $link . '</li>' . DOKU_LF . $detail;
    }

    private function _proper($id) {
         $id = str_replace(':', ': ', $id);
         $id = str_replace('_', ' ', $id);
         $id = ucwords($id);
         $id = str_replace(': ', ':', $id);
         return $id;
    }
    /**
     * swap normal link title (popup) for a more useful preview
     *
     * @param string $id    page id
     * @param string $name  display name
     * @return complete href link
     */
    private function _html_wikilink_tooltip($id, $name) {
        $link = html_wikilink($id, $name);
        $tooltip = $this->_abstract($id);
        $tooltip = str_replace("\n", '  ', $tooltip);
        $link = preg_replace('/title=\".+?\"/', 'title="' . $tooltip . '"', $link, 1);
        return $link;
    }

    private function _abstract($id) {
        $abstract = p_get_metadata($id, 'description abstract', true);
        $abstract = htmlspecialchars($abstract, ENT_QUOTES, 'UTF-8');
        return $abstract;
    }

    /**
     * Parse out the namespace, and convert to a regex for array search
     * -or- ensure that normal search are only within pagename not its namespace
     *
     * @param string $query user page query
     * @return processed query with regex markup as needed for namespace recognition
     */
    private function _parse_ns_query($query) {
        $incl_ns = preg_match('`(@|ns:)(\w+(\:\w+)*)(\s.+)*`', $query, $matches);
        if ($incl_ns > 0) {
            $ns = $matches[2];
            $page = trim($matches[4]);
            if ($page == '*') $page = '.*';
            $ns_query = $ns . ":.*" . $page;
            return array($ns_query, false);
        }
        $excl_ns = preg_match('`(\^|-ns:)(\w+(\:\w+)*)(\s.+)*`', $query, $matches);
        if ($excl_ns > 0) {
            $ns = $matches[2];
            $page = trim($matches[4]);
            if ($page == '*') $page = '.*';
            $ns_query = '^(?!' . $ns . '):.*' . $page;
            return array($ns_query, false);
        }
		if ($query == '*') $query= '.*';
        return array($query, true);	// true => turns on pageonly lookup
    }

    /**
     * Builds a separate sorting array for each sortby key
     *
     * @param string    $id         wiki page id
     * @param array     $sortby     keys to use for sorting
     * @param arrayref  $sortkeys   ref to sorting arrays
     * @return void
     */
    private function _get_sort_opts($ids, $sortkeys, $title) {
        global $conf;
        $sort_opts = array();
        $dformat = array();
        $dates = array();

        $cnt = 0;
        foreach ($ids as $id) {
            $meta = p_get_metadata ($id, false, true);
            if (!isset($meta['date']['modified'])) {
                $meta['date']['modified'] = $meta['date']['created'];
            }
            if ($title && !isset($meta['title'])) {
                $meta['title'] = $this->_proper(noNS($id));
            }
            $idx = 0;
            foreach ($sortkeys as $sortkey) {
                $key = $sortkey[0];
                switch ($key) {
                    case 'a':
                        $value = $this->_first(noNS($id), 1);
                        break;
                    case 'ab':
                        $value = $this->_first(noNS($id), 2);
                        break;
                    case 'abc':
                        $value = $this->_first(noNS($id), 3);
                        break;
                    case 'name':
                        $value = ($title) ? $meta['title'] : noNS($id);
                        break;
                    case 'id':
                    case 'page':
                        $value = $id;
                        break;
                    case 'ns':
                        $value = getNS($id);
                        if (empty($value)) $value = '(' . $conf['start'] . ')';
                        break;
                    case 'creator':
                        $value = $meta['creator'];
                        break;
                    case 'mdate':
                        $value = $meta['date']['modified'];
                        break;
                    case 'cdate':
                        $value = $meta['date']['created'];
                        break;
                    default:
                        $dtype = $key[0];
                        if ($dtype == 'c' || $dtype == 'm') {
                            // only set date once per id (not per sort column--date remains same across columns)
                            if ( ! isset($dates[$cnt])) {
                                if ($dtype == 'c') {
                                    $date = $meta['date']['created'];
                                } else {
                                    $date = $meta['date']['modified'];
                                }
                                $dates[$cnt] = $date;
                            } else {
                                $date = $dates[$cnt];
                            }
                            // the date formats are cached on first use; allows one of each key type per set
                            if ( ! isset($dformat[$key])) {
                                $dformat[$key] = $this->_date_format($key, $this->inwords);
                                $sort_opts[$idx]['inwords'] = $dformat[$key][1];
                            }
                            $value = strftime($dformat[$key][0], $date);
                        }
                }
                $sort_opts[$idx]['keys'][] = $value;
                $idx++;
            }
            $cnt++;
        }
        $idx = 0;
        foreach ($sortkeys as $sortkey) {
            list($key, $dir) = $sortkey;
            // now the sort direction
            switch ($dir) {
                case 'a':
                case 'asc':
                    $dir = SORT_ASC;
                    break;
                case 'd':
                case 'desc':
                    $dir = SORT_DESC;
                    break;
                default:
                    // sort descending by default; text ascending
                    // watch for other options beginning with c or m ....!
                    if ($key[0] == 'c' || $key[0] == 'm') {
                        $dir = SORT_DESC;
                    } else {
                        $dir = SORT_ASC;
                    }
            }
            $sort_opts[$idx]['dir'] = $dir;
            // and finally set the sort array's data type (for correct markup purposes)
            switch ($key) {
                // full-text and full dates cannot meaningfully be grouped (no duplicates!)
                case 'mdate':
                case 'cdate':
                case 'name':
                case 'id':
                case 'page':
                    $group = false;
                    break;
                case 'ns':
                    $group = 'ns';
                    break;
                default:
                    $group = true;
            }
            $sort_opts[$idx]['group'] = $group;
            // and now the sort data type
            $is_ns = false;
            switch ($key) {
                case 'mdate':
                case 'cdate':
                    $type = SORT_NUMERIC;
                    break;
                default:
                    $type = SORT_STRING;
            }
            $sort_opts[$idx]['type'] = $type;
            $idx++;
        }
        return array($sort_opts, $dates);
    }

    // returns first $count letters from $text
    private function _first($text, $count) {
        if ($count > 0) {
            return mb_substr($text, 0, $count);
        }
    }

    // parse the c|m-year-month-day option
    private function _date_format($key, $inwords = false) {
        if (strpos($key, 'year') !== false) $dkey[] = '%Y';
        if (strpos($key, 'month') !== false) $dkey[] = '%m';
        if (strpos($key, 'day') !== false) $dkey[] = '%d';
        $dformat = implode('-', $dkey);
        // provide month and day format in real words if required
        // used for display only; $dformat is used for correct sorting!
        $wformat = '';
        if ($inwords) {
            switch ($dformat) {
                case '%m':
                    $wformat = "%B";
                    break;
                case '%d':
                    $wformat = "%#d, %A ";
                    break;
                case '%Y-%m':
                    $wformat = "%B %Y";
                    break;
                case '%m-%d':
                    $wformat= "%B %#d, %A ";
                    break;
                case '%Y-%m-%d':
                    $wformat = "%A, %B %#d, %Y";
                    break;
            }
        }
        return array($dformat, $wformat);
    }

    // sort by each sorting array, in order
    private function _sort_results(&$ids, &$sort_opts, &$dates) {
        if ( ! empty($sort_opts)) {
            $args = array();
            foreach ($sort_opts as &$sort_opt) {
                $args[] = &$sort_opt['keys'];
                $args[] = &$sort_opt['dir'];
                $args[] = &$sort_opt['type'];
            }
            if ( ! empty($dates)) $args[] = &$dates;
            $args[] = &$ids;
            call_user_func_array('array_multisort', $args);
        }
    }

    private function _group_results(&$ids, &$sort_opts, &$dates) {
        $prevs = array();
        $results = array();
        $level = count($sort_opts) - 1;
        $idx = 0;
        foreach($ids as $id) {
            $this->_add_heading($results, $sort_opts, $dates, $level, $idx, $prevs);
            $results[] = $id;
            $idx++;
        }
        return $results;
    }

    private function _add_heading(&$results, &$sort_opts, &$dates, $level, $idx, &$prevs) {
        if ($level > 0) {
            // recurse to find all parent headings
            $this->_add_heading($results, $sort_opts, $dates, $level - 1, $idx, $prevs);
        }
        $group = $sort_opts[$level]['group'];
        // only if this sort array can be grouped....
        if ($group === true) {
            $prev = (isset($prevs[$level])) ? $prevs[$level] : '';
            $cur = $sort_opts[$level]['keys'][$idx];
            if ($cur != $prev) {
                $prevs[$level] = $cur;
                $hl = ($level + 1);
                $inwords = $sort_opts[$level]['inwords'];
                if ($this->inwords && ! empty($inwords)) $cur = strftime($inwords, $dates[$idx]);
                $results[] = $hl . '|' . $cur;
            }
        } elseif ($group == 'ns') {
            $prev = (isset($prevs[$level])) ? $prevs[$level] : '';
            $cur = $sort_opts[$level]['keys'][$idx];
            if ($cur != $prev) {
                $prevs[$level] = $cur;
                $cur_ns = explode(':', $cur);
                $prev_ns = explode(':', $prev);
                // we only show namespaces that are different from the previous heading
                for ($i= 0; $i < count($cur_ns); $i++) {
                    if ($cur_ns[$i] != $prev_ns[$i]) {
                        $hl = $level + $i + 1;
                        $hl = ($hl > 6) ? 6 : $hl;
                        $results[] = $hl . '|' . $cur_ns[$i];
                    }
                }
            }
        }
    }


    /**
     * heavily customised version of _ft_pageLookup in inc/fulltext.php
     * I just removed the preg_quote line to enable regexes in search query...
     * and the unnecessary usort line as I have my own sort routines
     *
     */
    private function _pageLookup($query, $pageonly) {
        global $conf;

        $query = trim($query);
        $pages = file($conf['indexdir'].'/page.idx');
        $pages = array_values(preg_grep('/'.$query.'/', $pages));

        $cnt = count($pages);
        for($i = 0; $i < $cnt; $i++){
            if($pageonly){
                if(!preg_match('/'.$query.'/',noNS($pages[$i]))){
                    unset($pages[$i]);
                    continue;
                }
            }
            if(!page_exists($pages[$i])){
                unset($pages[$i]);
                continue;
            }
        }

        $pages = array_filter($pages, 'isVisiblePage'); // discard hidden pages
        if(!count($pages)) return array();

        $pages = array_map('trim',$pages);

        // check ACL permissions and remove any 'start' pages if req'd
        $start = $conf['start'];
        $pos = strlen($start);
        foreach($pages as $idx => $name) {
            if ($this->nostart && substr($name, -$pos) == $start) {
                unset($pages[$idx]);
            } elseif(auth_quickaclcheck(trim($pages[$idx])) < AUTH_READ){
                unset($pages[$idx]);
            }
        }
        return $pages;
    }
}

blob
mark :36
data 26310
<?php
/**
 * PageQuery Plugin: search for and list pages, sorted by name, date, creator, etc
 *
 * @license    GPL 2 (http://www.gnu.org/licenses/gpl.html)
 * @author	   Symon Bent <hendrybadao@gmail.com>
 */
// must be run within Dokuwiki
if(!defined('DOKU_INC')) die();

if (!defined('DOKU_LF')) define('DOKU_LF', "\n");
if (!defined('DOKU_TAB')) define('DOKU_TAB', "\t");
if (!defined('DOKU_PLUGIN')) define('DOKU_PLUGIN',DOKU_INC.'lib/plugins/');

require_once(DOKU_PLUGIN.'syntax.php');
require_once(DOKU_INC.'inc/fulltext.php');

class syntax_plugin_pagequery extends DokuWiki_Syntax_Plugin {
    private $dformat = '';
    private $inwords = false;
    private $nostart = false;
    private $maxns = 0;

	function getType() {
		return 'substition';
	}

	function getPType() {
		return 'block';
	}

	function getSort() {
		return 98;
	}

	function connectTo($mode) {
		//Default is a word cloud style, looks good when combined with plugin:box
		$this->Lexer->addSpecialPattern('\{\{pagequery>.*?\}\}', $mode, 'plugin_pagequery');
	}
    /**
     * Parses all the pagequery options:
     * Insert the pagequery markup wherever you want your list to appear. E.g:
     *
     *   {{pagequery>}}
     *
     *   {{pagequery>[query];fulltext;sort=key:direction,key2:direction;group;limit=??;cols=?;inwords;proper}}
     *
     * Parameters as follows:
     * 1. query:    any expression directly after the >; can use all Dokuwiki search options (see manual)
     * 2. fulltext: use a full-text search, instead of page_id only [default]
     * 3. sort:     keys to sort by, in order of sorting. Each key can be followed by prefered sorting order
     *              available keys:
     *                  a, ab, abc          by 1st letter, 2 letters, or 3 letters
     *                  name                by page name (no namespace) [not grouped]
     *                  page|id             by full page id, including namespace [not grouped]
     *                  ns                  by namespace (without page name)
     *                  mdate, cdate        by modified|created dates (full) [not grouped]
     *                  m[year][month][day] by modified [year][month][day]; any combination accepted
     *                  c[year][month][day] by created [year][month][day]; any combination accepted
     *                  creator             by page author
     *              date sort default to descending, string sorts to ascending
     * 4. group:    show group headers for each change in sort keys
     *              Note: keys with no duplicated cannot be grouped (i.e. name, page|id, mdate, cdate)
     * 5. limit:    maximum number of results to return
     * 6. inwords:  use real month and day names instead of just numbers
     * 7. cols:     number of columns in displayed list (max = 4)
     * 8. proper:   display page names and namespace in Proper Case (i.e. no _'s and Capitalised)
                    header/hdr = group headers only, name = page name only, both = both!
     * 9. border:   turn on borders
     *10. fullregex:only useful on page name searches; allows a raw regex mode on the full page id
     *11. nostart:  ignore any 'start' pages in namespace (based on "config:start")
     *12. maxns:    maximum namespace level to be displayed; e.g. maxns=3 => one:two:three
     *13. title:    show 1st page heading instead of page name
     *14. abstract: should an excerpt of the wikipage:
     *              use :tooltip to show as a pop-up only
     *              use :<number> to show 1st n items in list with an abstract
     *
     * All options are optional, and the list will default to a boring long 1-column list...
     */
	function handle($match, $state, $pos, &$handler) {
        global $conf;
        $this->dformat = $conf['dformat'];

		$match = substr($match, 12, -2); // strip markup incl. pagequery>
		$args = explode(';', $match);
        $query = $args[0];
        $fulltext = false;
        $sort = array();
        $group = false;
        $limit = 0;  //Default max items displayed. '0' => no limit
        $maxns = 0;  // Maximum no. of namespace levels to display
        $proper = 'none';
        $cols = 1;
        $border = false;
        $title = false; // use title instead of name
        $abstract = 'tooltip';

        foreach ($args as $arg) {
            list($key, $value) = explode('=', $arg);
            switch ($key) {
                case 'fulltext':
                    $fulltext = true;
                    break;
                case 'sort':
                    $values = explode(',', $value);
                    foreach ($values as $value) {
                        list($key, $dir) = explode(':', $value);
                        $sort[] = array($key, $dir);
                    }
                    break;
                case 'group':
                    $group = true;
                    break;
                case 'limit':
                    $limit = $value;
                    break;
                case 'maxns':
                    $maxns = $value;
                    break;
                case 'inwords':
                    $inwords = true;
                    break;
                case 'proper':
                    switch ($value) {
                        case 'hdr':
                        case 'header':
                        case 'group':
                            $proper = 'header';
                            break;
                        case 'name':
                        case 'page':
                            $proper = 'name';
                            break;
                        default:
                            $proper = 'both';
                    }
                    break;
                case 'cols':
                    $cols = ($value > 6) ? 6 : $value;
                    break;
                case 'border':
                    $border = true;
                    break;
				case 'fullregex':
					$fullregex = true;
					break;
                case 'nostart':
                    $nostart = true;
                    break;
                case 'title':
                    $title = true;
                    break;
                case 'abstract':
                    switch ($value) {
                        case '':
                        case 'tooltip':
                            $abstract = 'tooltip';
                            break;
                        default:
                            if ($value >= 0) {
                                $abstract = $value;
                            }
                }
            }
        }
		return array($query, $fulltext, $sort, $group, $limit, $maxns, $proper,
                      $cols, $inwords, $border, $fullregex, $nostart, $title, $abstract);
	}

    function render($mode, &$renderer, $data) {
        $sortkeys = array();
        list($query, $fulltext, $sort, $group, $limit, $maxns, $proper,
              $cols, $inwords, $border, $fullregex, $nostart, $title, $abstract) = $data;
        $this->inwords = $inwords;
        $this->nostart = $nostart;
        $this->maxns = $maxns;

        if ($mode == 'xhtml') {
            // first get a raw list of matching results
            if ($fulltext) {
                $results = array_keys(ft_pageSearch($query, $highlight));
            } else {
                // allow for raw regex mode, for power users, this searches the full page id
                if ($fullregex) {
                    $full_query = $query;
                    $pageonly = false;
                } else {
                    list($full_query, $pageonly) = $this->_parse_ns_query($query);
                }
                $results = $this->_pageLookup($full_query, $pageonly);
            }
            // basic result page markup (always needed)
            $border_css = ($border === false) ? ' style="border-style:none;"' : '';
            $renderer->doc .= '<div id="pagequery">' . DOKU_LF;
            $renderer->doc .= '<table><tbody><tr>' . DOKU_LF;

            // display a "no results" message if empty
            if (empty($results)) {
                $renderer->doc .= '<td><p>' . $this->getLang("no_results") .
                                  '"<strong>' . $query . '</strong>"</p></td>';
            } else {
                // prepare the necessary sorting arrays, as per options
                list($sort_opts, $dates) = $this->_get_sort_opts($results, $sort, $title);
                // now do the sorting
                $this->_sort_results($results, $sort_opts, $dates);
                // limit the result list length if required
                // remember: this can only be done after sorting!
                $results = ($limit > 0) ? array_slice($results, 0, $limit) : $results;
                // and finally the grouping
                if ($group) {
                    $results = $this->_group_results($results, $sort_opts, $dates);
                }
                $was_heading = false;
                $idx = 0;
                $col = 0;
                $rows = ceil(count($results) / $cols);  // proposed column row size
                $width = floor(100 / $cols);
                // remove indenting if not grouped
                $indent_css = ($group === false) ? ' class="nogroup"' : '';
                $link_count = 0;    // needed by the abstract snippet section

                foreach ($results as $id) {
                    // are we ready to start a new column? (up to max allowed)
                    if ($col < $cols && $idx % $rows == 0) {
                        $ready_for_col = true;
                        $col++;
                    }
                    $is_heading = ($id[1] == '|');
                    if ($is_heading) {
                        list($hl, $heading) = explode('|', $id);
                        if ($proper == 'header' || $proper == 'both') $heading = $this->_proper($heading);
                    }

                    // Begin new column if: we are at the start, at a heading or if there is no grouping
                    if ($ready_for_col && !$was_heading) {
                        // close the previous column if necessary
                        $cont_close = (!$is_heading) ? '<strong> ... </strong>' : '';
                        $cont_open = ($idx > 0 && !$is_heading) ? "<h$hl>$heading ...</h$hl>" : '';
                        $close = ($idx > 0) ? $cont_close . '</ul></td>' . DOKU_LF : '';
                        $renderer->doc .= $close . '<td' . $border_css . ' valign="top" width="' . $width . '%">' . $cont_open . DOKU_LF;
                        $ready_for_col = false;
                        $was_heading = true;    //needed to begin a new page id list
                    }
                    if ($is_heading) {
                        // close previous sub list if necessary
                        if (!$was_heading) $renderer->doc .= '</ul>' . DOKU_LF;
                        $renderer->doc .= "<h$hl>$heading</h$hl>" . DOKU_LF;
                        $was_heading = true;
                    } else {
                        // open a new sub list if necessary
                        if ($was_heading || $idx == 0) $renderer->doc .= '<ul' . $indent_css . '>';

                        // deal with normal page links
                        $link = $this->_render_wikilink($id, $proper, $title, $abstract, $link_count);
                        $link_count++;
                        $renderer->doc .= $link;
                        $was_heading = false;
                    }
                    $idx++;
                }
                $renderer->doc .= '</ul></td>';
            }
            $renderer->doc .= '</tr>' . DOKU_LF;
            $renderer->doc .= '</tbody></table>';
            $renderer->doc .= '</div>' . DOKU_LF;
        } else {
            return false;
        }
    }
    /**
     * Renders the page link, plus tooltip, abstract, casing, etc...
     * @param string $id
     * @param bool  $proper
     * @param bool  $title
     * @param mixed $abstract
     */
    private function _render_wikilink($id, $proper, $title, $abstract, $link_count) {

        $id = (strpos($id, ':') === false) ? ':' . $id : $id;   // : needed for root pages

        // does the user want to see the "title" instead "pagename"
        if ($title) {
            $value = p_get_metadata($id, 'title', true);
            $name = (empty($value)) ? $this->_proper(noNS($id)) : $value;
        } elseif ($proper == 'name' || $proper == 'both') {
            $name = $this->_proper(noNS($id));
        } else {
            $name = '';
        }

        // show the "abstract" as a tooltip
        // -or- as a nice quoted snippet ( la blockquote plugin)
        $detail = '';
        if ($abstract == 'none') {
            $link = html_wikilink($id, $name);
        } elseif ($abstract == 'tooltip' || ($abstract > 0 && $link_count >= $abstract)) {
            $link = $this->_html_wikilink_tooltip($id, $name);
        } elseif ($abstract == 'all' || $abstract == 0 || ($abstract > 0 && $link_count < $abstract)) {
            $link = html_wikilink($id, $name);
            $detail = str_replace("\n\n", '<br/>', $this->_abstract($id));
            $more = html_wikilink($id, 'more...');
            $detail = '<blockquote>' . $detail . $more . '</blockquote>' . DOKU_LF;
        }
        return '<li>' . $link . '</li>' . DOKU_LF . $detail;
    }

    private function _proper($id) {
         $id = str_replace(':', ': ', $id);
         $id = str_replace('_', ' ', $id);
         $id = ucwords($id);
         $id = str_replace(': ', ':', $id);
         return $id;
    }
    /**
     * swap normal link title (popup) for a more useful preview
     *
     * @param string $id    page id
     * @param string $name  display name
     * @return complete href link
     */
    private function _html_wikilink_tooltip($id, $name) {
        $link = html_wikilink($id, $name);
        $tooltip = $this->_abstract($id);
        $tooltip = str_replace("\n", '  ', $tooltip);
        $link = preg_replace('/title=\".+?\"/', 'title="' . $tooltip . '"', $link, 1);
        return $link;
    }

    private function _abstract($id) {
        $abstract = p_get_metadata($id, 'description abstract', true);
        $abstract = htmlspecialchars($abstract, ENT_QUOTES, 'UTF-8');
        return $abstract;
    }

    /**
     * Parse out the namespace, and convert to a regex for array search
     * -or- ensure that normal search are only within pagename not its namespace
     *
     * @param string $query user page query
     * @return processed query with regex markup as needed for namespace recognition
     */
    private function _parse_ns_query($query) {
        $incl_ns = preg_match('`(@|ns:)(\w+(\:\w+)*)(\s.+)*`', $query, $matches);
        if ($incl_ns > 0) {
            $ns = $matches[2];
            $page = trim($matches[4]);
            if ($page == '*') $page = '.*';
            $ns_query = $ns . ":.*" . $page;
            return array($ns_query, false);
        }
        $excl_ns = preg_match('`(\^|-ns:)(\w+(\:\w+)*)(\s.+)*`', $query, $matches);
        if ($excl_ns > 0) {
            $ns = $matches[2];
            $page = trim($matches[4]);
            if ($page == '*') $page = '.*';
            $ns_query = '^(?!' . $ns . '):.*' . $page;
            return array($ns_query, false);
        }
		if ($query == '*') $query= '.*';
        return array($query, true);	// true => turns on pageonly lookup
    }

    /**
     * Builds a separate sorting array for each sortby key
     *
     * @param string    $id         wiki page id
     * @param array     $sortby     keys to use for sorting
     * @param arrayref  $sortkeys   ref to sorting arrays
     * @return void
     */
    private function _get_sort_opts($ids, $sortkeys, $title) {
        global $conf;
        $sort_opts = array();
        $dformat = array();
        $dates = array();

        $cnt = 0;
        foreach ($ids as $id) {
            $meta = p_get_metadata ($id, false, true);
            if (!isset($meta['date']['modified'])) {
                $meta['date']['modified'] = $meta['date']['created'];
            }
            if ($title && !isset($meta['title'])) {
                $meta['title'] = $this->_proper(noNS($id));
            }
            $idx = 0;
            foreach ($sortkeys as $sortkey) {
                $key = $sortkey[0];
                switch ($key) {
                    case 'a':
                        $value = $this->_first(noNS($id), 1);
                        break;
                    case 'ab':
                        $value = $this->_first(noNS($id), 2);
                        break;
                    case 'abc':
                        $value = $this->_first(noNS($id), 3);
                        break;
                    case 'name':
                        $value = ($title) ? $meta['title'] : noNS($id);
                        break;
                    case 'id':
                    case 'page':
                        $value = $id;
                        break;
                    case 'ns':
                        $value = getNS($id);
                        if (empty($value)) $value = '[' . $conf['start'] . ']';
                        break;
                    case 'creator':
                        $value = $meta['creator'];
                        break;
                    case 'mdate':
                        $value = $meta['date']['modified'];
                        break;
                    case 'cdate':
                        $value = $meta['date']['created'];
                        break;
                    default:
                        $dtype = $key[0];
                        if ($dtype == 'c' || $dtype == 'm') {
                            // only set date once per id (not per sort column--date remains same across columns)
                            if ( ! isset($dates[$cnt])) {
                                if ($dtype == 'c') {
                                    $date = $meta['date']['created'];
                                } else {
                                    $date = $meta['date']['modified'];
                                }
                                $dates[$cnt] = $date;
                            } else {
                                $date = $dates[$cnt];
                            }
                            // the date formats are cached on first use; allows one of each key type per set
                            if ( ! isset($dformat[$key])) {
                                $dformat[$key] = $this->_date_format($key, $this->inwords);
                                $sort_opts[$idx]['inwords'] = $dformat[$key][1];
                            }
                            $value = strftime($dformat[$key][0], $date);
                        }
                }
                $sort_opts[$idx]['keys'][] = $value;
                $idx++;
            }
            $cnt++;
        }
        $idx = 0;
        foreach ($sortkeys as $sortkey) {
            list($key, $opt) = $sortkey;
            // now the sort direction
            switch ($opt) {
                case 'a':
                case 'asc':
                    $dir = SORT_ASC;
                    break;
                case 'd':
                case 'desc':
                    $dir = SORT_DESC;
                    break;
                default:
                    // sort descending by default; text ascending
                    // watch for other options beginning with c or m ....!
                    if ($key[0] == 'c' || $key[0] == 'm') {
                        $dir = SORT_DESC;
                    } else {
                        $dir = SORT_ASC;
                    }
            }
            $sort_opts[$idx]['dir'] = $dir;

            // establish grouping type
            switch ($key) {
                // full-text and full dates cannot meaningfully be grouped (no duplicates!)
                case 'mdate':
                case 'cdate':
                case 'name':
                case 'id':
                case 'page':
                    $group = false;
                    break;
                case 'ns':
                    $group = 'ns';
                    break;
                default:
                    $group = true;
            }
            $sort_opts[$idx]['group'] = $group;

            // and finally set the sort array's data type (for correct markup purposes)
            $is_ns = false;
            switch ($key) {
                case 'mdate':
                case 'cdate':
                    $type = SORT_NUMERIC;
                    break;
                default:
                    $type = SORT_STRING;
            }
            $sort_opts[$idx]['type'] = $type;
            $idx++;
        }
        return array($sort_opts, $dates);
    }

    // returns first $count letters from $text
    private function _first($text, $count) {
        if ($count > 0) {
            return mb_substr($text, 0, $count);
        }
    }

    // parse the c|m-year-month-day option
    private function _date_format($key, $inwords = false) {
        if (strpos($key, 'year') !== false) $dkey[] = '%Y';
        if (strpos($key, 'month') !== false) $dkey[] = '%m';
        if (strpos($key, 'day') !== false) $dkey[] = '%d';
        $dformat = implode('-', $dkey);
        // provide month and day format in real words if required
        // used for display only; $dformat is used for correct sorting!
        $wformat = '';
        if ($inwords) {
            switch ($dformat) {
                case '%m':
                    $wformat = "%B";
                    break;
                case '%d':
                    $wformat = "%#d, %A ";
                    break;
                case '%Y-%m':
                    $wformat = "%B %Y";
                    break;
                case '%m-%d':
                    $wformat= "%B %#d, %A ";
                    break;
                case '%Y-%m-%d':
                    $wformat = "%A, %B %#d, %Y";
                    break;
            }
        }
        return array($dformat, $wformat);
    }

    // sort by each sorting array, in order
    private function _sort_results(&$ids, &$sort_opts, &$dates) {
        if ( ! empty($sort_opts)) {
            $args = array();
            foreach ($sort_opts as &$sort_opt) {
                $args[] = &$sort_opt['keys'];
                $args[] = &$sort_opt['dir'];
                $args[] = &$sort_opt['type'];
            }
            if ( ! empty($dates)) $args[] = &$dates;
            $args[] = &$ids;
            call_user_func_array('array_multisort', $args);
        }
    }

    private function _group_results(&$ids, &$sort_opts, &$dates) {
        $prevs = array();
        $results = array();
        $level = count($sort_opts) - 1;
        $idx = 0;
        foreach($ids as $id) {
            $this->_add_heading($results, $sort_opts, $dates, $level, $idx, $prevs);
            $results[] = $id;
            $idx++;
        }
        return $results;
    }

    private function _add_heading(&$results, &$sort_opts, &$dates, $level, $idx, &$prevs) {
        if ($level > 0) {
            // recurse to find all parent headings
            $this->_add_heading($results, $sort_opts, $dates, $level - 1, $idx, $prevs);
        }
        $group = $sort_opts[$level]['group'];
        // only if this sort array can be grouped....
        if ($group === true) {
            $prev = (isset($prevs[$level])) ? $prevs[$level] : '';
            $cur = $sort_opts[$level]['keys'][$idx];
            if ($cur != $prev) {
                $prevs[$level] = $cur;
                $hl = ($level + 1);
                $inwords = $sort_opts[$level]['inwords'];
                if ($this->inwords && ! empty($inwords)) $cur = strftime($inwords, $dates[$idx]);
                $results[] = $hl . '|' . $cur;
            }
        } elseif ($group == 'ns') {
            $prev = (isset($prevs[$level])) ? $prevs[$level] : '';
            $cur = $sort_opts[$level]['keys'][$idx];
            if ($cur != $prev) {
                $prevs[$level] = $cur;
                $cur_ns = explode(':', $cur);
                $prev_ns = explode(':', $prev);
                // we only show namespaces that are different from the previous heading
                for ($i= 0; $i < count($cur_ns); $i++) {
                    if ($cur_ns[$i] != $prev_ns[$i]) {
                        $hl = $level + $i + 1;
                        $hl = ($hl > 6) ? 6 : $hl;
                        $results[] = $hl . '|' . $cur_ns[$i];
                    }
                }
            }
        }
    }


    /**
     * heavily customised version of _ft_pageLookup in inc/fulltext.php
     * I just removed the preg_quote line to enable regexes in search query...
     * and the unnecessary usort line as I have my own sort routines
     *
     */
    private function _pageLookup($query, $pageonly) {
        global $conf;

        $query = trim($query);
        $pages = file($conf['indexdir'].'/page.idx');
        $pages = array_values(preg_grep('/'.$query.'/', $pages));

        $cnt = count($pages);
        for($i = 0; $i < $cnt; $i++){
            if($pageonly){
                if(!preg_match('/'.$query.'/',noNS($pages[$i]))){
                    unset($pages[$i]);
                    continue;
                }
            }
            if(!page_exists($pages[$i])){
                unset($pages[$i]);
                continue;
            }
        }

        $pages = array_filter($pages, 'isVisiblePage'); // discard hidden pages
        if(!count($pages)) return array();

        $pages = array_map('trim',$pages);

        // check ACL permissions and remove any 'start' pages if req'd
        $start = $conf['start'];
        $pos = strlen($start);
        foreach($pages as $idx => $name) {
            if ($this->nostart && substr($name, -$pos) == $start) {
                unset($pages[$idx]);
            } elseif(auth_quickaclcheck(trim($pages[$idx])) < AUTH_READ){
                unset($pages[$idx]);
            } elseif ($this->maxns > 0 && (substr_count($name,':') + 1) > $this->maxns) {
                unset($pages[$idx]);    //skip this page
            }
        }
        return $pages;
    }
}

blob
mark :38
data 27118
<?php
/**
 * PageQuery Plugin: search for and list pages, sorted by name, date, creator, etc
 *
 * @license    GPL 2 (http://www.gnu.org/licenses/gpl.html)
 * @author	   Symon Bent <hendrybadao@gmail.com>
 */
// must be run within Dokuwiki
if(!defined('DOKU_INC')) die();

if (!defined('DOKU_LF')) define('DOKU_LF', "\n");
if (!defined('DOKU_TAB')) define('DOKU_TAB', "\t");
if (!defined('DOKU_PLUGIN')) define('DOKU_PLUGIN',DOKU_INC.'lib/plugins/');

require_once(DOKU_PLUGIN.'syntax.php');
require_once(DOKU_INC.'inc/fulltext.php');

class syntax_plugin_pagequery extends DokuWiki_Syntax_Plugin {
    private $dformat = '';
    private $inwords = false;
    private $nostart = false;
    private $maxns = 0;

	function getType() {
		return 'substition';
	}

	function getPType() {
		return 'block';
	}

	function getSort() {
		return 98;
	}

	function connectTo($mode) {
		//Default is a word cloud style, looks good when combined with plugin:box
		$this->Lexer->addSpecialPattern('\{\{pagequery>.*?\}\}', $mode, 'plugin_pagequery');
	}
    /**
     * Parses all the pagequery options:
     * Insert the pagequery markup wherever you want your list to appear. E.g:
     *
     *   {{pagequery>}}
     *
     *   {{pagequery>[query];fulltext;sort=key:direction,key2:direction;group;limit=??;cols=?;inwords;proper}}
     *
     * Parameters as follows:
     * 1. query:    any expression directly after the >; can use all Dokuwiki search options (see manual)
     * 2. fulltext: use a full-text search, instead of page_id only [default]
     * 3. sort:     keys to sort by, in order of sorting. Each key can be followed by prefered sorting order
     *              available keys:
     *                  a, ab, abc          by 1st letter, 2 letters, or 3 letters
     *                  name                by page name (no namespace) [not grouped]
     *                  page|id             by full page id, including namespace [not grouped]
     *                  ns                  by namespace (without page name)
     *                  mdate, cdate        by modified|created dates (full) [not grouped]
     *                  m[year][month][day] by modified [year][month][day]; any combination accepted
     *                  c[year][month][day] by created [year][month][day]; any combination accepted
     *                  creator             by page author
     *              date sort default to descending, string sorts to ascending
     * 4. group:    show group headers for each change in sort keys
     *              Note: keys with no duplicated cannot be grouped (i.e. name, page|id, mdate, cdate)
     * 5. limit:    maximum number of results to return
     * 6. inwords:  use real month and day names instead of just numbers
     * 7. cols:     number of columns in displayed list (max = 4)
     * 8. proper:   display page names and namespace in Proper Case (i.e. no _'s and Capitalised)
                    header/hdr = group headers only, name = page name only, both = both!
     * 9. border:   turn on borders
     *10. fullregex:only useful on page name searches; allows a raw regex mode on the full page id
     *11. nostart:  ignore any 'start' pages in namespace (based on "config:start")
     *12. maxns:    maximum namespace level to be displayed; e.g. maxns=3 => one:two:three
     *13. title:    show 1st page heading instead of page name
     *14. abstract: should an excerpt of the wikipage:
     *              use :tooltip to show as a pop-up only
     *              use :<number> to show 1st n items in list with an abstract
     *
     * All options are optional, and the list will default to a boring long 1-column list...
     */
	function handle($match, $state, $pos, &$handler) {
        global $conf;
        $this->dformat = $conf['dformat'];

		$match = substr($match, 12, -2); // strip markup incl. pagequery>
		$args = explode(';', $match);
        $query = $args[0];
        $fulltext = false;
        $sort = array();
        $group = false;
        $limit = 0;  //Default max items displayed. '0' => no limit
        $maxns = 0;  // Maximum no. of namespace levels to display
        $proper = 'none';
        $cols = 1;
        $border = false;
        $title = false; // use title instead of name
        $abstract = 'tooltip';
        $fullregex = false;

        foreach ($args as $arg) {
            list($key, $value) = explode('=', $arg);
            switch ($key) {
                case 'fulltext':
                    $fulltext = true;
                    break;
                case 'sort':
                    $values = explode(',', $value);
                    foreach ($values as $value) {
                        list($key, $dir) = explode(':', $value);
                        $sort[] = array($key, $dir);
                    }
                    break;
                case 'group':
                    $group = true;
                    break;
                case 'limit':
                    $limit = $value;
                    break;
                case 'maxns':
                    $maxns = $value;
                    break;
                case 'inwords':
                    $inwords = true;
                    break;
                case 'proper':
                    switch ($value) {
                        case 'hdr':
                        case 'header':
                        case 'group':
                            $proper = 'header';
                            break;
                        case 'name':
                        case 'page':
                            $proper = 'name';
                            break;
                        default:
                            $proper = 'both';
                    }
                    break;
                case 'cols':
                    $cols = ($value > 6) ? 6 : $value;
                    break;
                case 'border':
                    $border = true;
                    break;
				case 'fullregex':
					$fullregex = true;
					break;
                case 'nostart':
                    $nostart = true;
                    break;
                case 'title':
                    $title = true;
                    break;
                case 'abstract':
                    switch ($value) {
                        case '':
                        case 'tooltip':
                            $abstract = 'tooltip';
                            break;
                        default:
                            if ($value >= 0) {
                                $abstract = $value;
                            }
                }
            }
        }
		return array($query, $fulltext, $sort, $group, $limit, $maxns, $proper,
                      $cols, $inwords, $border, $fullregex, $nostart, $title, $abstract);
	}

    function render($mode, &$renderer, $data) {
        $sortkeys = array();
        $incl_ns = array();
        $excl_ns = array();

        list($query, $fulltext, $sort, $group, $limit, $maxns, $proper,
              $cols, $inwords, $border, $fullregex, $nostart, $title, $abstract) = $data;
        $this->inwords = $inwords;
        $this->nostart = $nostart;
        $this->maxns = $maxns;

        if ($mode == 'xhtml') {
            // first get a raw list of matching results
            if ($fulltext) {
                $results = array_keys(ft_pageSearch($query, $highlight));
            } else {
                // allow for raw regex mode, for power users, this searches the full page id
                if ($fullregex) {
                    $full_query = $query;
                    $pageonly = false;
                } else {
                    list($full_query, $pageonly, $incl_ns, $excl_ns) = $this->_parse_ns_query($query);
                }
                $results = $this->_pageLookup($full_query, $pageonly, $incl_ns, $excl_ns);
            }

            // basic result page markup (always needed)
            $renderer->doc .= '<div id="pagequery">' . DOKU_LF;
            $renderer->doc .= '<table><tbody><tr>' . DOKU_LF;

            if ( ! empty($results)) {
                // prepare the necessary sorting arrays, as per options
                list($sort_opts, $dates) = $this->_get_sort_opts($results, $sort, $title);
                // now do the sorting
                $this->_sort_results($results, $sort_opts, $dates);
                // limit the result list length if required
                // remember: this can only be done after sorting!
                $results = ($limit > 0) ? array_slice($results, 0, $limit) : $results;
                // and finally the grouping
                if ($group) {
                    $results = $this->_group_results($results, $sort_opts, $dates);
                }

                // now render the actual result list
                $was_heading = false;
                $idx = 0;
                $col = 0;
                $rows = ceil(count($results) / $cols);  // proposed column row size
                $width = floor(100 / $cols);
                $indent_css = ($group === false) ? ' class="nogroup"' : ''; // remove indenting if not grouped
                $border_css = ($border === false) ? ' style="border-style:none;"' : '';
                $max_abstract = 0;    // needed by the abstract snippet section

                foreach ($results as $id) {
                    // are we ready to start a new column? (up to max allowed)
                    if ($col < $cols && $idx % $rows == 0) {
                        $ready_for_col = true;
                        $col++;
                    }
                    $is_heading = ($id[1] == '|');
                    if ($is_heading) {
                        list($hl, $heading) = explode('|', $id);
                        if ($proper == 'header' || $proper == 'both') $heading = $this->_proper($heading);
                    }

                    // Begin new column if: we are at the start, at a heading or if there is no grouping
                    if ($ready_for_col && ! $was_heading) {
                        // close the previous column if necessary
                        $cont_close = (!$is_heading) ? '<strong> ... </strong>' : '';
                        $cont_open = ($idx > 0 && !$is_heading) ? "<h$hl>$heading ...</h$hl>" : '';
                        $close = ($idx > 0) ? $cont_close . '</ul></td>' . DOKU_LF : '';
                        $renderer->doc .= $close . '<td' . $border_css . ' valign="top" width="' . $width . '%">' . $cont_open . DOKU_LF;
                        $ready_for_col = false;
                        $was_heading = true;    //needed to begin a new page id list
                    }
                    if ($is_heading) {
                        // close previous sub list if necessary
                        if (!$was_heading) $renderer->doc .= '</ul>' . DOKU_LF;
                        $renderer->doc .= "<h$hl>$heading</h$hl>" . DOKU_LF;
                        $was_heading = true;
                    } else {
                        // open a new sub list if necessary
                        if ($was_heading || $idx == 0) $renderer->doc .= '<ul' . $indent_css . '>';

                        // deal with normal page links
                        $link = $this->_render_wikilink($id, $proper, $title, $abstract, $max_abstract);
                        $max_abstract++;
                        $renderer->doc .= $link;
                        $was_heading = false;
                    }
                    $idx++;
                }
                $renderer->doc .= '</ul></td>';
            } else {
                // display a "no results" message if empty
                $renderer->doc .= '<td><p>' . $this->getLang("no_results") .
                                  '"<strong>' . $query . '</strong>"</p></td>' . DOKU_LF;
            }
            $renderer->doc .= '</tr>' . DOKU_LF;
            $renderer->doc .= '</tbody></table>';
            $renderer->doc .= '</div>' . DOKU_LF;
            return true;
        } else {
            return false;
        }
    }

    /**
     * Renders the page link, plus tooltip, abstract, casing, etc...
     * @param string $id
     * @param bool  $proper
     * @param bool  $title
     * @param mixed $abstract
     */
    private function _render_wikilink($id, $proper, $title, $abstract, $max_abstract) {

        $id = (strpos($id, ':') === false) ? ':' . $id : $id;   // : needed for root pages

        // does the user want to see the "title" instead "pagename"
        if ($title) {
            $value = p_get_metadata($id, 'title', true);
            $name = (empty($value)) ? $this->_proper(noNS($id)) : $value;
        } elseif ($proper == 'name' || $proper == 'both') {
            $name = $this->_proper(noNS($id));
        } else {
            $name = '';
        }

        // show the "abstract" as a tooltip
        // -or- as a nice quoted snippet ( la blockquote plugin)
        $detail = '';
        if ($abstract == 'none') {
            $link = html_wikilink($id, $name);
        } elseif ($abstract == 'tooltip' || ($abstract > 0 && $max_abstract >= $abstract)) {
            $link = $this->_html_wikilink_tooltip($id, $name);
        } elseif ($abstract == 'all' || $abstract == 0 || ($abstract > 0 && $max_abstract < $abstract)) {
            $link = html_wikilink($id, $name);
            $detail = str_replace("\n\n", '<br/>', $this->_abstract($id));
            $more = html_wikilink($id, 'more...');
            $detail = '<blockquote>' . $detail . $more . '</blockquote>' . DOKU_LF;
        }
        return '<li>' . $link . '</li>' . DOKU_LF . $detail;
    }

    private function _proper($id) {
         $id = str_replace(':', ': ', $id);
         $id = str_replace('_', ' ', $id);
         $id = ucwords($id);
         $id = str_replace(': ', ':', $id);
         return $id;
    }
    /**
     * swap normal link title (popup) for a more useful preview
     *
     * @param string $id    page id
     * @param string $name  display name
     * @return complete href link
     */
    private function _html_wikilink_tooltip($id, $name) {
        $link = html_wikilink($id, $name);
        $tooltip = $this->_abstract($id);
        $tooltip = str_replace("\n", '  ', $tooltip);
        $link = preg_replace('/title=\".+?\"/', 'title="' . $tooltip . '"', $link, 1);
        return $link;
    }

    private function _abstract($id) {
        $abstract = p_get_metadata($id, 'description abstract', true);
        $abstract = htmlspecialchars($abstract, ENT_QUOTES, 'UTF-8');
        return $abstract;
    }

    /**
     * Parse out the namespace, and convert to a regex for array search
     * -or- ensure that normal search are only within pagename not its namespace
     *
     * @param string $query user page query
     * @return processed query with regex markup as needed for namespace recognition
     */
    private function _parse_ns_query($query) {
        $incl_ns = array();
        $excl_ns = array();
        $page_qry = '';
        $tokens = explode(' ', $query);
        foreach ($tokens as $token) {
            if (preg_match('/^(?:\^|-ns:)(.+)$/u', $token, $matches)) {
                $excl_ns[] = $matches[1];
            } elseif (preg_match('/^(?:@|ns:)(.+)$/u', $token, $matches)) {
                $incl_ns[] = $matches[1];
            } else {
                $page_qry .= ' ' . $token;
            }
        }
        $page_qry = trim($page_qry);
		if ($page_qry == '*') $page_qry = '.*';
        return array($page_qry, true, $incl_ns, $excl_ns);	// true => turns on pageonly lookup
    }

    /**
     * Builds a separate sorting array for each sortby key
     *
     * @param string    $id         wiki page id
     * @param array     $sortby     keys to use for sorting
     * @param arrayref  $sortkeys   ref to sorting arrays
     * @return void
     */
    private function _get_sort_opts($ids, $sortkeys, $title) {
        global $conf;
        $sort_opts = array();
        $dformat = array();
        $dates = array();

        $cnt = 0;
        foreach ($ids as $id) {
            $meta = p_get_metadata ($id, false, true);
            if (!isset($meta['date']['modified'])) {
                $meta['date']['modified'] = $meta['date']['created'];
            }
            if ($title && !isset($meta['title'])) {
                $meta['title'] = $this->_proper(noNS($id));
            }
            $idx = 0;
            foreach ($sortkeys as $sortkey) {
                $key = $sortkey[0];
                switch ($key) {
                    case 'a':
                        $value = $this->_first(noNS($id), 1);
                        break;
                    case 'ab':
                        $value = $this->_first(noNS($id), 2);
                        break;
                    case 'abc':
                        $value = $this->_first(noNS($id), 3);
                        break;
                    case 'name':
                        $value = ($title) ? $meta['title'] : noNS($id);
                        break;
                    case 'id':
                    case 'page':
                        $value = $id;
                        break;
                    case 'ns':
                        $value = getNS($id);
                        if (empty($value)) $value = '[' . $conf['start'] . ']';
                        break;
                    case 'creator':
                        $value = $meta['creator'];
                        break;
                    case 'mdate':
                        $value = $meta['date']['modified'];
                        break;
                    case 'cdate':
                        $value = $meta['date']['created'];
                        break;
                    default:
                        $dtype = $key[0];
                        if ($dtype == 'c' || $dtype == 'm') {
                            // only set date once per id (not per sort column--date remains same across columns)
                            if ( ! isset($dates[$cnt])) {
                                if ($dtype == 'c') {
                                    $date = $meta['date']['created'];
                                } else {
                                    $date = $meta['date']['modified'];
                                }
                                $dates[$cnt] = $date;
                            } else {
                                $date = $dates[$cnt];
                            }
                            // the date formats are cached on first use; allows one of each key type per set
                            if ( ! isset($dformat[$key])) {
                                $dformat[$key] = $this->_date_format($key, $this->inwords);
                                $sort_opts[$idx]['inwords'] = $dformat[$key][1];
                            }
                            $value = strftime($dformat[$key][0], $date);
                        }
                }
                $sort_opts[$idx]['keys'][] = $value;
                $idx++;
            }
            $cnt++;
        }
        $idx = 0;
        foreach ($sortkeys as $sortkey) {
            list($key, $opt) = $sortkey;
            // now the sort direction
            switch ($opt) {
                case 'a':
                case 'asc':
                    $dir = SORT_ASC;
                    break;
                case 'd':
                case 'desc':
                    $dir = SORT_DESC;
                    break;
                default:
                    // sort descending by default; text ascending
                    // watch for other options beginning with c or m ....!
                    if ($key[0] == 'c' || $key[0] == 'm') {
                        $dir = SORT_DESC;
                    } else {
                        $dir = SORT_ASC;
                    }
            }
            $sort_opts[$idx]['dir'] = $dir;

            // establish grouping type
            switch ($key) {
                // full-text and full dates cannot meaningfully be grouped (no duplicates!)
                case 'mdate':
                case 'cdate':
                case 'name':
                case 'id':
                case 'page':
                    $group = false;
                    break;
                case 'ns':
                    $group = 'ns';
                    break;
                default:
                    $group = true;
            }
            $sort_opts[$idx]['group'] = $group;

            // and finally set the sort array's data type (for correct markup purposes)
            $is_ns = false;
            switch ($key) {
                case 'mdate':
                case 'cdate':
                    $type = SORT_NUMERIC;
                    break;
                default:
                    $type = SORT_STRING;
            }
            $sort_opts[$idx]['type'] = $type;
            $idx++;
        }
        return array($sort_opts, $dates);
    }

    // returns first $count letters from $text
    private function _first($text, $count) {
        if ($count > 0) {
            return utf8_substr($text, 0, $count);
        }
    }

    // parse the c|m-year-month-day option
    private function _date_format($key, $inwords = false) {
        if (strpos($key, 'year') !== false) $dkey[] = '%Y';
        if (strpos($key, 'month') !== false) $dkey[] = '%m';
        if (strpos($key, 'day') !== false) $dkey[] = '%d';
        $dformat = implode('-', $dkey);
        // provide month and day format in real words if required
        // used for display only; $dformat is used for correct sorting!
        $wformat = '';
        if ($inwords) {
            switch ($dformat) {
                case '%m':
                    $wformat = "%B";
                    break;
                case '%d':
                    $wformat = "%#d, %A ";
                    break;
                case '%Y-%m':
                    $wformat = "%B %Y";
                    break;
                case '%m-%d':
                    $wformat= "%B %#d, %A ";
                    break;
                case '%Y-%m-%d':
                    $wformat = "%A, %B %#d, %Y";
                    break;
            }
        }
        return array($dformat, $wformat);
    }

    // sort by each sorting array, in order
    private function _sort_results(&$ids, &$sort_opts, &$dates) {
        if ( ! empty($sort_opts)) {
            $args = array();
            foreach ($sort_opts as &$sort_opt) {
                $args[] = &$sort_opt['keys'];
                $args[] = &$sort_opt['dir'];
                $args[] = &$sort_opt['type'];
            }
            if ( ! empty($dates)) $args[] = &$dates;
            $args[] = &$ids;
            call_user_func_array('array_multisort', $args);
        }
    }

    private function _group_results(&$ids, &$sort_opts, &$dates) {
        $prevs = array();
        $results = array();
        $level = count($sort_opts) - 1;
        $idx = 0;
        foreach($ids as $id) {
            $this->_add_heading($results, $sort_opts, $dates, $level, $idx, $prevs);
            $results[] = $id;
            $idx++;
        }
        return $results;
    }

    private function _add_heading(&$results, &$sort_opts, &$dates, $level, $idx, &$prevs) {
        if ($level > 0) {
            // recurse to find all parent headings
            $this->_add_heading($results, $sort_opts, $dates, $level - 1, $idx, $prevs);
        }
        $group = $sort_opts[$level]['group'];
        // only if this sort array can be grouped....
        if ($group === true) {
            $prev = (isset($prevs[$level])) ? $prevs[$level] : '';
            $cur = $sort_opts[$level]['keys'][$idx];
            if ($cur != $prev) {
                $prevs[$level] = $cur;
                $hl = ($level + 1);
                $inwords = $sort_opts[$level]['inwords'];
                if ($this->inwords && ! empty($inwords)) $cur = strftime($inwords, $dates[$idx]);
                $results[] = $hl . '|' . $cur;
            }
        } elseif ($group == 'ns') {
            $prev = (isset($prevs[$level])) ? $prevs[$level] : '';
            $cur = $sort_opts[$level]['keys'][$idx];
            if ($cur != $prev) {
                $prevs[$level] = $cur;
                $cur_ns = explode(':', $cur);
                $prev_ns = explode(':', $prev);
                // we only show namespaces that are different from the previous heading
                for ($i= 0; $i < count($cur_ns); $i++) {
                    if ($cur_ns[$i] != $prev_ns[$i]) {
                        $hl = $level + $i + 1;
                        $hl = ($hl > 6) ? 6 : $hl;
                        $results[] = $hl . '|' . $cur_ns[$i];
                    }
                }
            }
        }
    }


    /**
     * heavily customised version of _ft_pageLookup in inc/fulltext.php
     * I just removed the preg_quote line to enable regexes in search query...
     * and the unnecessary usort line as I have my own sort routines
     *
     */
    private function _pageLookup($query, $pageonly, $incl_ns, $excl_ns) {
        global $conf;

        $query = trim($query);
        $pages = file($conf['indexdir'] . '/page.idx');
        $pages = array_values(preg_grep('/' . $query . '/', $pages));

        // first deal with excluded namespaces, then included
        $pages = $this->_filter_ns($pages, $excl_ns, true);

        // now include ONLY the selected namespaces if provided
        $pages = $this->_filter_ns($pages, $incl_ns, false);

        $cnt = count($pages);
        for ($i = 0; $i < $cnt; $i++) {
            if ($pageonly) {
                if( ! preg_match('/' . $query . '/', noNS($pages[$i]))) {
                    unset($pages[$i]);
                    continue;
                }
            }
            if ( ! page_exists($pages[$i])) {
                unset($pages[$i]);
            }
        }

        $pages = array_filter($pages, 'isVisiblePage'); // discard hidden pages
        if ( ! count($pages)) return array();

        $pages = array_map('trim',$pages);

        // check ACL permissions and remove any 'start' pages if req'd
        $start = $conf['start'];
        $pos = strlen($start);
        foreach($pages as $idx => $name) {
            if ($this->nostart && substr($name, -$pos) == $start) {
                unset($pages[$idx]);
            } elseif(auth_quickaclcheck(trim($pages[$idx])) < AUTH_READ){
                unset($pages[$idx]);
            } elseif ($this->maxns > 0 && (substr_count($name,':') + 1) > $this->maxns) {
                unset($pages[$idx]);    //skip this page
            }
        }
        return $pages;
    }

    private function _filter_ns($pages, $ns_qry, $exclude) {
        $invert = ($exclude) ? PREG_GREP_INVERT : 0;
        foreach ($ns_qry as $ns) {
            $regexes[] = '.*' . $ns . ':.*';
        }
        if ( ! empty($regexes)) {
            $regex = '/(' . implode('|', $regexes) . ')/';
            return array_values(preg_grep($regex, $pages, $invert));
        } else {
            return $pages;
        }
    }
}

blob
mark :40
data 1644
div.dokuwiki div#pagequery h1,
div.dokuwiki div#pagequery h2,
div.dokuwiki div#pagequery h3,
div.dokuwiki div#pagequery h4,
div.dokuwiki div#pagequery h5,
div.dokuwiki div#pagequery h6 {
    padding:0.2em 0 0.1em 0;
    margin:0;
    margin-bottom:4px;
    color:gray;
}
div.dokuwiki div#pagequery h3,
div.dokuwiki div#pagequery h4,
div.dokuwiki div#pagequery h5,
div.dokuwiki div#pagequery h6 {
    font-weight:normal;
}
div.dokuwiki div#pagequery h1 {font-size:160%;}
div.dokuwiki div#pagequery h2 {margin-left:8px; font-weight:bold;}
div.dokuwiki div#pagequery h3 {margin-left:16px}
div.dokuwiki div#pagequery h4 {margin-left:24px}
div.dokuwiki div#pagequery h5 {margin-left:30px}
div.dokuwiki div#pagequery h6 {margin-left:36px}

div.dokuwiki div#pagequery table {
    border-collapse:collapse;
    width:99%;
}
div.dokuwiki div#pagequery td {
	border-width:1px;
	padding:5px 10px;
	border-style:solid;
	border-color:#D7D5D4;
	background-color:white;
}
div.dokuwiki div#pagequery ul {
    list-style:none;
    margin:0 0 8px 20px;
	text-align:left;
}
div.dokuwiki div#pagequery ul.nogroup {
    margin:0 0 5px 3px;
}
div.dokuwiki div#pagequery li {
	padding-left:7px;
	list-style-position:inside;
	text-indent:-7px;
}
/* credit: blockquote:plugin */
div.dokuwiki div#pagequery blockquote {
    font-size:80%;
	margin: 5px 15px 10px 15px !important;
	border: 1px dotted __border__ !important;
	background: #FAFACE url(images/blockquote.gif) no-repeat 5px 5px !important;
	padding: 10px 15px 15px 18px !important;
    -moz-border-radius: 6px;
    -webkit-border-radius: 6px;
}
div.dokuwiki div#pagequery blockquote a {
    margin-left:12px;
}
blob
mark :41
data 27448
<?php
/**
 * PageQuery Plugin: search for and list pages, sorted by name, date, creator, etc
 *
 * @license    GPL 2 (http://www.gnu.org/licenses/gpl.html)
 * @author	   Symon Bent <hendrybadao@gmail.com>
 */
// must be run within Dokuwiki
if(!defined('DOKU_INC')) die();

if (!defined('DOKU_LF')) define('DOKU_LF', "\n");
if (!defined('DOKU_TAB')) define('DOKU_TAB', "\t");
if (!defined('DOKU_PLUGIN')) define('DOKU_PLUGIN',DOKU_INC.'lib/plugins/');

require_once(DOKU_PLUGIN.'syntax.php');
require_once(DOKU_INC.'inc/fulltext.php');

class syntax_plugin_pagequery extends DokuWiki_Syntax_Plugin {
    private $dformat = '';
    private $inwords = false;
    private $nostart = false;
    private $maxns = 0;

	function getType() {
		return 'substition';
	}

	function getPType() {
		return 'block';
	}

	function getSort() {
		return 98;
	}

	function connectTo($mode) {
		//Default is a word cloud style, looks good when combined with plugin:box
		$this->Lexer->addSpecialPattern('\{\{pagequery>.*?\}\}', $mode, 'plugin_pagequery');
	}
    /**
     * Parses all the pagequery options:
     * Insert the pagequery markup wherever you want your list to appear. E.g:
     *
     *   {{pagequery>}}
     *
     *   {{pagequery>[query];fulltext;sort=key:direction,key2:direction;group;limit=??;cols=?;inwords;proper}}
     *
     * Parameters as follows:
     * 1. query:    any expression directly after the >; can use all Dokuwiki search options (see manual)
     * 2. fulltext: use a full-text search, instead of page_id only [default]
     * 3. sort:     keys to sort by, in order of sorting. Each key can be followed by prefered sorting order
     *              available keys:
     *                  a, ab, abc          by 1st letter, 2 letters, or 3 letters
     *                  name                by page name (no namespace) [not grouped]
     *                  page|id             by full page id, including namespace [not grouped]
     *                  ns                  by namespace (without page name)
     *                  mdate, cdate        by modified|created dates (full) [not grouped]
     *                  m[year][month][day] by modified [year][month][day]; any combination accepted
     *                  c[year][month][day] by created [year][month][day]; any combination accepted
     *                  creator             by page author
     *              date sort default to descending, string sorts to ascending
     * 4. group:    show group headers for each change in sort keys
     *              Note: keys with no duplicated cannot be grouped (i.e. name, page|id, mdate, cdate)
     * 5. limit:    maximum number of results to return
     * 6. inwords:  use real month and day names instead of just numbers
     * 7. cols:     number of columns in displayed list (max = 4)
     * 8. proper:   display page names and namespace in Proper Case (i.e. no _'s and Capitalised)
                    header/hdr = group headers only, name = page name only, both = both!
     * 9. border:   turn on borders
     *10. fullregex:only useful on page name searches; allows a raw regex mode on the full page id
     *11. nostart:  ignore any 'start' pages in namespace (based on "config:start")
     *12. maxns:    maximum namespace level to be displayed; e.g. maxns=3 => one:two:three
     *13. title:    show 1st page heading instead of page name
     *14. abstract: should an excerpt of the wikipage:
     *              use :tooltip to show as a pop-up only
     *              use :<number> to show 1st n items in list with an abstract
     *
     * All options are optional, and the list will default to a boring long 1-column list...
     */
	function handle($match, $state, $pos, &$handler) {
        global $conf;
        $this->dformat = $conf['dformat'];

		$match = substr($match, 12, -2); // strip markup incl. pagequery>
		$args = explode(';', $match);
        $query = $args[0];
        $fulltext = false;
        $sort = array();
        $group = false;
        $limit = 0;  //Default max items displayed. '0' => no limit
        $maxns = 0;  // Maximum no. of namespace levels to display
        $proper = 'none';
        $cols = 1;
        $border = false;
        $title = false; // use title instead of name
        $abstract = 'tooltip';
        $fullregex = false;

        foreach ($args as $arg) {
            list($key, $value) = explode('=', $arg);
            switch ($key) {
                case 'fulltext':
                    $fulltext = true;
                    break;
                case 'sort':
                    $values = explode(',', $value);
                    foreach ($values as $value) {
                        list($key, $dir) = explode(':', $value);
                        $sort[] = array($key, $dir);
                    }
                    break;
                case 'group':
                    $group = true;
                    break;
                case 'limit':
                    $limit = $value;
                    break;
                case 'maxns':
                    $maxns = $value;
                    break;
                case 'inwords':
                    $inwords = true;
                    break;
                case 'proper':
                    switch ($value) {
                        case 'hdr':
                        case 'header':
                        case 'group':
                            $proper = 'header';
                            break;
                        case 'name':
                        case 'page':
                            $proper = 'name';
                            break;
                        default:
                            $proper = 'both';
                    }
                    break;
                case 'cols':
                    $cols = ($value > 6) ? 6 : $value;
                    break;
                case 'border':
                    $border = true;
                    break;
				case 'fullregex':
					$fullregex = true;
					break;
                case 'nostart':
                    $nostart = true;
                    break;
                case 'title':
                    $title = true;
                    break;
                case 'abstract':
                    switch ($value) {
                        case '':
                        case 'tooltip':
                            $abstract = 'tooltip';
                            break;
                        default:
                            if ($value >= 0) {
                                $abstract = $value;
                            }
                }
            }
        }
		return array($query, $fulltext, $sort, $group, $limit, $maxns, $proper,
                      $cols, $inwords, $border, $fullregex, $nostart, $title, $abstract);
	}

    function render($mode, &$renderer, $data) {
        $sortkeys = array();
        $incl_ns = array();
        $excl_ns = array();

        list($query, $fulltext, $sort, $group, $limit, $maxns, $proper,
              $cols, $inwords, $border, $fullregex, $nostart, $title, $abstract) = $data;
        $this->inwords = $inwords;
        $this->nostart = $nostart;
        $this->maxns = $maxns;

        if ($mode == 'xhtml') {
            // first get a raw list of matching results
            if ($fulltext) {
                $results = array_keys(ft_pageSearch($query, $highlight));
            } else {
                // allow for raw regex mode, for power users, this searches the full page id
                if ($fullregex) {
                    $full_query = $query;
                    $pageonly = false;
                } else {
                    list($full_query, $pageonly, $incl_ns, $excl_ns) = $this->_parse_ns_query($query);
                }
                $results = $this->_pageLookup($full_query, $pageonly, $incl_ns, $excl_ns);
            }

            // basic result page markup (always needed)
            $renderer->doc .= '<div id="pagequery">' . DOKU_LF;
            $renderer->doc .= '<table><tbody><tr>' . DOKU_LF;

            if ( ! empty($results)) {
                // prepare the necessary sorting arrays, as per options
                list($sort_opts, $dates) = $this->_get_sort_opts($results, $sort, $title);
                // now do the sorting
                $this->_sort_results($results, $sort_opts, $dates);
                // limit the result list length if required
                // remember: this can only be done after sorting!
                $results = ($limit > 0) ? array_slice($results, 0, $limit) : $results;
                // and finally the grouping
                if ($group) {
                    $results = $this->_group_results($results, $sort_opts, $dates);
                }

                // now render the actual result list
                $was_heading = false;
                $idx = 0;
                $col = 0;
                $rows = ceil(count($results) / $cols);  // proposed column row size
                $width = floor(100 / $cols);
                $indent_css = ($group === false) ? ' class="nogroup"' : ''; // remove indenting if not grouped
                $border_css = ($border === false) ? ' style="border-style:none;"' : '';
                $max_abstract = 0;    // needed by the abstract snippet section

                foreach ($results as $id) {
                    // are we ready to start a new column? (up to max allowed)
                    if ($col < $cols && $idx % $rows == 0) {
                        $ready_for_col = true;
                        $col++;
                    }
                    $is_heading = ($id[1] == '|');
                    if ($is_heading) {
                        list($hl, $heading) = explode('|', $id);
                        if ($proper == 'header' || $proper == 'both') $heading = $this->_proper($heading);
                    }

                    // Begin new column if: we are at the start, at a heading or if there is no grouping
                    if ($ready_for_col && ! $was_heading) {
                        // close the previous column if necessary
                        $cont_close = (!$is_heading) ? '<strong> ... </strong>' : '';
                        $cont_open = ($idx > 0 && !$is_heading) ? "<h$hl>$heading ...</h$hl>" : '';
                        $close = ($idx > 0) ? $cont_close . '</ul></td>' . DOKU_LF : '';
                        $renderer->doc .= $close . '<td' . $border_css . ' valign="top" width="' . $width . '%">' . $cont_open . DOKU_LF;
                        $ready_for_col = false;
                        $was_heading = true;    //needed to begin a new page id list
                    }
                    if ($is_heading) {
                        // close previous sub list if necessary
                        if (!$was_heading) $renderer->doc .= '</ul>' . DOKU_LF;
                        $renderer->doc .= "<h$hl>$heading</h$hl>" . DOKU_LF;
                        $was_heading = true;
                    } else {
                        // open a new sub list if necessary
                        if ($was_heading || $idx == 0) $renderer->doc .= '<ul' . $indent_css . '>';

                        // deal with normal page links
                        $link = $this->_render_wikilink($id, $proper, $title, $abstract, $max_abstract);
                        $max_abstract++;
                        $renderer->doc .= $link;
                        $was_heading = false;
                    }
                    $idx++;
                }
                $renderer->doc .= '</ul></td>';
            } else {
                // display a "no results" message if empty
                $renderer->doc .= '<td><p>' . $this->getLang("no_results") .
                                  '"<strong>' . $query . '</strong>"</p></td>' . DOKU_LF;
            }
            $renderer->doc .= '</tr>' . DOKU_LF;
            $renderer->doc .= '</tbody></table>';
            $renderer->doc .= '</div>' . DOKU_LF;
            return true;
        } else {
            return false;
        }
    }

    /**
     * Renders the page link, plus tooltip, abstract, casing, etc...
     * @param string $id
     * @param bool  $proper
     * @param bool  $title
     * @param mixed $abstract
     */
    private function _render_wikilink($id, $proper, $title, $abstract, $max_abstract) {

        $id = (strpos($id, ':') === false) ? ':' . $id : $id;   // : needed for root pages

        // does the user want to see the "title" instead "pagename"
        if ($title) {
            $value = p_get_metadata($id, 'title', true);
            $name = (empty($value)) ? $this->_proper(noNS($id)) : $value;
        } elseif ($proper == 'name' || $proper == 'both') {
            $name = $this->_proper(noNS($id));
        } else {
            $name = '';
        }

        // show the "abstract" as a tooltip
        // -or- as a nice quoted snippet ( la blockquote plugin)
        $detail = '';
        if ($abstract == 'none') {
            $link = html_wikilink($id, $name);
        } elseif ($abstract == 'tooltip' || ($abstract > 0 && $max_abstract >= $abstract)) {
            $link = $this->_html_wikilink_tooltip($id, $name);
        } elseif ($abstract == 'all' || $abstract == 0 || ($abstract > 0 && $max_abstract < $abstract)) {
            $link = html_wikilink($id, $name);
            $detail = str_replace("\n\n", '<br/>', $this->_abstract($id));
            $more = html_wikilink($id, 'more...');
            $detail = '<blockquote>' . $detail . $more . '</blockquote>' . DOKU_LF;
        }
        return '<li>' . $link . '</li>' . DOKU_LF . $detail;
    }

    private function _proper($id) {
         $id = str_replace(':', ': ', $id);
         $id = str_replace('_', ' ', $id);
         $id = ucwords($id);
         $id = str_replace(': ', ':', $id);
         return $id;
    }
    /**
     * swap normal link title (popup) for a more useful preview
     *
     * @param string $id    page id
     * @param string $name  display name
     * @return complete href link
     */
    private function _html_wikilink_tooltip($id, $name) {
        $link = html_wikilink($id, $name);
        $tooltip = $this->_abstract($id);
        $tooltip = str_replace("\n", '  ', $tooltip);
        $link = preg_replace('/title=\".+?\"/', 'title="' . $tooltip . '"', $link, 1);
        return $link;
    }

    private function _abstract($id) {
        $abstract = p_get_metadata($id, 'description abstract', true);
        $abstract = htmlspecialchars($abstract, ENT_QUOTES, 'UTF-8');
        return $abstract;
    }

    /**
     * Parse out the namespace, and convert to a regex for array search
     * -or- ensure that normal search are only within pagename not its namespace
     *
     * @param string $query user page query
     * @return processed query with regex markup as needed for namespace recognition
     */
    private function _parse_ns_query($query) {
        $incl_ns = array();
        $excl_ns = array();
        $page_qry = '';
        $tokens = explode(' ', $query);
        foreach ($tokens as $token) {
            if (preg_match('/^(?:\^|-ns:)(.+)$/u', $token, $matches)) {
                $excl_ns[] = $matches[1];
            } elseif (preg_match('/^(?:@|ns:)(.+)$/u', $token, $matches)) {
                $incl_ns[] = $matches[1];
            } else {
                $page_qry .= ' ' . $token;
            }
        }
        $page_qry = trim($page_qry);
		if ($page_qry == '*') $page_qry = '.*';
        return array($page_qry, true, $incl_ns, $excl_ns);	// true => turns on pageonly lookup
    }

    /**
     * Builds a separate sorting array for each sortby key
     *
     * @param string    $id         wiki page id
     * @param array     $sortby     keys to use for sorting
     * @param arrayref  $sortkeys   ref to sorting arrays
     * @return void
     */
    private function _get_sort_opts($ids, $sortkeys, $title) {
        global $conf;
        $sort_opts = array();
        $dformat = array();
        $wformat = array();
        $dates = array();

        $cnt = 0;
        foreach ($ids as $id) {
            $meta = p_get_metadata ($id, false, true);
            if ( ! isset($meta['date']['modified'])) {
                $meta['date']['modified'] = $meta['date']['created'];
            }
            if ($title && isset($meta['title'])) {
                $name = strtolower($meta['title']);
            } else {
                $name = noNS($id);
            }
            $idx = 0;
            foreach ($sortkeys as $sortkey) {
                $key = $sortkey[0];
                switch ($key) {
                    case 'a':
                        $value = $this->_first($name, 1);
                        break;
                    case 'ab':
                        $value = $this->_first($name, 2);
                        break;
                    case 'abc':
                        $value = $this->_first($name, 3);
                        break;
                    case 'name':
                        $value = $name;
                        break;
                    case 'id':
                    case 'page':
                        $value = $id;
                        break;
                    case 'ns':
                        $value = getNS($id);
                        if (empty($value)) $value = '[' . $conf['start'] . ']';
                        break;
                    case 'creator':
                        $value = $meta['creator'];
                        break;
                    case 'mdate':
                        $value = $meta['date']['modified'];
                        break;
                    case 'cdate':
                        $value = $meta['date']['created'];
                        break;
                    default:
                        $dtype = $key[0];
                        if ($dtype == 'c' || $dtype == 'm') {
                            // only set date once per id (not per sort column--date remains same across columns)
                            if ( ! isset($dates[$cnt])) {
                                if ($dtype == 'c') {
                                    $date = $meta['date']['created'];
                                } else {
                                    $date = $meta['date']['modified'];
                                }
                                $dates[$cnt] = $date;
                            } else {
                                $date = $dates[$cnt];
                            }
                            // the date formats are cached on first use; limited to one per sort column/key
                            if ( ! isset($dformat[$key])) {
                                list($dformat[$key], $wformat[$key]) = $this->_date_format($key, $this->inwords);
                                $sort_opts[$idx]['inwords'] = $wformat[$key];
                            }
                            // create a string date used for sorting only
                            // (we cannot just use the date otherwise it would not group correctly)
                            $value = strftime($dformat[$key], $date);
                        }
                }
                $sort_opts[$idx]['keys'][] = $value;
                $idx++;
            }
            $cnt++;
        }
        $idx = 0;
        foreach ($sortkeys as $sortkey) {
            list($key, $opt) = $sortkey;
            // now the sort direction
            switch ($opt) {
                case 'a':
                case 'asc':
                    $dir = SORT_ASC;
                    break;
                case 'd':
                case 'desc':
                    $dir = SORT_DESC;
                    break;
                default:
                    // sort descending by default; text ascending
                    // watch for other options beginning with c or m ....!
                    if ($key[0] == 'c' || $key[0] == 'm') {
                        $dir = SORT_DESC;
                    } else {
                        $dir = SORT_ASC;
                    }
            }
            $sort_opts[$idx]['dir'] = $dir;

            // establish grouping type
            switch ($key) {
                // full-text and full dates cannot meaningfully be grouped (no duplicates!)
                case 'mdate':
                case 'cdate':
                case 'name':
                case 'id':
                case 'page':
                    $group = false;
                    break;
                case 'ns':
                    $group = 'ns';
                    break;
                default:
                    $group = true;
            }
            $sort_opts[$idx]['group'] = $group;

            // and finally set the sort array's data type (for correct markup purposes)
            $is_ns = false;
            switch ($key) {
                case 'mdate':
                case 'cdate':
                    $type = SORT_NUMERIC;
                    break;
                default:
                    $type = SORT_STRING;
            }
            $sort_opts[$idx]['type'] = $type;
            $idx++;
        }
        return array($sort_opts, $dates);
    }

    // returns first $count letters from $text
    private function _first($text, $count) {
        if ($count > 0) {
            return utf8_substr($text, 0, $count);
        }
    }

    /** parse the c|m-year-month-day option
     *
     * @param type $key
     * @param type $inwords
     * @return array $dformat, $wformat
     */
    private function _date_format($key, $inwords = false) {
        if (strpos($key, 'year') !== false) $dkey[] = '%Y';
        if (strpos($key, 'month') !== false) $dkey[] = '%m';
        if (strpos($key, 'day') !== false) $dkey[] = '%d';
        $dformat = implode('-', $dkey);
        // provide month and day format in real words if required
        // used for display only; $dformat is used for correct sorting!
        $wformat = '';
        if ($inwords) {
            switch ($dformat) {
                case '%m':
                    $wformat = "%B";
                    break;
                case '%d':
                    $wformat = "%#d, %A ";
                    break;
                case '%Y-%m':
                    $wformat = "%B %Y";
                    break;
                case '%m-%d':
                    $wformat= "%B %#d, %A ";
                    break;
                case '%Y-%m-%d':
                    $wformat = "%A, %B %#d, %Y";
                    break;
            }
        }
        return array($dformat, $wformat);
    }

    // sort by each sorting array, in order
    private function _sort_results(&$ids, &$sort_opts, &$dates) {
        if ( ! empty($sort_opts)) {
            $args = array();
            foreach ($sort_opts as &$sort_opt) {
                $args[] = &$sort_opt['keys'];
                $args[] = &$sort_opt['dir'];
                $args[] = &$sort_opt['type'];
            }
            if ( ! empty($dates)) $args[] = &$dates;
            $args[] = &$ids;
            call_user_func_array('array_multisort', $args);
        }
    }

    private function _group_results(&$ids, &$sort_opts, &$dates) {
        $prevs = array();
        $results = array();
        $level = count($sort_opts) - 1;
        $idx = 0;
        foreach($ids as $id) {
            $this->_add_heading($results, $sort_opts, $dates, $level, $idx, $prevs);
            $results[] = $id;
            $idx++;
        }
        return $results;
    }

    private function _add_heading(&$results, &$sort_opts, &$dates, $level, $idx, &$prevs) {
        if ($level > 0) {
            // recurse to find all parent headings
            $this->_add_heading($results, $sort_opts, $dates, $level - 1, $idx, $prevs);
        }
        $group = $sort_opts[$level]['group'];
        // only if this sort array can be grouped....
        if ($group === true) {
            $prev = (isset($prevs[$level])) ? $prevs[$level] : '';
            $cur = $sort_opts[$level]['keys'][$idx];
            if ($cur != $prev) {
                $prevs[$level] = $cur;
                $hl = ($level + 1);
                $inwords = $sort_opts[$level]['inwords'];
                if ($this->inwords && ! empty($inwords)) $cur = strftime($inwords, $dates[$idx]);
                $results[] = $hl . '|' . $cur;
            }
        } elseif ($group == 'ns') {
            $prev = (isset($prevs[$level])) ? $prevs[$level] : '';
            $cur = $sort_opts[$level]['keys'][$idx];
            if ($cur != $prev) {
                $prevs[$level] = $cur;
                $cur_ns = explode(':', $cur);
                $prev_ns = explode(':', $prev);
                // we only show namespaces that are different from the previous heading
                for ($i= 0; $i < count($cur_ns); $i++) {
                    if ($cur_ns[$i] != $prev_ns[$i]) {
                        $hl = $level + $i + 1;
                        $hl = ($hl > 6) ? 6 : $hl;
                        $results[] = $hl . '|' . $cur_ns[$i];
                    }
                }
            }
        }
    }


    /**
     * heavily customised version of _ft_pageLookup in inc/fulltext.php
     * I just removed the preg_quote line to enable regexes in search query...
     * and the unnecessary usort line as I have my own sort routines
     *
     */
    private function _pageLookup($query, $pageonly, $incl_ns, $excl_ns) {
        global $conf;

        $query = trim($query);
        $pages = file($conf['indexdir'] . '/page.idx');
        $pages = array_values(preg_grep('/' . $query . '/', $pages));

        // first deal with excluded namespaces, then included
        $pages = $this->_filter_ns($pages, $excl_ns, true);

        // now include ONLY the selected namespaces if provided
        $pages = $this->_filter_ns($pages, $incl_ns, false);

        $cnt = count($pages);
        for ($i = 0; $i < $cnt; $i++) {
            if ($pageonly) {
                if( ! preg_match('/' . $query . '/', noNS($pages[$i]))) {
                    unset($pages[$i]);
                    continue;
                }
            }
            if ( ! page_exists($pages[$i])) {
                unset($pages[$i]);
            }
        }

        $pages = array_filter($pages, 'isVisiblePage'); // discard hidden pages
        if ( ! count($pages)) return array();

        $pages = array_map('trim',$pages);

        // check ACL permissions and remove any 'start' pages if req'd
        $start = $conf['start'];
        $pos = strlen($start);
        foreach($pages as $idx => $name) {
            if ($this->nostart && substr($name, -$pos) == $start) {
                unset($pages[$idx]);
            } elseif(auth_quickaclcheck(trim($pages[$idx])) < AUTH_READ){
                unset($pages[$idx]);
            } elseif ($this->maxns > 0 && (substr_count($name,':') + 1) > $this->maxns) {
                unset($pages[$idx]);    //skip this page
            }
        }
        return $pages;
    }

    private function _filter_ns($pages, $ns_qry, $exclude) {
        $invert = ($exclude) ? PREG_GREP_INVERT : 0;
        foreach ($ns_qry as $ns) {
            $regexes[] = '.*' . $ns . ':.*';
        }
        if ( ! empty($regexes)) {
            $regex = '/(' . implode('|', $regexes) . ')/';
            return array_values(preg_grep($regex, $pages, $invert));
        } else {
            return $pages;
        }
    }
}

blob
mark :44
data 485
base    pagequery
author  Symon Bent
email   hendrybadao@gmail.com
date    2011-02-26
name    PageQuery Plugin
desc    Search for (fulltext) and list wiki pages, sorted and optionally grouped by name, date, creator, abc, etc. in columns. Insert the pagequery markup wherever you want your list to appear.  E.g.{{pagequery>[query;fulltext;sort=key:direction,key2:direction;group;limit=??;cols=?;inwords;proper]}} [..] = optional
url     http://wiki.splitbrain.org/plugin:pagequery
blob
mark :46
data 27401
<?php
/**
 * PageQuery Plugin: search for and list pages, sorted by name, date, creator, etc
 *
 * @license    GPL 2 (http://www.gnu.org/licenses/gpl.html)
 * @author	   Symon Bent <hendrybadao@gmail.com>
 */
// must be run within Dokuwiki
if(!defined('DOKU_INC')) die();

if (!defined('DOKU_LF')) define('DOKU_LF', "\n");
if (!defined('DOKU_TAB')) define('DOKU_TAB', "\t");
if (!defined('DOKU_PLUGIN')) define('DOKU_PLUGIN',DOKU_INC.'lib/plugins/');

require_once(DOKU_PLUGIN.'syntax.php');
require_once(DOKU_INC.'inc/fulltext.php');

class syntax_plugin_pagequery extends DokuWiki_Syntax_Plugin {
    private $dformat = '';
    private $inwords = false;
    private $nostart = false;
    private $maxns = 0;

	function getType() {
		return 'substition';
	}

	function getPType() {
		return 'block';
	}

	function getSort() {
		return 98;
	}

	function connectTo($mode) {
		//Default is a word cloud style, looks good when combined with plugin:box
		$this->Lexer->addSpecialPattern('\{\{pagequery>.*?\}\}', $mode, 'plugin_pagequery');
	}
    /**
     * Parses all the pagequery options:
     * Insert the pagequery markup wherever you want your list to appear. E.g:
     *
     *   {{pagequery>}}
     *
     *   {{pagequery>[query];fulltext;sort=key:direction,key2:direction;group;limit=??;cols=?;inwords;proper}}
     *
     * Parameters as follows:
     * 1. query:    any expression directly after the >; can use all Dokuwiki search options (see manual)
     * 2. fulltext: use a full-text search, instead of page_id only [default]
     * 3. sort:     keys to sort by, in order of sorting. Each key can be followed by prefered sorting order
     *              available keys:
     *                  a, ab, abc          by 1st letter, 2 letters, or 3 letters
     *                  name                by page name (no namespace) [not grouped]
     *                  page|id             by full page id, including namespace [not grouped]
     *                  ns                  by namespace (without page name)
     *                  mdate, cdate        by modified|created dates (full) [not grouped]
     *                  m[year][month][day] by modified [year][month][day]; any combination accepted
     *                  c[year][month][day] by created [year][month][day]; any combination accepted
     *                  creator             by page author
     *              date sort default to descending, string sorts to ascending
     * 4. group:    show group headers for each change in sort keys
     *              Note: keys with no duplicated cannot be grouped (i.e. name, page|id, mdate, cdate)
     * 5. limit:    maximum number of results to return
     * 6. inwords:  use real month and day names instead of just numbers
     * 7. cols:     number of columns in displayed list (max = 4)
     * 8. proper:   display page names and namespace in Proper Case (i.e. no _'s and Capitalised)
                    header/hdr = group headers only, name = page name only, both = both!
     * 9. border:   turn on borders
     *10. fullregex:only useful on page name searches; allows a raw regex mode on the full page id
     *11. nostart:  ignore any 'start' pages in namespace (based on "config:start")
     *12. maxns:    maximum namespace level to be displayed; e.g. maxns=3 => one:two:three
     *13. title:    show 1st page heading instead of page name
     *14. abstract: should an excerpt of the wikipage:
     *              use :tooltip to show as a pop-up only
     *              use :<number> to show 1st n items in list with an abstract
     *
     * All options are optional, and the list will default to a boring long 1-column list...
     */
	function handle($match, $state, $pos, &$handler) {
        global $conf;
        $this->dformat = $conf['dformat'];

		$match = substr($match, 12, -2); // strip markup incl. pagequery>
		$args = explode(';', $match);
        $query = $args[0];
        $fulltext = false;
        $sort = array();
        $group = false;
        $limit = 0;  //Default max items displayed. '0' => no limit
        $maxns = 0;  // Maximum no. of namespace levels to display
        $proper = 'none';
        $cols = 1;
        $border = false;
        $title = false; // use title instead of name
        $abstract = 'tooltip';
        $fullregex = false;

        foreach ($args as $arg) {
            list($key, $value) = explode('=', $arg);
            switch ($key) {
                case 'fulltext':
                    $fulltext = true;
                    break;
                case 'sort':
                    $values = explode(',', $value);
                    foreach ($values as $value) {
                        list($key, $dir) = explode(':', $value);
                        $sort[] = array($key, $dir);
                    }
                    break;
                case 'group':
                    $group = true;
                    break;
                case 'limit':
                    $limit = $value;
                    break;
                case 'maxns':
                    $maxns = $value;
                    break;
                case 'inwords':
                    $inwords = true;
                    break;
                case 'proper':
                    switch ($value) {
                        case 'hdr':
                        case 'header':
                        case 'group':
                            $proper = 'header';
                            break;
                        case 'name':
                        case 'page':
                            $proper = 'name';
                            break;
                        default:
                            $proper = 'both';
                    }
                    break;
                case 'cols':
                    $cols = ($value > 6) ? 6 : $value;
                    break;
                case 'border':
                    $border = true;
                    break;
				case 'fullregex':
					$fullregex = true;
					break;
                case 'nostart':
                    $nostart = true;
                    break;
                case 'title':
                    $title = true;
                    break;
                case 'abstract':
                    switch ($value) {
                        case '':
                        case 'tooltip':
                            $abstract = 'tooltip';
                            break;
                        default:
                            if ($value >= 0) {
                                $abstract = $value;
                            }
                }
            }
        }
		return array($query, $fulltext, $sort, $group, $limit, $maxns, $proper,
                      $cols, $inwords, $border, $fullregex, $nostart, $title, $abstract);
	}

    function render($mode, &$renderer, $data) {
        $sortkeys = array();
        $incl_ns = array();
        $excl_ns = array();

        list($query, $fulltext, $sort, $group, $limit, $maxns, $proper,
              $cols, $inwords, $border, $fullregex, $nostart, $title, $abstract) = $data;
        $this->inwords = $inwords;
        $this->nostart = $nostart;
        $this->maxns = $maxns;

        if ($mode == 'xhtml') {
            // first get a raw list of matching results
            if ($fulltext) {
                $results = array_keys(ft_pageSearch($query, $highlight));
            } else {
                // allow for raw regex mode, for power users, this searches the full page id
                if ($fullregex) {
                    $pageonly = false;
                } else {
                    list($query, $incl_ns, $excl_ns) = $this->_parse_ns_query($query);
                    $pageonly = true;
                }
                $results = $this->_pageLookup($query, $pageonly, $incl_ns, $excl_ns);
            }

            // basic result page markup (always needed)
            $renderer->doc .= '<div id="pagequery">' . DOKU_LF;
            $renderer->doc .= '<table><tbody><tr>' . DOKU_LF;

            if ( ! empty($results)) {
                // prepare the necessary sorting arrays, as per options
                list($sort_opts, $dates) = $this->_get_sort_opts($results, $sort, $title);
                // now do the sorting
                $this->_sort_results($results, $sort_opts, $dates);
                // limit the result list length if required
                // remember: this can only be done after sorting!
                $results = ($limit > 0) ? array_slice($results, 0, $limit) : $results;
                // and finally the grouping
                if ($group) {
                    $results = $this->_group_results($results, $sort_opts, $dates);
                }

                // now render the actual result list
                $was_heading = false;
                $idx = 0;
                $col = 0;
                $rows = ceil(count($results) / $cols);  // proposed column row size
                $width = floor(100 / $cols);
                $indent_css = ($group === false) ? ' class="nogroup"' : ''; // remove indenting if not grouped
                $border_css = ($border === false) ? ' style="border-style:none;"' : '';
                $max_abstract = 0;    // needed by the abstract snippet section

                foreach ($results as $id) {
                    // are we ready to start a new column? (up to max allowed)
                    if ($col < $cols && $idx % $rows == 0) {
                        $ready_for_col = true;
                        $col++;
                    }
                    $is_heading = ($id[1] == '|');
                    if ($is_heading) {
                        list($hl, $heading) = explode('|', $id);
                        if ($proper == 'header' || $proper == 'both') $heading = $this->_proper($heading);
                    }

                    // Begin new column if: we are at the start, at a heading or if there is no grouping
                    if ($ready_for_col && ! $was_heading) {
                        // close the previous column if necessary
                        $cont_close = (!$is_heading) ? '<strong> ... </strong>' : '';
                        $cont_open = ($idx > 0 && !$is_heading) ? "<h$hl>$heading ...</h$hl>" : '';
                        $close = ($idx > 0) ? $cont_close . '</ul></td>' . DOKU_LF : '';
                        $renderer->doc .= $close . '<td' . $border_css . ' valign="top" width="' . $width . '%">' . $cont_open . DOKU_LF;
                        $ready_for_col = false;
                        $was_heading = true;    //needed to begin a new page id list
                    }
                    if ($is_heading) {
                        // close previous sub list if necessary
                        if (!$was_heading) $renderer->doc .= '</ul>' . DOKU_LF;
                        $renderer->doc .= "<h$hl>$heading</h$hl>" . DOKU_LF;
                        $was_heading = true;
                    } else {
                        // open a new sub list if necessary
                        if ($was_heading || $idx == 0) $renderer->doc .= '<ul' . $indent_css . '>';

                        // deal with normal page links
                        $link = $this->_render_wikilink($id, $proper, $title, $abstract, $max_abstract);
                        $max_abstract++;
                        $renderer->doc .= $link;
                        $was_heading = false;
                    }
                    $idx++;
                }
                $renderer->doc .= '</ul></td>';
            } else {
                // display a "no results" message if empty
                $renderer->doc .= '<td><p>' . $this->getLang("no_results") .
                                  '"<strong>' . $query . '</strong>"</p></td>' . DOKU_LF;
            }
            $renderer->doc .= '</tr>' . DOKU_LF;
            $renderer->doc .= '</tbody></table>';
            $renderer->doc .= '</div>' . DOKU_LF;
            return true;
        } else {
            return false;
        }
    }

    /**
     * Renders the page link, plus tooltip, abstract, casing, etc...
     * @param string $id
     * @param bool  $proper
     * @param bool  $title
     * @param mixed $abstract
     */
    private function _render_wikilink($id, $proper, $title, $abstract, $max_abstract) {

        $id = (strpos($id, ':') === false) ? ':' . $id : $id;   // : needed for root pages

        // does the user want to see the "title" instead "pagename"
        if ($title) {
            $value = p_get_metadata($id, 'title', true);
            $name = (empty($value)) ? $this->_proper(noNS($id)) : $value;
        } elseif ($proper == 'name' || $proper == 'both') {
            $name = $this->_proper(noNS($id));
        } else {
            $name = '';
        }

        // show the "abstract" as a tooltip
        // -or- as a nice quoted snippet ( la blockquote plugin)
        $detail = '';
        if ($abstract == 'none') {
            $link = html_wikilink($id, $name);
        } elseif ($abstract == 'tooltip' || ($abstract > 0 && $max_abstract >= $abstract)) {
            $link = $this->_html_wikilink_tooltip($id, $name);
        } elseif ($abstract == 'all' || $abstract == 0 || ($abstract > 0 && $max_abstract < $abstract)) {
            $link = html_wikilink($id, $name);
            $detail = str_replace("\n\n", '<br/>', $this->_abstract($id));
            $more = html_wikilink($id, 'more...');
            $detail = '<blockquote>' . $detail . $more . '</blockquote>' . DOKU_LF;
        }
        return '<li>' . $link . '</li>' . DOKU_LF . $detail;
    }

    private function _proper($id) {
         $id = str_replace(':', ': ', $id);
         $id = str_replace('_', ' ', $id);
         $id = ucwords($id);
         $id = str_replace(': ', ':', $id);
         return $id;
    }
    /**
     * swap normal link title (popup) for a more useful preview
     *
     * @param string $id    page id
     * @param string $name  display name
     * @return complete href link
     */
    private function _html_wikilink_tooltip($id, $name) {
        $link = html_wikilink($id, $name);
        $tooltip = $this->_abstract($id);
        $tooltip = str_replace("\n", '  ', $tooltip);
        $link = preg_replace('/title=\".+?\"/', 'title="' . $tooltip . '"', $link, 1);
        return $link;
    }

    private function _abstract($id) {
        $abstract = p_get_metadata($id, 'description abstract', true);
        $abstract = htmlspecialchars($abstract, ENT_QUOTES, 'UTF-8');
        return $abstract;
    }

    /**
     * Parse out the namespace, and convert to a regex for array search
     * -or- ensure that normal search are only within pagename not its namespace
     *
     * @param string $query user page query
     * @return processed query with regex markup as needed for namespace recognition
     */
    private function _parse_ns_query($query) {
        $incl_ns = array();
        $excl_ns = array();
        $page_qry = '';
        $tokens = explode(' ', $query);
        if (count($tokens) == 1) {
            $page_qry = $query;
        } else {
            foreach ($tokens as $token) {
                if (preg_match('/^(?:\^|-ns:)(.+)$/u', $token, $matches)) {
                    $excl_ns[] = $matches[1];
                } elseif (preg_match('/^(?:@|ns:)(.+)$/u', $token, $matches)) {
                    $incl_ns[] = $matches[1];
                } else {
                    $page_qry .= ' ' . $token;
                }
            }
        }
        $page_qry = trim($page_qry);
		if ($page_qry == '*') $page_qry = '.*';
        return array($page_qry, $incl_ns, $excl_ns);
    }

    /**
     * Builds a separate sorting array for each sortby key
     *
     * @param string    $id         wiki page id
     * @param array     $sortby     keys to use for sorting
     * @param arrayref  $sortkeys   ref to sorting arrays
     * @return void
     */
    private function _get_sort_opts($ids, $sortkeys, $title) {
        global $conf;
        $sort_opts = array();
        $dformat = array();
        $wformat = array();
        $dates = array();

        $cnt = 0;
        foreach ($ids as $id) {
            $meta = p_get_metadata ($id, false, true);
            if ( ! isset($meta['date']['modified'])) {
                $meta['date']['modified'] = $meta['date']['created'];
            }
            if ($title && isset($meta['title'])) {
                $name = strtolower($meta['title']);
            } else {
                $name = noNS($id);
            }
            $idx = 0;
            foreach ($sortkeys as $sortkey) {
                $key = $sortkey[0];
                switch ($key) {
                    case 'a':
                        $value = $this->_first($name, 1);
                        break;
                    case 'ab':
                        $value = $this->_first($name, 2);
                        break;
                    case 'abc':
                        $value = $this->_first($name, 3);
                        break;
                    case 'name':
                        $value = $name;
                        break;
                    case 'id':
                    case 'page':
                        $value = $id;
                        break;
                    case 'ns':
                        $value = getNS($id);
                        if (empty($value)) $value = '[' . $conf['start'] . ']';
                        break;
                    case 'creator':
                        $value = $meta['creator'];
                        break;
                    case 'mdate':
                        $value = $meta['date']['modified'];
                        break;
                    case 'cdate':
                        $value = $meta['date']['created'];
                        break;
                    default:
                        $dtype = $key[0];
                        if ($dtype == 'c' || $dtype == 'm') {
                            // only set date once per id (not per sort column--date remains same across columns)
                            if ( ! isset($dates[$cnt])) {
                                if ($dtype == 'c') {
                                    $date = $meta['date']['created'];
                                } else {
                                    $date = $meta['date']['modified'];
                                }
                                $dates[$cnt] = $date;
                            } else {
                                $date = $dates[$cnt];
                            }
                            // the date formats are cached on first use; limited to one per sort column/key
                            if ( ! isset($dformat[$key])) {
                                list($dformat[$key], $wformat[$key]) = $this->_date_format($key, $this->inwords);
                                $sort_opts[$idx]['inwords'] = $wformat[$key];
                            }
                            // create a string date used for sorting only
                            // (we cannot just use the date otherwise it would not group correctly)
                            $value = strftime($dformat[$key], $date);
                        }
                }
                $sort_opts[$idx]['keys'][] = $value;
                $idx++;
            }
            $cnt++;
        }
        $idx = 0;
        foreach ($sortkeys as $sortkey) {
            list($key, $opt) = $sortkey;
            // now the sort direction
            switch ($opt) {
                case 'a':
                case 'asc':
                    $dir = SORT_ASC;
                    break;
                case 'd':
                case 'desc':
                    $dir = SORT_DESC;
                    break;
                default:
                    // sort descending by default; text ascending
                    // watch for other options beginning with c or m ....!
                    if ($key[0] == 'c' || $key[0] == 'm') {
                        $dir = SORT_DESC;
                    } else {
                        $dir = SORT_ASC;
                    }
            }
            $sort_opts[$idx]['dir'] = $dir;

            // establish grouping type
            switch ($key) {
                // full-text and full dates cannot meaningfully be grouped (no duplicates!)
                case 'mdate':
                case 'cdate':
                case 'name':
                case 'id':
                case 'page':
                    $group = false;
                    break;
                case 'ns':
                    $group = 'ns';
                    break;
                default:
                    $group = true;
            }
            $sort_opts[$idx]['group'] = $group;

            // and finally set the sort array's data type (for correct markup purposes)
            $is_ns = false;
            switch ($key) {
                case 'mdate':
                case 'cdate':
                    $type = SORT_NUMERIC;
                    break;
                default:
                    $type = SORT_STRING;
            }
            $sort_opts[$idx]['type'] = $type;
            $idx++;
        }
        return array($sort_opts, $dates);
    }

    // returns first $count letters from $text
    private function _first($text, $count) {
        if ($count > 0) {
            return utf8_substr($text, 0, $count);
        }
    }

    /** parse the c|m-year-month-day option
     *
     * @param type $key
     * @param type $inwords
     * @return array $dformat, $wformat
     */
    private function _date_format($key, $inwords = false) {
        if (strpos($key, 'year') !== false) $dkey[] = '%Y';
        if (strpos($key, 'month') !== false) $dkey[] = '%m';
        if (strpos($key, 'day') !== false) $dkey[] = '%d';
        $dformat = implode('-', $dkey);
        // provide month and day format in real words if required
        // used for display only; $dformat is used for correct sorting!
        $wformat = '';
        if ($inwords) {
            switch ($dformat) {
                case '%m':
                    $wformat = "%B";
                    break;
                case '%d':
                    $wformat = "%#d, %A ";
                    break;
                case '%Y-%m':
                    $wformat = "%B %Y";
                    break;
                case '%m-%d':
                    $wformat= "%B %#d, %A ";
                    break;
                case '%Y-%m-%d':
                    $wformat = "%A, %B %#d, %Y";
                    break;
            }
        }
        return array($dformat, $wformat);
    }

    // sort by each sorting array, in order
    private function _sort_results(&$ids, &$sort_opts, &$dates) {
        if ( ! empty($sort_opts)) {
            $args = array();
            foreach ($sort_opts as &$sort_opt) {
                $args[] = &$sort_opt['keys'];
                $args[] = &$sort_opt['dir'];
                $args[] = &$sort_opt['type'];
            }
            if ( ! empty($dates)) $args[] = &$dates;
            $args[] = &$ids;
            call_user_func_array('array_multisort', $args);
        }
    }

    private function _group_results(&$ids, &$sort_opts, &$dates) {
        $prevs = array();
        $results = array();
        $level = count($sort_opts) - 1;
        $idx = 0;
        foreach($ids as $id) {
            $this->_add_heading($results, $sort_opts, $dates, $level, $idx, $prevs);
            $results[] = $id;
            $idx++;
        }
        return $results;
    }

    private function _add_heading(&$results, &$sort_opts, &$dates, $level, $idx, &$prevs) {
        if ($level > 0) {
            // recurse to find all parent headings
            $this->_add_heading($results, $sort_opts, $dates, $level - 1, $idx, $prevs);
        }
        $group = $sort_opts[$level]['group'];
        // only if this sort array can be grouped....
        if ($group === true) {
            $prev = (isset($prevs[$level])) ? $prevs[$level] : '';
            $cur = $sort_opts[$level]['keys'][$idx];
            if ($cur != $prev) {
                $prevs[$level] = $cur;
                $hl = ($level + 1);
                $inwords = $sort_opts[$level]['inwords'];
                if ($this->inwords && ! empty($inwords)) $cur = strftime($inwords, $dates[$idx]);
                $results[] = $hl . '|' . $cur;
            }
        } elseif ($group == 'ns') {
            $prev = (isset($prevs[$level])) ? $prevs[$level] : '';
            $cur = $sort_opts[$level]['keys'][$idx];
            if ($cur != $prev) {
                $prevs[$level] = $cur;
                $cur_ns = explode(':', $cur);
                $prev_ns = explode(':', $prev);
                // we only show namespaces that are different from the previous heading
                for ($i= 0; $i < count($cur_ns); $i++) {
                    if ($cur_ns[$i] != $prev_ns[$i]) {
                        $hl = $level + $i + 1;
                        $hl = ($hl > 6) ? 6 : $hl;
                        $results[] = $hl . '|' . $cur_ns[$i];
                    }
                }
            }
        }
    }


    /**
     * heavily customised version of _ft_pageLookup in inc/fulltext.php
     * I just removed the preg_quote line to enable regexes in search query...
     * and the unnecessary usort line as I have my own sort routines
     *
     */
    private function _pageLookup($query, $pageonly, $incl_ns, $excl_ns) {
        global $conf;
        
        $queries = trim($query);
        $pages = file($conf['indexdir'] . '/page.idx');
        // first deal with excluded namespaces, then included
        $pages = $this->_filter_ns($pages, $excl_ns, true);

        // now include ONLY the selected namespaces if provided
        $pages = $this->_filter_ns($pages, $incl_ns, false);

        $cnt = count($pages);
        for ($i = 0; $i < $cnt; $i++) {
            $page = $pages[$i];
            if ( ! page_exists($page) || isHiddenPage($page)) {
                unset($pages[$i]);
                continue;
            }
            if ($pageonly) $page = noNS($page);
            if (preg_match('/' . $query . '/i', $page) == 0) {
                unset($pages[$i]);
            }
        }
        if ( ! count($pages)) return array();

        $pages = array_map('trim',$pages);

        // check ACL permissions and remove any 'start' pages if req'd
        $start = $conf['start'];
        $pos = strlen($start);
        foreach($pages as $idx => $name) {
            if ($this->nostart && substr($name, -$pos) == $start) {
                unset($pages[$idx]);
            } elseif(auth_quickaclcheck(trim($pages[$idx])) < AUTH_READ){
                unset($pages[$idx]);
            } elseif ($this->maxns > 0 && (substr_count($name,':') + 1) > $this->maxns) {
                unset($pages[$idx]);    //skip this page
            }
        }
        return $pages;
    }

    private function _filter_ns($pages, $ns_qry, $exclude) {
        $invert = ($exclude) ? PREG_GREP_INVERT : 0;
        foreach ($ns_qry as $ns) {
            $regexes[] = '.*' . $ns . ':.*';
        }
        if ( ! empty($regexes)) {
            $regex = '/(' . implode('|', $regexes) . ')/';
            return array_values(preg_grep($regex, $pages, $invert));
        } else {
            return $pages;
        }
    }
}

blob
mark :50
data 1960
div.dokuwiki div#pagequery h1,
div.dokuwiki div#pagequery h2,
div.dokuwiki div#pagequery h3,
div.dokuwiki div#pagequery h4,
div.dokuwiki div#pagequery h5,
div.dokuwiki div#pagequery h6 {
    padding:0.06em 0 0.03em 0;
    margin:0;
    margin-bottom:2px;
    color:#A0A0A0;
}
div.dokuwiki div#pagequery h3,
div.dokuwiki div#pagequery h4,
div.dokuwiki div#pagequery h5,
div.dokuwiki div#pagequery h6 {
    font-weight:normal;
}
div.dokuwiki div#pagequery h1 {
    font-size:134%;
    padding:0px 0px 3px 7px;
    /*border-bottom:1px dotted #D7D5D4;*/
    background:#EDEDED;
    -moz-border-radius:6px;
    -webkit-border-radius:6px;
}
div.dokuwiki div#pagequery h2 {font-size:125%; font-weight:bold;}
div.dokuwiki div#pagequery h3 {font-size:114%;}
div.dokuwiki div#pagequery h4 {font-size:108%;}
div.dokuwiki div#pagequery h5 {font-size:100%;}
div.dokuwiki div#pagequery h6 {font-size:95%;}

div.dokuwiki div#pagequery table {
    border-collapse:collapse;
    width:99%;
}
div.dokuwiki div#pagequery td {
	border-width:1px;
	padding:8px 10px;
	border-style:solid;
	border-color:#D7D5D4;
	background-color:white;
}
div.dokuwiki div#pagequery ul {
    list-style:none;
    margin:0 0 8px 0;
	text-align:left;
}
div.dokuwiki div#pagequery ul.nogroup {
    margin:0 0 5px 3px;
}
div.dokuwiki div#pagequery li {
	padding-left:10px;
	list-style-position:inside;
	text-indent:-10px;
    line-height:135%;
}
div.dokuwiki div#pagequery a:hover,
div.dokuwiki div#pagequery blockquote a {
    text-decoration:none;
    color:#202020!important;
}
/* credit: blockquote:plugin */
div.dokuwiki div#pagequery blockquote {
    font-size:80%;
	margin: 5px 15px 10px 15px !important;
	border: 1px dotted __border__ !important;
	background: #FAFACE url(images/blockquote.gif) no-repeat 5px 5px !important;
	padding: 10px 15px 15px 18px !important;
    -moz-border-radius: 6px;
    -webkit-border-radius: 6px;
}
div.dokuwiki div#pagequery blockquote a {
    margin-left:12px;
}

blob
mark :51
data 27966
<?php
/**
 * PageQuery Plugin: search for and list pages, sorted by name, date, creator, etc
 *
 * @license    GPL 2 (http://www.gnu.org/licenses/gpl.html)
 * @author	   Symon Bent <hendrybadao@gmail.com>
 */
// must be run within Dokuwiki
if(!defined('DOKU_INC')) die();

if (!defined('DOKU_LF')) define('DOKU_LF', "\n");
if (!defined('DOKU_TAB')) define('DOKU_TAB', "\t");
if (!defined('DOKU_PLUGIN')) define('DOKU_PLUGIN',DOKU_INC.'lib/plugins/');

require_once(DOKU_PLUGIN . 'syntax.php');
require_once(DOKU_INC . 'inc/fulltext.php');
require_once(DOKU_PLUGIN . 'pagequery/inc/msort.php');

define ('NAME_KEY', 1);
define ('ID_KEY', 0);
define ('START_KEY', 2);

class syntax_plugin_pagequery extends DokuWiki_Syntax_Plugin {
    private $dformat = '';
    private $inwords = false;
    private $nostart = false;
    private $maxns = 0;

	function getType() {
		return 'substition';
	}

	function getPType() {
		return 'block';
	}

	function getSort() {
		return 98;
	}

	function connectTo($mode) {
		//Default is a word cloud style, looks good when combined with plugin:box
		$this->Lexer->addSpecialPattern('\{\{pagequery>.*?\}\}', $mode, 'plugin_pagequery');
	}
    /**
     * Parses all the pagequery options:
     * Insert the pagequery markup wherever you want your list to appear. E.g:
     *
     *   {{pagequery>}}
     *
     *   {{pagequery>[query];fulltext;sort=key:direction,key2:direction;group;limit=??;cols=?;inwords;proper}}
     *
     * Parameters as follows:
     * 1. query:    any expression directly after the >; can use all Dokuwiki search options (see manual)
     * 2. fulltext: use a full-text search, instead of page_id only [default]
     * 3. sort:     keys to sort by, in order of sorting. Each key can be followed by prefered sorting order
     *              available keys:
     *                  a, ab, abc          by 1st letter, 2 letters, or 3 letters
     *                  name                by page name (no namespace) [not grouped]
     *                  page|id             by full page id, including namespace [not grouped]
     *                  ns                  by namespace (without page name)
     *                  mdate, cdate        by modified|created dates (full) [not grouped]
     *                  m[year][month][day] by modified [year][month][day]; any combination accepted
     *                  c[year][month][day] by created [year][month][day]; any combination accepted
     *                  creator             by page author
     *              date sort default to descending, string sorts to ascending
     * 4. group:    show group headers for each change in sort keys
     *              Note: keys with no duplicated cannot be grouped (i.e. name, page|id, mdate, cdate)
     * 5. limit:    maximum number of results to return
     * 6. inwords:  use real month and day names instead of just numbers
     * 7. cols:     number of columns in displayed list (max = 6)
     * 8. proper:   display page names and namespace in Proper Case (i.e. no _'s and Capitalised)
                    header/hdr = group headers only, name = page name only, both = both!
     * 9. border:   turn on borders
     *10. fullregex:only useful on page name searches; allows a raw regex mode on the full page id
     *11. nostart:  ignore any 'start' pages in namespace (based on "config:start")
     *12. maxns:    maximum namespace level to be displayed; e.g. maxns=3 => one:two:three
     *13. title:    show 1st page heading instead of page name
     *14. abstract: should an excerpt of the wikipage be shown:
     *              use :tooltip to show as a pop-up only
     *              use :<number> to show 1st n items in list with an abstract
     *15. natsort:  use natural sorting order (good for words beginning with numbers)
     *16. case:     respect case when sorting, i.e. a != A when sorting.  a-z then A-Z (opp. to PHP term, easier on novices)
     *
     * All options are optional, and the list will default to a boring long 1-column list...
     */
	function handle($match, $state, $pos, &$handler) {
        global $conf;
        $this->dformat = $conf['dformat'];

		$match = substr($match, 12, -2); // strip markup incl. pagequery>
		$args = explode(';', $match);
        $query = $args[0];
        $fulltext = false;
        $sort = array();
        $group = false;
        $limit = 0;  //Default max items displayed. '0' => no limit
        $maxns = 0;  // Maximum no. of namespace levels to display
        $proper = 'none';
        $cols = 1;
        $border = false;
        $title = false; // use title instead of name
        $snippet = 'tooltip';
        $fullregex = false;
        $case = false;
        $natsort = false;

        foreach ($args as $arg) {
            list($key, $value) = explode('=', $arg);
            switch ($key) {
                case 'fulltext':
                    $fulltext = true;
                    break;
                case 'sort':
                    $values = explode(',', $value);
                    foreach ($values as $value) {
                        list($key, $dir) = explode(':', $value);
                        $sort[] = array($key, $dir);
                    }
                    break;
                case 'group':
                    $group = true;
                    break;
                case 'limit':
                    $limit = $value;
                    break;
                case 'maxns':
                    $maxns = $value;
                    break;
                case 'inwords':
                    $inwords = true;
                    break;
                case 'proper':
                    switch ($value) {
                        case 'hdr':
                        case 'header':
                        case 'group':
                            $proper = 'header';
                            break;
                        case 'name':
                        case 'page':
                            $proper = 'name';
                            break;
                        default:
                            $proper = 'both';
                    }
                    break;
                case 'cols':
                    $cols = ($value > 6) ? 6 : $value;
                    break;
                case 'border':
                    $border = true;
                    break;
				case 'fullregex':
					$fullregex = true;
					break;
                case 'nostart':
                    $nostart = true;
                    break;
                case 'title':
                    $title = true;
                    break;
                case 'abstract':    // old syntax, remove after some time? (2011-03-15)
                case 'snippet':
                    switch ($value) {
                        case '':
                        case 'tooltip':
                            $snippet = 'tooltip';
                            break;
                        default:
                            if ($value >= 0) {
                                $snippet = $value;
                            }
                    }
                    break;
                case 'case':
                    $case = true;
                    break;
                case 'natsort':
                    $natsort = true;
                    break;
            }
        }
		return array($query, $fulltext, $sort, $group, $limit, $maxns, $proper,
                      $cols, $inwords, $border, $fullregex, $nostart, $title,
                      $snippet, $case, $natsort);
	}

    function render($mode, &$renderer, $data) {
        $sortkeys = array();
        $incl_ns = array();
        $excl_ns = array();

        list($query, $fulltext, $sort, $group, $limit, $maxns, $proper,
              $cols, $inwords, $border, $fullregex, $nostart, $title,
              $snippet, $case, $natsort) = $data;

        if ($mode == 'xhtml') {
            // first get a raw list of matching results
            if ($fulltext) {
                $results = array_keys(ft_pageSearch($query, $highlight));
            } else {
                // allow for raw regex mode, for power users, this searches the full page id
                if ($fullregex) {
                    $pageonly = false;
                } else {
                    list($query, $incl_ns, $excl_ns) = $this->_parse_ns_query($query);
                    $pageonly = true;
                }
                $results = $this->_pageLookup($query, $pageonly, $incl_ns, $excl_ns, $nostart, $maxns);
            }

            // basic result page markup (always needed)
            $renderer->doc .= '<div id="pagequery">' . DOKU_LF;
            $renderer->doc .= '<table><tbody><tr>' . DOKU_LF;

            if ( ! empty($results)) {
                // this section is where the essential pagequery functionality happens...

                // prepare the necessary sorting arrays, as per users options
                list($sort_array, $sort_opts, $group_opts) =
                    $this->_get_options($results, $sort, $title, $proper, $inwords, $case, $natsort);

                // now do the sorting
                msort($sort_array, $sort_opts);

                // limit the result list length if required; this can only be done after sorting!
                $results = ($limit > 0) ? array_slice($results, 0, $limit) : $results;

                // and finally the grouping
                if ($group) $results = mgroup($sort_array, $group_opts);

                // now render the actual result list
                $was_heading = false;
                $cont_level = 1;
                $idx = 0;
                $col = 0;
                $rows = ceil(count($results) / $cols);  // proposed column row size
                $width = floor(100 / $cols);
                $indent_css = ($group === false) ? ' class="nogroup"' : ''; // remove indenting if not grouped
                $border_css = ($border === false) ? ' style="border-style:none;"' : '';
                $snippet_cnt = 0;    // needed by the snippet section

                foreach ($results as $line) {
                    list($level, $name, $id) = $line;

                    // are we ready to start a new column? (up to max allowed)
                    if ($col < $cols && $idx % $rows == 0) {
                        $ready_for_col = true;
                        $col++;
                    }
                    $is_heading = ($level > 0);
                    if ($is_heading) {
                        $heading = $name;
                        if ($proper == 'header' || $proper == 'both') $heading = $this->_proper($heading);
                    }
                    if ($group === false) {
                        $indent_css = ' class="nogroup"';
                    } else {
                        $indent = ($is_heading) ? $level - 1 : $cont_level - 1;
                        $indent_css = ' style="margin-left:' . $indent * 10 . 'px"';
                    }
                    // Begin new column if: we are at the start, at a heading or if there is no grouping
                    if ($ready_for_col && ! $was_heading) {
                        // close the previous column if necessary
                        $cont_close = ( ! $is_heading) ? "<h$cont_level>... </h$cont_level>" : '';
                        $cont_open = ($idx > 0 && ! $is_heading) ? "<h$cont_level$indent_css>$heading...</h$cont_level>" : '';
                        $close = ($idx > 0) ? $cont_close . '</ul></td>' . DOKU_LF : '';
                        $renderer->doc .= $close . '<td' . $border_css . ' valign="top" width="' . $width . '%">' . $cont_open . DOKU_LF;
                        $ready_for_col = false;
                        $was_heading = true;    //needed to begin a new page id list
                    }
                    if ($is_heading) {
                        // close previous sub list if necessary
                        if ( ! $was_heading) {
                            $renderer->doc .= '</ul>' . DOKU_LF;
                        }
                        $renderer->doc .= "<h$level$indent_css>$heading</h$level>" . DOKU_LF;
                        $was_heading = true;
                        $cont_level = $level + 1;
                    } else {
                        // open a new sub list if necessary
                        if ($was_heading || $idx == 0) {
                            $renderer->doc .= "<ul$indent_css>";
                        }
                        // deal with normal page links
                        $link = $this->_render_wikilink($id, $name, $snippet, $snippet_cnt);
                        $snippet_cnt++;
                        $renderer->doc .= $link;
                        $was_heading = false;
                    }
                    $idx++;
                }
                $renderer->doc .= '</ul></td>';
            } else {
                // display a "no results" message if empty
                $renderer->doc .= '<td><p>' . $this->getLang("no_results") .
                                  '"<strong>' . $query . '</strong>"</p></td>' . DOKU_LF;
            }
            $renderer->doc .= '</tr>' . DOKU_LF;
            $renderer->doc .= '</tbody></table>';
            $renderer->doc .= '</div>' . DOKU_LF;
            return true;
        } else {
            return false;
        }
    }

    /**
     * Renders the page link, plus tooltip, abstract, casing, etc...
     * @param string $id
     * @param bool  $proper
     * @param bool  $title
     * @param mixed $abstract
     */
    private function _render_wikilink($id, $name, $snippet, $snippet_cnt) {

        $id = (strpos($id, ':') === false) ? ':' . $id : $id;   // : needed for root pages

        // show the "snippet" as a tooltip
        // -or- as a nice quoted snippet ( la blockquote plugin)
        $box = '';
        if ($snippet != 'none') {
            $abstract = $this->_abstract($id);
            if ($snippet == 'tooltip' || ($snippet > 0 && $snippet_cnt >= $snippet)) {
                $link = $this->_html_wikilink_tooltip($id, $name, $abstract);
            } elseif ($snippet == 'all' || ($snippet >= 0 && $snippet_cnt < $snippet)) {
                list($link, $box) = $this->_html_wikilink_snippet($id, $name, $abstract);
            }
        } else {
            $link = html_wikilink($id, $name);
        }
        return '<li>' . $link . '</li>' . DOKU_LF . $box;
    }

    private function _proper($id) {
         $id = str_replace(':', ': ', $id);
         $id = str_replace('_', ' ', $id);
         $id = ucwords($id);
         $id = str_replace(': ', ':', $id);
         return $id;
    }
    /**
     * swap normal link title (popup) for a more useful preview
     *
     * @param string $id    page id
     * @param string $name  display name
     * @return complete href link
     */
    private function _html_wikilink_tooltip($id, $name, $tooltip) {
        $link = html_wikilink($id, $name);
        $tooltip = str_replace("\n", '  ', $tooltip);
        $link = preg_replace('/title=\".+?\"/', 'title="' . $tooltip . '"', $link, 1);
        return $link;
    }
    private function _html_wikilink_snippet($id, $name, $snippet) {
        $link = html_wikilink($id, $name);
        $detail = str_replace("\n\n", '<br/>', $snippet);
        $more = html_wikilink($id, 'more...');
        $detail = '<blockquote>' . $detail . $more . '</blockquote>' . DOKU_LF;
        return array($link, $detail);
    }

    private function _abstract($id) {
        $abstract = p_get_metadata($id, 'description abstract', true);
        $abstract = htmlspecialchars($abstract, ENT_QUOTES, 'UTF-8');
        return $abstract;
    }

    /**
     * Parse out the namespace, and convert to a regex for array search
     * -or- ensure that normal search are only within pagename not its namespace
     *
     * @param string $query user page query
     * @return processed query with regex markup as needed for namespace recognition
     */
    private function _parse_ns_query($query) {
        $incl_ns = array();
        $excl_ns = array();
        $page_qry = '';
        $tokens = explode(' ', $query);
        if (count($tokens) == 1) {
            $page_qry = $query;
        } else {
            foreach ($tokens as $token) {
                if (preg_match('/^(?:\^|-ns:)(.+)$/u', $token, $matches)) {
                    $excl_ns[] = $matches[1];
                } elseif (preg_match('/^(?:@|ns:)(.+)$/u', $token, $matches)) {
                    $incl_ns[] = $matches[1];
                } else {
                    $page_qry .= ' ' . $token;
                }
            }
        }
        $page_qry = trim($page_qry);
		if ($page_qry == '*') $page_qry = '.*';
        return array($page_qry, $incl_ns, $excl_ns);
    }

    /**
     * Builds the sorting array: adds extra items for each sorting key
     *
     * @param array     $ids        array of page ids to be sorted
     * @param array     $sortkeys   list of array keys to sort by
     * @param array     $title      use page heading instead of name for sorting
     * @return void
     */
    private function _get_options($ids, $sortkeys, $title, $proper, $inwords, $case, $natsort) {
        global $conf;

        $sort_opts = array();
        $group_opts = array();

        $dformat = array();
        $wformat = array();

        $row = 0;
        $end_col = START_KEY + count($sortkeys);

        foreach ($ids as $id) {
            $meta = p_get_metadata ($id, false, true);
            if ( ! isset($meta['date']['modified'])) {
                $meta['date']['modified'] = $meta['date']['created'];
            }
            // use page heading instead of page name
            if ($title && isset($meta['title'])) {
                $name = $meta['title'];
            } else {
                $name = noNS($id);
            }
            if ($proper == 'name' || $proper == 'both') {
                $name = $this->_proper($name);
            }
            // first column is the basic page id
            $sort_array[$row][ID_KEY] = $id;
            // second column is the display 'name' (used when sorting by 'name')
            // this also avoids rebuilding the display name when building links (DRY)
            $sort_array[$row][NAME_KEY] = $name;
            $col = START_KEY;

            foreach ($sortkeys as $sortkey) {
                $key = $sortkey[0];
                switch ($key) {
                    case 'a':
                        $value = $this->_first($name, 1);
                        break;
                    case 'ab':
                        $value = $this->_first($name, 2);
                        break;
                    case 'abc':
                        $value = $this->_first($name, 3);
                        break;
                    case 'name':
                        // a name column already exists by default (col 1)
                        continue;
                    case 'id':
                    case 'page':
                        $value = $id;
                        break;
                    case 'ns':
                        $value = getNS($id);
                        if (empty($value)) $value = '[' . $conf['start'] . ']';
                        break;
                    case 'creator':
                        $value = $meta['creator'];
                        break;
                    case 'mdate':
                        $value = $meta['date']['modified'];
                        break;
                    case 'cdate':
                        $value = $meta['date']['created'];
                        break;
                    default:
                        // date sorting types (groupable)
                        $dtype = $key[0];
                        if ($dtype == 'c' || $dtype == 'm') {
                            // we only set real date once per id (needed for grouping)
                            // not per sort column--the date should remain same across all columns
                            // this is always the last column!
                            if ($col == START_KEY) {
                                if ($dtype == 'c') {
                                    $date = $meta['date']['created'];
                                } else {
                                    $date = $meta['date']['modified'];
                                }
                                $sort_array[$row][$end_col] = $date;
                            } else {
                                $date = $sort_array[$row][$end_col] ;
                            }
                            // only set date formats once per sort column/key (not per id!)
                            if ($row == 0) {
                                $dformat[$col] = $this->_date_format($key);
                                // collect date in word format for potential use in grouping
                                if ($inwords) {
                                    $wformat[$col] = $this->_date_format_words($dformat[$col]);
                                } else {
                                    $wformat[$col] = '';
                                }
                            }
                            // create a string date used for sorting only
                            // (we cannot just use the real date otherwise it would not group correctly)
                            $value = strftime($dformat[$col], $date);
                        }
                }
                $sort_array[$row][$col] = $value;
                $col++;
            }
            $row++;
        }

        $cnt = START_KEY;
        $order = 0;
        foreach ($sortkeys as $sortkey) {
            list($key, $opt) = $sortkey;

            if ($key == 'name') {
                $col = NAME_KEY;
                // do not incease $cnt so that this col number will be re-used
                // next time through
            } else {
                $col = $cnt;
                $cnt++;
            }
            $sort_opts['key'][] = $col;

            // now the sort direction
            switch ($opt) {
                case 'a':
                case 'asc':
                    $dir = MSORT_ASC;
                    break;
                case 'd':
                case 'desc':
                    $dir = MSORT_DESC;
                    break;
                default:
                    // sort descending by default; text ascending
                    // watch for other sort options beginning with c or m ....!
                    if ($key[0] == 'c' || $key[0] == 'm') {
                        $dir = MSORT_DESC;
                    } else {
                        $dir = MSORT_ASC;
                    }
            }
            $sort_opts['dir'][] = $dir;

            // set the sort array's data type
            $is_ns = false;
            switch ($key) {
                case 'mdate':
                case 'cdate':
                    $type = MSORT_NUMERIC;
                    break;
                default:
                    if ($case) {
                        // case matters: a-z then A-Z
                        $type = ($natsort) ? MSORT_NAT : MSORT_STRING;
                    } else {
                        // case-insensitive
                        $type = ($natsort) ? MSORT_NAT_CASE : MSORT_STRING_CASE;
                    }
            }
            $sort_opts['type'][] = $type;

            // now establish grouping options
            switch ($key) {
                // full-text and full dates cannot meaningfully be grouped (no duplicates!)
                case 'mdate':
                case 'cdate':
                case 'name':
                case 'id':
                case 'page':
                    $group_by = MGROUP_NONE;
                    break;
                case 'ns':
                    $group_by = MGROUP_NAMESPACE;
                    break;
                default:
                    $group_by = MGROUP_HEADING;
            }
            if ($group_by != MGROUP_NONE) {
                $group_opts['key'][$order] = $col;
                $group_opts['type'][$order] = $group_by;
                $group_opts['dformat'][$order] = $wformat[$col];
                $order++;
            }
        }
        return array($sort_array, $sort_opts, $group_opts);
    }

    // returns first $count letters from $text
    private function _first($text, $count) {
        if ($count > 0) {
            return utf8_substr($text, 0, $count);
        }
    }

    /** parse the c|m-year-month-day option
     *
     * @param string  $key
     * @return string
     */
    private function _date_format($key) {
        if (strpos($key, 'year') !== false) $dkey[] = '%Y';
        if (strpos($key, 'month') !== false) $dkey[] = '%m';
        if (strpos($key, 'day') !== false) $dkey[] = '%d';
        $dformat = implode('-', $dkey);
        return $dformat;
    }

    /**
     * provide month and day format in real words if required
     * used for display only; $dformat is used for correct sorting!
     *
     * @param string $dformat
     * @return string
     */
    private function _date_format_words($dformat) {
        $wformat = '';
        switch ($dformat) {
            case '%m':
                $wformat = "%B";
                break;
            case '%d':
                $wformat = "%#d%A ";
                break;
            case '%Y-%m':
                $wformat = "%B %Y";
                break;
            case '%m-%d':
                $wformat= "%B %#d, %A ";
                break;
            case '%Y-%m-%d':
                $wformat = "%A, %B %#d, %Y";
                break;
        }
        return $wformat;
    }

    /**
     * a heavily customised version of _ft_pageLookup in inc/fulltext.php
     * I just removed the preg_quote line to enable regexes in search query...
     * and the unnecessary usort line as I have my own sort routines
     *
     */
    private function _pageLookup($query, $pageonly, $incl_ns, $excl_ns, $nostart = true, $maxns = 0) {
        global $conf;

        $queries = trim($query);
        $pages = file($conf['indexdir'] . '/page.idx');
        // first deal with excluded namespaces, then included
        $pages = $this->_filter_ns($pages, $excl_ns, true);

        // now include ONLY the selected namespaces if provided
        $pages = $this->_filter_ns($pages, $incl_ns, false);

        $cnt = count($pages);
        for ($i = 0; $i < $cnt; $i++) {
            $page = $pages[$i];
            if ( ! page_exists($page) || isHiddenPage($page)) {
                unset($pages[$i]);
                continue;
            }
            if ($pageonly) $page = noNS($page);
            if (preg_match('/' . $query . '/i', $page) == 0) {
                unset($pages[$i]);
            }
        }
        if ( ! count($pages)) return array();

        $pages = array_map('trim',$pages);

        // check ACL permissions and remove any 'start' pages if req'd
        $start = $conf['start'];
        $pos = strlen($start);
        foreach($pages as $idx => $name) {
            if ($this->nostart && substr($name, -$pos) == $start) {
                unset($pages[$idx]);
            } elseif(auth_quickaclcheck(trim($pages[$idx])) < AUTH_READ){
                unset($pages[$idx]);
            } elseif ($this->maxns > 0 && (substr_count($name,':') + 1) > $this->maxns) {
                unset($pages[$idx]);    //skip this page
            }
        }
        return $pages;
    }

    private function _filter_ns($pages, $ns_qry, $exclude) {
        $invert = ($exclude) ? PREG_GREP_INVERT : 0;
        foreach ($ns_qry as $ns) {
            $regexes[] = '.*' . $ns . ':.*';
        }
        if ( ! empty($regexes)) {
            $regex = '/(' . implode('|', $regexes) . ')/';
            return array_values(preg_grep($regex, $pages, $invert));
        } else {
            return $pages;
        }
    }
}

blob
mark :52
data 10845
<?php
// keep key associations
define('MSORT_KEEP_ASSOC', 'msort01');

// additional sorting type
define('MSORT_NUMERIC', 'msort02');
define('MSORT_REGULAR', 'msort03');
define('MSORT_STRING', 'msort04');
define('MSORT_STRING_CASE', 'msort05'); // case insensitive (PHP style!)
define('MSORT_NAT', 'msort06');
define('MSORT_NAT_CASE', 'msort07');    // case insensitive (PHP style!)

define('MSORT_ASC', 'msort08');
define('MSORT_DESC', 'msort09');

define('MSORT_DEFAULT_DIRECTION', MSORT_ASC);
define('MSORT_DEFAULT_TYPE', MSORT_STRING);

/**
 * a replacement for array_mulitsort which permits natural and caseless sorting
 * this function will sort an 'array of rows' only (not array of 'columns')
 *
 * @param array $sort_array  : multi-dimensional array of arrays, where the first index refers to the row number
 *                             and the second to the column number (e.g. $array[row_number][column_number])
 *                             i.e. = array(
 *                                          array('name1', 'job1', 'start_date1', 'rank1'),
 *                                          array('name2', 'job2', 'start_date2', 'rank2'),
 *                                          ...
 *                                          );
 *
 * @param mixed $sort_opts   : options for how the array should be sorted
 *                   : AS ARGS
 *                             $key, $type, $direction [,$key2, $type2, $direction2, ...etc], $assoc
 *                             $key      = key/column to sort by
 *                             $type     = sorting type, one of following:
 *                                           MSORT_NUMERIC
 *                                           MSORT_REGULAR
 *                                           MSORT_STRING
 *                                           MSORT_STRING_CASE  : caseless sorting
 *                                           MSORT_NAT          : natural sorting
 *                                           MSORT_NAT_CASE
 *                             $direction = sorting direction:
 *                                           MSORT_ASC
 *                                           MSORT_DESC
 *                             $assoc     = keep associative array keys (uasort)
 *                                           MSORT_KEEP_ASSOC
 *                    :AS ARRAY
 *                             $sort_opts['key'][<column>] = 'key'
 *                             $sort_opts['type'][<column>] = 'type'
 *                             $sort_opts['dir'][<column>] = 'dir'
 *                             $sort_opts['assoc'][<column>] = MSORT_KEEP_ASSOC | true
 * @return boolean
 */

function msort(&$sort_array, $sort_opts) {

    // if a full sort_opts array was passed
    if (is_array($sort_opts)) {
        if (isset($sort_opts['assoc'])) {
            $keep_assoc = true;
        }
    // else separate the options from the function args
    } else {
        $args = func_get_args();

        if (end($args) == MSORT_KEEP_ASSOC) {
            $keep_assoc = true;
            array_pop($args);
        }

        // make sure there is something to sort
        if (empty($args)) return true;

        $type_enums = array(
                           MSORT_NUMERIC,
                           MSORT_REGULAR,
                           MSORT_STRING,
                           MSORT_STRING_CASE,
                           MSORT_NAT,
                           MSORT_NAT_CASE
                           );
        $direction_enums = array(
                                MSORT_ASC,
                                MSORT_DESC
                                );

        // work through the args list (SORT_KEY, SORT_TYPE, SORT_DIRECTION)
        $order = -1;
        foreach ($args as $arg) {
            // is it a sort direction?
            if (in_array($arg, $direction_enums)) {
                $sort_opts['dir'][$order] = $arg;
            // is it a sort type?
            } elseif (in_array($arg, $type_enums)) {
                $sort_opts['type'][$order] = $arg;
            // is it a sort array?
            } elseif (is_numeric($arg)) {
                $order++;
                $sort_opts['key'][$order] = $arg;
                $sort_opts['type'][$order] = MSORT_DEFAULT_TYPE;
                $sort_opts['dir'][$order] = MSORT_DEFAULT_DIRECTION;
            }
        }
    }

    // Determine which u..sort function (with or without associations).
    $sort_func = ($keep_assoc) ? 'uasort' : 'usort';

    // Sort the data and get the result.
    $result = $sort_func (
        $sort_array,
        function(array &$left, array &$right) use($sort_opts) {

            // Assume that the entries are the same.
            $cmp = 0;

            // Work through each sort column
            foreach($sort_opts['key'] as $idx => $key) {

                // Handle the different sort types.
                switch ($sort_opts['type'][$idx]) {
                    case MSORT_NUMERIC:
                        $key_cmp = ((intval($left[$key]) == intval($right[$key])) ? 0 :
                                   ((intval($left[$key]) < intval($right[$key])) ? -1 : 1 ) );
                        break;

                    case MSORT_STRING:
                        $key_cmp = strcmp((string)$left[$key], (string)$right[$key]);
                        break;

                    case MSORT_STRING_CASE: //case-insensitive
                        $key_cmp = strcasecmp((string)$left[$key], (string)$right[$key]);
                        break;

                    case MSORT_NAT:
                        $key_cmp = strnatcmp((string)$left[$key], (string)$right[$key]);
                        break;

                    case MSORT_NAT_CASE:    //case-insensitive
                        $key_cmp = strnatcasecmp((string)$left[$key], (string)$right[$key]);
                        break;

                    case MSORT_REGULAR:
                    default :
                        $key_cmp = (($left[$key] == $right[$key]) ? 0 :
                                   (($left[$key] < $right[$key]) ? -1 : 1 ) );
                    break;
                }

                // Is the column in the two arrays the same?
                if ($key_cmp == 0) {
                    continue;
                }

                // Are we sorting descending?
                $cmp = $key_cmp * (($sort_opts['dir'][$idx] == MSORT_DESC) ? -1 : 1);

                // no need for remaining keys as there was a difference
                break;
            }
            return $cmp;
        }
    );
	return $result;
}



// grouping types
define ('MGRUP_NONE', 'mgrp00');
define ('MGROUP_HEADING', 'mgrp01');
define ('MGROUP_NAMESPACE', 'mgrp02');

/**
 * group a multi-dimensional array by each level heading
 * @param array $sort_array : array to be grouped (result of 'msort' function)
 *                             last column should contain real dates if you need dates in words
 * @param mixed $group_opts :
 *                    AS ARGS:
 *                             key, type, dformat [,order, type, dformat]... [,real_dates]
 *                              key      = group by key/column
 *                              type     = one of the MGROUP types
 *                              dformat  = date format (if used)
 *                   AS ARRAY:
 *                             $group_opts['key'][<order>] = column key to group by
 *                             $group_opts['type'][<order>] = grouping type [MGROUP...]
 *                             $group_opts['dformat'][<order>] = date formatting string
 *
 * @return array $results   : array of array(level, first array item), e.g. array(1, 'Main Title')
 *                              array(0, '...') =>  0 = normal row item (not heading)
 */
function mgroup(&$sort_array, $group_opts) {

    // if complete option array was provided
    if (is_array($group_opts)) {
        $level = count($group_opts['key']) - 1;

    // if not presume the above, one-by-one format
    } else {
        $args = func_get_args();

        $type_enums = array(
                            MGROUP_HEADING,
                            MGROUP_NAMESPACE,
                            );

        // get all the grouping options
        // order (which key/column), type (grouping type see MGROUP_...), dformat (real date display format),... repeated
        $group_opts = array();
        $order = -1;
        foreach ($args as $arg) {
            if (is_numeric($arg)) {
                $order++;
                $group_opts['key'][$order] = $arg;
                $group_opts['type'] [$order]= MGROUP_HEADING; // defaults
                $group_opts['dformat'] [$order]= '';
            } elseif ($order > -1) {
                if (in_array($arg, $type_enums)) {
                    $group_opts['type'][$order] = $arg;
                } else {
                    $group_opts['dformat'][$order] = $arg;
                }
            }
        }
        $level = $order;
    }

    $prevs = array();
    $results = array();
    $idx = 0;

    foreach($sort_array as $row) {
        _add_heading($results, $sort_array, $group_opts, $level, $idx, $prevs);
        $results[] = array(0, $row[NAME_KEY], $row[ID_KEY]);
        $idx++;
    }
    return $results;
}

/**
 * private function used by mgroup only!
 */
function _add_heading(&$results, &$sort_array, &$group_opts, $level, $idx, &$prevs) {
    static $end_col = 0;

    // recurse to find all parent headings
    if ($level > 0) {
        _add_heading($results, $sort_array, $group_opts, $level - 1, $idx, $prevs);
    }
    $group_type = $group_opts['type'][$level];

    $prev = (isset($prevs[$level])) ? $prevs[$level] : '';
    $key = $group_opts['key'][$level];
    $cur = $sort_array[$idx][$key];
    if ($cur != $prev) {
        $prevs[$level] = $cur;

        if ($group_type === MGROUP_HEADING) {
            $date_format = $group_opts['dformat'][$level];
            if ( ! empty($date_format)) {
                // the real date is always the last column (or item in array row)
                // static is used to avoid checking array length repeatedly
                if ($end_col == 0) $end_col = count($sort_array[0]) - 1;
                $cur = strftime($date_format, $sort_array[$idx][$end_col]);
            }
            $results[] = array($level + 1, $cur, '');

        } elseif ($group_type === MGROUP_NAMESPACE) {
            $cur_ns = explode(':', $cur);
            $prev_ns = explode(':', $prev);
            // only show namespaces that are different from the previous heading
            for ($i= 0; $i < count($cur_ns); $i++) {
                if ($cur_ns[$i] != $prev_ns[$i]) {
                    $hl = $level + $i + 1;
                    $results[] = array($hl , $cur_ns[$i], '');
                }
            }
        }
    }
}
?>
blob
mark :56
data 485
<?php
/**
 * English language file
 *
 * @license    GPL 2 (http://www.gnu.org/licenses/gpl.html)
 * @author     Symon Bent <symonbent@gmail.com>
 */

// custom language strings for the pagequery plugin
$lang['no_results']   = 'No results for the search query: ';
$lang['jump_section'] = 'Continue with the  %1$s  section at the top...'; // '%1$s' will be replaced by the relevant heading
$lang['jump_to_top']  = 'Back to top of this page list';
$lang['link_to_top']  = 'Top ';

blob
mark :57
data 2111
div.dokuwiki div#pagequery {
    position:relative;
}

div.dokuwiki div#pagequery h1,
div.dokuwiki div#pagequery h2,
div.dokuwiki div#pagequery h3,
div.dokuwiki div#pagequery h4,
div.dokuwiki div#pagequery h5,
div.dokuwiki div#pagequery h6 {
    padding:0.06em 0 0.03em 0;
    margin:0;
    margin-bottom:2px;
    color:#A0A0A0;
}
div.dokuwiki div#pagequery h3,
div.dokuwiki div#pagequery h4,
div.dokuwiki div#pagequery h5,
div.dokuwiki div#pagequery h6 {
    font-weight:normal;
}
div.dokuwiki div#pagequery h1 {
    font-size:134%;
    padding:0px 0px 3px 7px;
    background:#EDEDED;
    -moz-border-radius:6px;
    -webkit-border-radius:6px;
}
div.dokuwiki div#pagequery h2 {font-size:125%; font-weight:bold;}
div.dokuwiki div#pagequery h3 {font-size:114%;}
div.dokuwiki div#pagequery h4 {font-size:108%;}
div.dokuwiki div#pagequery h5 {font-size:100%;}
div.dokuwiki div#pagequery h6 {font-size:95%;}

div.dokuwiki div#pagequery table {
    border-collapse:collapse;
    width:99%;
}
div.dokuwiki div#pagequery td {
	border-width:1px;
	padding:8px 10px;
	border-style:solid;
	border-color:#D7D5D4;
	background-color:white;
}
div.dokuwiki div#pagequery ul {
    list-style:none;
    margin:0 0 8px 0;
	text-align:left;
}
div.dokuwiki div#pagequery ul.nogroup {
    margin:0 0 5px 3px;
}
div.dokuwiki div#pagequery li {
	padding-left:10px;
	list-style-position:inside;
	text-indent:-10px;
    line-height:135%;
}
div.dokuwiki div#pagequery a:hover,
div.dokuwiki div#pagequery blockquote a {
    text-decoration:none;
    color:#202020!important;
}
div.dokuwiki div#pagequery a.top {
    position:absolute;
    bottom:1.2em;;
    right:1.2em;
    font-style:italic;
    color:#A0A0A0;
}
/* credit: blockquote:plugin */
div.dokuwiki div#pagequery blockquote {
    font-size:80%;
	margin: 5px 15px 10px 15px !important;
	border: 1px dotted __border__ !important;
	background: #FAFACE url(images/blockquote.gif) no-repeat 5px 5px !important;
	padding: 10px 15px 15px 18px !important;
    -moz-border-radius: 6px;
    -webkit-border-radius: 6px;
}
div.dokuwiki div#pagequery blockquote a {
    margin-left:12px;
}

blob
mark :58
data 28742
<?php
/**
 * PageQuery Plugin: search for and list pages, sorted/grouped by name, date, creator, etc
 *
 * @license    GPL 2 (http://www.gnu.org/licenses/gpl.html)
 * @author	   Symon Bent <hendrybadao@gmail.com>
 */
// must be run within Dokuwiki
if(!defined('DOKU_INC')) die();

if (!defined('DOKU_LF')) define('DOKU_LF', "\n");
if (!defined('DOKU_TAB')) define('DOKU_TAB', "\t");
if (!defined('DOKU_PLUGIN')) define('DOKU_PLUGIN',DOKU_INC.'lib/plugins/');

require_once(DOKU_PLUGIN . 'syntax.php');
require_once(DOKU_INC . 'inc/fulltext.php');
require_once(DOKU_PLUGIN . 'pagequery/inc/msort.php');

define ('NAME_KEY', 1);
define ('ID_KEY', 0);
define ('START_KEY', 2);

class syntax_plugin_pagequery extends DokuWiki_Syntax_Plugin {
    private $dformat = '';
    private $inwords = false;
    private $nostart = false;
    private $maxns = 0;

	function getType() {
		return 'substition';
	}

	function getPType() {
		return 'block';
	}

	function getSort() {
		return 98;
	}

	function connectTo($mode) {
		//Default is a word cloud style, looks good when combined with plugin:box
		$this->Lexer->addSpecialPattern('\{\{pagequery>.*?\}\}', $mode, 'plugin_pagequery');
	}
    /**
     * Parses all the pagequery options:
     * Insert the pagequery markup wherever you want your list to appear. E.g:
     *
     *   {{pagequery>}}
     *
     *   {{pagequery>[query];fulltext;sort=key:direction,key2:direction;group;limit=??;cols=?;inwords;proper}}
     *
     * Parameters as follows:
     * 1. query:    any expression directly after the >; can use all Dokuwiki search options (see manual)
     * 2. fulltext: use a full-text search, instead of page_id only [default]
     * 3. sort:     keys to sort by, in order of sorting. Each key can be followed by prefered sorting order
     *              available keys:
     *                  a, ab, abc          by 1st letter, 2 letters, or 3 letters
     *                  name                by page name (no namespace) [not grouped]
     *                  page|id             by full page id, including namespace [not grouped]
     *                  ns                  by namespace (without page name)
     *                  mdate, cdate        by modified|created dates (full) [not grouped]
     *                  m[year][month][day] by modified [year][month][day]; any combination accepted
     *                  c[year][month][day] by created [year][month][day]; any combination accepted
     *                  creator             by page author
     *              date sort default to descending, string sorts to ascending
     * 4. group:    show group headers for each change in sort keys
     *              Note: keys with no duplicated cannot be grouped (i.e. name, page|id, mdate, cdate)
     * 5. limit:    maximum number of results to return
     * 6. inwords:  use real month and day names instead of just numbers
     * 7. cols:     number of columns in displayed list (max = 6)
     * 8. proper:   display page names and namespace in Proper Case (i.e. no _'s and Capitalised)
                    header/hdr = group headers only, name = page name only, both = both!
     * 9. border:   turn on borders
     *10. fullregex:only useful on page name searches; allows a raw regex mode on the full page id
     *11. nostart:  ignore any 'start' pages in namespace (based on "config:start")
     *12. maxns:    maximum namespace level to be displayed; e.g. maxns=3 => one:two:three
     *13. title:    show 1st page heading instead of page name
     *14. abstract: should an excerpt of the wikipage be shown:
     *              use :tooltip to show as a pop-up only
     *              use :<number> to show 1st n items in list with an abstract
     *15. natsort:  use natural sorting order (good for words beginning with numbers)
     *16. case:     respect case when sorting, i.e. a != A when sorting.  a-z then A-Z (opp. to PHP term, easier on novices)
     *
     * All options are optional, and the list will default to a boring long 1-column list...
     */
	function handle($match, $state, $pos, &$handler) {
        global $conf;
        $this->dformat = $conf['dformat'];

		$match = substr($match, 12, -2); // strip markup incl. pagequery>
		$args = explode(';', $match);
        $query = $args[0];
        $fulltext = false;
        $sort = array();
        $group = false;
        $limit = 0;  //Default max items displayed. '0' => no limit
        $maxns = 0;  // Maximum no. of namespace levels to display
        $proper = 'none';
        $cols = 1;
        $border = false;
        $title = false; // use title instead of name
        $snippet = 'tooltip';
        $fullregex = false;
        $case = false;
        $natsort = false;

        foreach ($args as $arg) {
            list($key, $value) = explode('=', $arg);
            switch ($key) {
                case 'fulltext':
                    $fulltext = true;
                    break;
                case 'sort':
                    $values = explode(',', $value);
                    foreach ($values as $value) {
                        list($key, $dir) = explode(':', $value);
                        $sort[] = array($key, $dir);
                    }
                    break;
                case 'group':
                    $group = true;
                    break;
                case 'limit':
                    $limit = $value;
                    break;
                case 'maxns':
                    $maxns = $value;
                    break;
                case 'inwords':
                    $inwords = true;
                    break;
                case 'proper':
                    switch ($value) {
                        case 'hdr':
                        case 'header':
                        case 'group':
                            $proper = 'header';
                            break;
                        case 'name':
                        case 'page':
                            $proper = 'name';
                            break;
                        default:
                            $proper = 'both';
                    }
                    break;
                case 'cols':
                    $cols = ($value > 6) ? 6 : $value;
                    break;
                case 'border':
                    $border = true;
                    break;
				case 'fullregex':
					$fullregex = true;
					break;
                case 'nostart':
                    $nostart = true;
                    break;
                case 'title':
                    $title = true;
                    break;
                case 'abstract':    // old syntax, remove after some time? (2011-03-15)
                case 'snippet':
                    switch ($value) {
                        case '':
                        case 'tooltip':
                            $snippet = 'tooltip';
                            break;
                        default:
                            if ($value >= 0) {
                                $snippet = $value;
                            }
                    }
                    break;
                case 'case':
                    $case = true;
                    break;
                case 'natsort':
                    $natsort = true;
                    break;
            }
        }
		return array($query, $fulltext, $sort, $group, $limit, $maxns, $proper,
                      $cols, $inwords, $border, $fullregex, $nostart, $title,
                      $snippet, $case, $natsort);
	}

    function render($mode, &$renderer, $data) {
        $sortkeys = array();
        $incl_ns = array();
        $excl_ns = array();

        list($query, $fulltext, $sort, $group, $limit, $maxns, $proper,
              $cols, $inwords, $border, $fullregex, $nostart, $title,
              $snippet, $case, $natsort) = $data;

        if ($mode == 'xhtml') {
            // first get a raw list of matching results
            if ($fulltext) {
                $results = array_keys(ft_pageSearch($query, $highlight));
            } else {
                // allow for raw regex mode, for power users, this searches the full page id
                if ($fullregex) {
                    $pageonly = false;
                } else {
                    list($query, $incl_ns, $excl_ns) = $this->_parse_ns_query($query);
                    $pageonly = true;
                }
                $results = $this->_pageLookup($query, $pageonly, $incl_ns, $excl_ns, $nostart, $maxns);
            }

            // basic result page markup (always needed)
            $renderer->doc .= '<div id="pagequery">' . DOKU_LF;
            $renderer->doc .= '<table><tbody><tr>' . DOKU_LF;

            if ( ! empty($results)) {
                // this section is where the essential pagequery functionality happens...

                // prepare the necessary sorting arrays, as per users options
                list($sort_array, $sort_opts, $group_opts) =
                    $this->_get_options($results, $sort, $title, $proper, $inwords, $case, $natsort);

                // now do the sorting
                msort($sort_array, $sort_opts);

                // limit the result list length if required; this can only be done after sorting!
                $results = ($limit > 0) ? array_slice($results, 0, $limit) : $results;

                // and finally the grouping
                if ($group) $results = mgroup($sort_array, $group_opts);

                // now render the actual result list
                $was_heading = false;
                $cont_level = 1;
                $idx = 0;
                $col = 0;
                $rows = ceil(count($results) / $cols);  // proposed column row size
                $width = floor(100 / $cols);
                $indent_css = ($group === false) ? ' class="nogroup"' : ''; // remove indenting if not grouped
                $border_css = ($border === false) ? ' style="border-style:none;"' : '';
                $snippet_cnt = 0;    // needed by the snippet section
                $jump_txt= $this->getLang('jump_section');

                foreach ($results as $line) {
                    list($level, $name, $id) = $line;

                    // are we ready to start a new column? (up to max allowed)
                    if ($col < $cols && $idx % $rows == 0) {
                        $ready_for_col = true;
                        $col++;
                    }
                    $is_heading = ($level > 0);
                    if ($is_heading) {
                        $heading = $name;
                        if ($proper == 'header' || $proper == 'both') $heading = $this->_proper($heading);
                    }
                    if ($group === false) {
                        $indent_css = ' class="nogroup"';
                    } else {
                        $indent = ($is_heading) ? $level - 1 : $cont_level - 1;
                        $indent_css = ' style="margin-left:' . $indent * 10 . 'px"';
                    }
                    // Begin new column if: 1.we are at the start, 2.at a heading or 3.if there is no grouping
                    if ($ready_for_col && ! $was_heading) {
                        $top_id = 'top-' . mt_rand();
                        $jump_tip = sprintf($jump_txt, $heading);
                        // close the previous column if necessary; also add a 'jump to anchor'
                        $cont_close = ( ! $is_heading) ? '<a title="'. $jump_tip . '" href="#' .
                                        $top_id . '">' . "<h$cont_level>... </h$cont_level></a>" : '';
                        $cont_open = ($idx > 0 && ! $is_heading) ? "<h$cont_level$indent_css" .
                                        ' id="' . $top_id . '">' . "$heading...</h$cont_level>" : '';
                        $close = ($idx > 0) ? $cont_close . '</ul></td>' . DOKU_LF : '';
                        $renderer->doc .= $close . '<td' . $border_css . ' valign="top" width="' . $width . '%">' . $cont_open . DOKU_LF;
                        $ready_for_col = false;
                        $was_heading = true;    //needed to begin a new page id list
                    }
                    if ($is_heading) {
                        // close previous sub list if necessary
                        if ( ! $was_heading) {
                            $renderer->doc .= '</ul>' . DOKU_LF;
                        }
                        $renderer->doc .= "<h$level$indent_css>$heading</h$level>" . DOKU_LF;
                        $was_heading = true;
                        $cont_level = $level + 1;
                    } else {
                        // open a new sub list if necessary
                        if ($was_heading || $idx == 0) {
                            $renderer->doc .= "<ul$indent_css>";
                        }
                        // deal with normal page links
                        $link = $this->_render_wikilink($id, $name, $snippet, $snippet_cnt);
                        $snippet_cnt++;
                        $renderer->doc .= $link;
                        $was_heading = false;
                    }
                    $idx++;
                }
                $renderer->doc .= '</ul></td>';
            } else {
                // display a "no results" message if empty
                $renderer->doc .= '<td><p>' . $this->getLang("no_results") .
                                  '"<strong>' . $query . '</strong>"</p></td>' . DOKU_LF;
            }
            $renderer->doc .= '</tr>' . DOKU_LF;
            $renderer->doc .= '</tbody></table>';
            $renderer->doc .= '<a class="top" href="#' . $top_id . '">' . $this->getLang('link_to_top') . '</a>';
            $renderer->doc .= '</div>' . DOKU_LF;
            return true;
        } else {
            return false;
        }
    }

    /**
     * Renders the page link, plus tooltip, abstract, casing, etc...
     * @param string $id
     * @param bool  $proper
     * @param bool  $title
     * @param mixed $abstract
     */
    private function _render_wikilink($id, $name, $snippet, $snippet_cnt) {

        $id = (strpos($id, ':') === false) ? ':' . $id : $id;   // : needed for root pages

        // show the "snippet" as a tooltip
        // -or- as a nice quoted snippet ( la blockquote plugin)
        $box = '';
        if ($snippet != 'none') {
            $abstract = $this->_abstract($id);
            if ($snippet == 'tooltip' || ($snippet > 0 && $snippet_cnt >= $snippet)) {
                $link = $this->_html_wikilink_tooltip($id, $name, $abstract);
            } elseif ($snippet == 'all' || ($snippet >= 0 && $snippet_cnt < $snippet)) {
                list($link, $box) = $this->_html_wikilink_snippet($id, $name, $abstract);
            }
        } else {
            $link = html_wikilink($id, $name);
        }
        return '<li>' . $link . '</li>' . DOKU_LF . $box;
    }

    private function _proper($id) {
         $id = str_replace(':', ': ', $id);
         $id = str_replace('_', ' ', $id);
         $id = ucwords($id);
         $id = str_replace(': ', ':', $id);
         return $id;
    }
    /**
     * swap normal link title (popup) for a more useful preview
     *
     * @param string $id    page id
     * @param string $name  display name
     * @return complete href link
     */
    private function _html_wikilink_tooltip($id, $name, $tooltip) {
        $link = html_wikilink($id, $name);
        $tooltip = str_replace("\n", '  ', $tooltip);
        $link = preg_replace('/title=\".+?\"/', 'title="' . $tooltip . '"', $link, 1);
        return $link;
    }
    private function _html_wikilink_snippet($id, $name, $snippet) {
        $link = html_wikilink($id, $name);
        $detail = str_replace("\n\n", '<br/>', $snippet);
        $more = html_wikilink($id, 'more...');
        $detail = '<blockquote>' . $detail . $more . '</blockquote>' . DOKU_LF;
        return array($link, $detail);
    }

    private function _abstract($id) {
        $abstract = p_get_metadata($id, 'description abstract', true);
        $abstract = htmlspecialchars($abstract, ENT_QUOTES, 'UTF-8');
        return $abstract;
    }

    /**
     * Parse out the namespace, and convert to a regex for array search
     * -or- ensure that normal search are only within pagename not its namespace
     *
     * @param string $query user page query
     * @return processed query with regex markup as needed for namespace recognition
     */
    private function _parse_ns_query($query) {
        $incl_ns = array();
        $excl_ns = array();
        $page_qry = '';
        $tokens = explode(' ', $query);
        if (count($tokens) == 1) {
            $page_qry = $query;
        } else {
            foreach ($tokens as $token) {
                if (preg_match('/^(?:\^|-ns:)(.+)$/u', $token, $matches)) {
                    $excl_ns[] = $matches[1];
                } elseif (preg_match('/^(?:@|ns:)(.+)$/u', $token, $matches)) {
                    $incl_ns[] = $matches[1];
                } else {
                    $page_qry .= ' ' . $token;
                }
            }
        }
        $page_qry = trim($page_qry);
		if ($page_qry == '*') $page_qry = '.*';
        return array($page_qry, $incl_ns, $excl_ns);
    }

    /**
     * Builds the sorting array: adds extra items for each sorting key
     *
     * @param array     $ids        array of page ids to be sorted
     * @param array     $sortkeys   list of array keys to sort by
     * @param bool      $title      use page heading instead of name for sorting
     * @param bool      $proper     use proper case where possible
     * @param bool      $inwords    show dates in words where possible
     * @param bool      $case       honour case when sorting
     * @param bool      $natsort    natural sorting, the human way
     * @return void
     */
    private function _get_options($ids, $sortkeys, $title, $proper, $inwords, $case, $natsort) {
        global $conf;

        $sort_opts = array();
        $group_opts = array();

        $dformat = array();
        $wformat = array();

        $row = 0;
        $end_col = START_KEY + count($sortkeys);

        foreach ($ids as $id) {
            $meta = p_get_metadata ($id, false, true);
            if ( ! isset($meta['date']['modified'])) {
                $meta['date']['modified'] = $meta['date']['created'];
            }
            // use page heading instead of page name
            if ($title && isset($meta['title'])) {
                $name = $meta['title'];
            } else {
                $name = noNS($id);
            }
            if ($proper == 'name' || $proper == 'both') {
                $name = $this->_proper($name);
            }
            // first column is the basic page id
            $sort_array[$row][ID_KEY] = $id;
            // second column is the display 'name' (used when sorting by 'name')
            // this also avoids rebuilding the display name when building links (DRY)
            $sort_array[$row][NAME_KEY] = $name;
            $col = START_KEY;

            foreach ($sortkeys as $sortkey) {
                $key = $sortkey[0];
                switch ($key) {
                    case 'a':
                        $value = $this->_first($name, 1);
                        break;
                    case 'ab':
                        $value = $this->_first($name, 2);
                        break;
                    case 'abc':
                        $value = $this->_first($name, 3);
                        break;
                    case 'name':
                        // a name column already exists by default (col 1)
                        continue;
                    case 'id':
                    case 'page':
                        $value = $id;
                        break;
                    case 'ns':
                        $value = getNS($id);
                        if (empty($value)) $value = '[' . $conf['start'] . ']';
                        break;
                    case 'creator':
                        $value = $meta['creator'];
                        break;
                    case 'mdate':
                        $value = $meta['date']['modified'];
                        break;
                    case 'cdate':
                        $value = $meta['date']['created'];
                        break;
                    default:
                        // date sorting types (groupable)
                        $dtype = $key[0];
                        if ($dtype == 'c' || $dtype == 'm') {
                            // we only set real date once per id (needed for grouping)
                            // not per sort column--the date should remain same across all columns
                            // this is always the last column!
                            if ($col == START_KEY) {
                                if ($dtype == 'c') {
                                    $date = $meta['date']['created'];
                                } else {
                                    $date = $meta['date']['modified'];
                                }
                                $sort_array[$row][$end_col] = $date;
                            } else {
                                $date = $sort_array[$row][$end_col] ;
                            }
                            // only set date formats once per sort column/key (not per id!)
                            if ($row == 0) {
                                $dformat[$col] = $this->_date_format($key);
                                // collect date in word format for potential use in grouping
                                if ($inwords) {
                                    $wformat[$col] = $this->_date_format_words($dformat[$col]);
                                } else {
                                    $wformat[$col] = '';
                                }
                            }
                            // create a string date used for sorting only
                            // (we cannot just use the real date otherwise it would not group correctly)
                            $value = strftime($dformat[$col], $date);
                        }
                }
                $sort_array[$row][$col] = $value;
                $col++;
            }
            $row++;
        }

        $cnt = START_KEY;
        $order = 0;
        foreach ($sortkeys as $sortkey) {
            list($key, $opt) = $sortkey;

            if ($key == 'name') {
                $col = NAME_KEY;
                // do not incease $cnt so that this col number will be re-used
                // next time through
            } else {
                $col = $cnt;
                $cnt++;
            }
            $sort_opts['key'][] = $col;

            // now the sort direction
            switch ($opt) {
                case 'a':
                case 'asc':
                    $dir = MSORT_ASC;
                    break;
                case 'd':
                case 'desc':
                    $dir = MSORT_DESC;
                    break;
                default:
                    // sort descending by default; text ascending
                    // watch for other sort options beginning with c or m ....!
                    if ($key[0] == 'c' || $key[0] == 'm') {
                        $dir = MSORT_DESC;
                    } else {
                        $dir = MSORT_ASC;
                    }
            }
            $sort_opts['dir'][] = $dir;

            // set the sort array's data type
            $is_ns = false;
            switch ($key) {
                case 'mdate':
                case 'cdate':
                    $type = MSORT_NUMERIC;
                    break;
                default:
                    if ($case) {
                        // case matters: a-z then A-Z
                        $type = ($natsort) ? MSORT_NAT : MSORT_STRING;
                    } else {
                        // case-insensitive
                        $type = ($natsort) ? MSORT_NAT_CASE : MSORT_STRING_CASE;
                    }
            }
            $sort_opts['type'][] = $type;

            // now establish grouping options
            switch ($key) {
                // name strings and full dates cannot be meaningfully grouped (no duplicates!)
                case 'mdate':
                case 'cdate':
                case 'name':
                case 'id':
                case 'page':
                    $group_by = MGROUP_NONE;
                    break;
                case 'ns':
                    $group_by = MGROUP_NAMESPACE;
                    break;
                default:
                    $group_by = MGROUP_HEADING;
            }
            if ($group_by != MGROUP_NONE) {
                $group_opts['key'][$order] = $col;
                $group_opts['type'][$order] = $group_by;
                $group_opts['dformat'][$order] = $wformat[$col];
                $order++;
            }
        }
        return array($sort_array, $sort_opts, $group_opts);
    }

    // returns first $count letters from $text
    private function _first($text, $count) {
        if ($count > 0) {
            return utf8_substr($text, 0, $count);
        }
    }

    /** parse the c|m-year-month-day option
     *
     * @param string  $key
     * @return string
     */
    private function _date_format($key) {
        if (strpos($key, 'year') !== false) $dkey[] = '%Y';
        if (strpos($key, 'month') !== false) $dkey[] = '%m';
        if (strpos($key, 'day') !== false) $dkey[] = '%d';
        $dformat = implode('-', $dkey);
        return $dformat;
    }

    /**
     * provide month and day format in real words if required
     * used for display only; $dformat is used for correct sorting!
     *
     * @param string $dformat
     * @return string
     */
    private function _date_format_words($dformat) {
        $wformat = '';
        switch ($dformat) {
            case '%m':
                $wformat = "%B";
                break;
            case '%d':
                $wformat = "%#d%A ";
                break;
            case '%Y-%m':
                $wformat = "%B %Y";
                break;
            case '%m-%d':
                $wformat= "%B %#d, %A ";
                break;
            case '%Y-%m-%d':
                $wformat = "%A, %B %#d, %Y";
                break;
        }
        return $wformat;
    }

    /**
     * a heavily customised version of _ft_pageLookup in inc/fulltext.php
     * I just removed the preg_quote line to enable regexes in search query...
     * and the unnecessary usort line as I have my own sort routines
     *
     */
    private function _pageLookup($query, $pageonly, $incl_ns, $excl_ns, $nostart = true, $maxns = 0) {
        global $conf;

        $queries = trim($query);
        $pages = file($conf['indexdir'] . '/page.idx');
        // first deal with excluded namespaces, then included
        $pages = $this->_filter_ns($pages, $excl_ns, true);

        // now include ONLY the selected namespaces if provided
        $pages = $this->_filter_ns($pages, $incl_ns, false);

        $cnt = count($pages);
        for ($i = 0; $i < $cnt; $i++) {
            $page = $pages[$i];
            if ( ! page_exists($page) || isHiddenPage($page)) {
                unset($pages[$i]);
                continue;
            }
            if ($pageonly) $page = noNS($page);
            if (preg_match('/' . $query . '/i', $page) == 0) {
                unset($pages[$i]);
            }
        }
        if ( ! count($pages)) return array();

        $pages = array_map('trim',$pages);

        // check ACL permissions and remove any 'start' pages if req'd
        $start = $conf['start'];
        $pos = strlen($start);
        foreach($pages as $idx => $name) {
            if ($this->nostart && substr($name, -$pos) == $start) {
                unset($pages[$idx]);
            } elseif(auth_quickaclcheck(trim($pages[$idx])) < AUTH_READ){
                unset($pages[$idx]);
            } elseif ($this->maxns > 0 && (substr_count($name,':') + 1) > $this->maxns) {
                unset($pages[$idx]);    //skip this page
            }
        }
        return $pages;
    }

    private function _filter_ns($pages, $ns_qry, $exclude) {
        $invert = ($exclude) ? PREG_GREP_INVERT : 0;
        foreach ($ns_qry as $ns) {
            $regexes[] = '.*' . $ns . ':.*';
        }
        if ( ! empty($regexes)) {
            $regex = '/(' . implode('|', $regexes) . ')/';
            return array_values(preg_grep($regex, $pages, $invert));
        } else {
            return $pages;
        }
    }
}

blob
mark :59
data 491
base    pagequery
author  Symon Bent
email   hendrybadao@gmail.com
date    2011-03-19
name    PageQuery Plugin (0.7)
desc    Search for (fulltext) and list wiki pages, sorted and optionally grouped by name, date, creator, abc, etc. in columns. Insert the pagequery markup wherever you want your list to appear.  E.g.{{pagequery>[query;fulltext;sort=key:direction,key2:direction;group;limit=??;cols=?;inwords;proper]}} [..] = optional
url     http://wiki.splitbrain.org/plugin:pagequery
blob
mark :60
data 10854
<?php
// keep key associations
define('MSORT_KEEP_ASSOC', 'msort01');

// additional sorting type
define('MSORT_NUMERIC', 'msort02');
define('MSORT_REGULAR', 'msort03');
define('MSORT_STRING', 'msort04');
define('MSORT_STRING_CASE', 'msort05'); // case insensitive (PHP style!)
define('MSORT_NAT', 'msort06');
define('MSORT_NAT_CASE', 'msort07');    // case insensitive (PHP style!)

define('MSORT_ASC', 'msort08');
define('MSORT_DESC', 'msort09');

define('MSORT_DEFAULT_DIRECTION', MSORT_ASC);
define('MSORT_DEFAULT_TYPE', MSORT_STRING);

/**
 * a replacement for array_mulitsort which permits natural and caseless sorting
 * this function will sort an 'array of rows' only (not array of 'columns')
 *
 * @param array $sort_array  : multi-dimensional array of arrays, where the first index refers to the row number
 *                             and the second to the column number (e.g. $array[row_number][column_number])
 *                             i.e. = array(
 *                                          array('name1', 'job1', 'start_date1', 'rank1'),
 *                                          array('name2', 'job2', 'start_date2', 'rank2'),
 *                                          ...
 *                                          );
 *
 * @param mixed $sort_opts   : options for how the array should be sorted
 *                   : AS ARGS
 *                             $key, $type, $direction [,$key2, $type2, $direction2, ...etc], $assoc
 *                             $key      = key/column to sort by
 *                             $type     = sorting type, one of following:
 *                                           MSORT_NUMERIC
 *                                           MSORT_REGULAR
 *                                           MSORT_STRING
 *                                           MSORT_STRING_CASE  : caseless sorting
 *                                           MSORT_NAT          : natural sorting
 *                                           MSORT_NAT_CASE
 *                             $direction = sorting direction:
 *                                           MSORT_ASC
 *                                           MSORT_DESC
 *                             $assoc     = keep associative array keys (uasort)
 *                                           MSORT_KEEP_ASSOC
 *                    :AS ARRAY
 *                             $sort_opts['key'][<column>] = 'key'
 *                             $sort_opts['type'][<column>] = 'type'
 *                             $sort_opts['dir'][<column>] = 'dir'
 *                             $sort_opts['assoc'][<column>] = MSORT_KEEP_ASSOC | true
 * @return boolean
 */

function msort(&$sort_array, $sort_opts) {

    // if a full sort_opts array was passed
    if (is_array($sort_opts)) {
        if (isset($sort_opts['assoc'])) {
            $keep_assoc = true;
        }
    // else separate the options from the function args
    } else {
        $args = func_get_args();

        if (end($args) == MSORT_KEEP_ASSOC) {
            $keep_assoc = true;
            array_pop($args);
        }

        // make sure there is something to sort
        if (empty($args)) return true;

        $type_enums = array(
                           MSORT_NUMERIC,
                           MSORT_REGULAR,
                           MSORT_STRING,
                           MSORT_STRING_CASE,
                           MSORT_NAT,
                           MSORT_NAT_CASE
                           );
        $direction_enums = array(
                                MSORT_ASC,
                                MSORT_DESC
                                );

        // work through the args list (SORT_KEY, SORT_TYPE, SORT_DIRECTION)
        $order = -1;
        foreach ($args as $arg) {
            // is it a sort direction?
            if (in_array($arg, $direction_enums)) {
                $sort_opts['dir'][$order] = $arg;
            // is it a sort type?
            } elseif (in_array($arg, $type_enums)) {
                $sort_opts['type'][$order] = $arg;
            // is it a sort array?
            } elseif (is_numeric($arg)) {
                $order++;
                $sort_opts['key'][$order] = $arg;
                $sort_opts['type'][$order] = MSORT_DEFAULT_TYPE;
                $sort_opts['dir'][$order] = MSORT_DEFAULT_DIRECTION;
            }
        }
    }

    // Determine which u..sort function (with or without associations).
    $sort_func = ($keep_assoc) ? 'uasort' : 'usort';

    // Sort the data and get the result.
    $result = $sort_func (
        $sort_array,
        function(array &$left, array &$right) use($sort_opts) {

            // Assume that the entries are the same.
            $cmp = 0;

            // Work through each sort column
            foreach($sort_opts['key'] as $idx => $key) {

                // Handle the different sort types.
                switch ($sort_opts['type'][$idx]) {
                    case MSORT_NUMERIC:
                        $key_cmp = ((intval($left[$key]) == intval($right[$key])) ? 0 :
                                   ((intval($left[$key]) < intval($right[$key])) ? -1 : 1 ) );
                        break;

                    case MSORT_STRING:
                        $key_cmp = strcmp((string)$left[$key], (string)$right[$key]);
                        break;

                    case MSORT_STRING_CASE: //case-insensitive
                        $key_cmp = strcasecmp((string)$left[$key], (string)$right[$key]);
                        break;

                    case MSORT_NAT:
                        $key_cmp = strnatcmp((string)$left[$key], (string)$right[$key]);
                        break;

                    case MSORT_NAT_CASE:    //case-insensitive
                        $key_cmp = strnatcasecmp((string)$left[$key], (string)$right[$key]);
                        break;

                    case MSORT_REGULAR:
                    default :
                        $key_cmp = (($left[$key] == $right[$key]) ? 0 :
                                   (($left[$key] < $right[$key]) ? -1 : 1 ) );
                    break;
                }

                // Is the column in the two arrays the same?
                if ($key_cmp == 0) {
                    continue;
                }

                // Are we sorting descending?
                $cmp = $key_cmp * (($sort_opts['dir'][$idx] == MSORT_DESC) ? -1 : 1);

                // no need for remaining keys as there was a difference
                break;
            }
            return $cmp;
        }
    );
	return $result;
}



// grouping types
define ('MGROUP_NONE', 'mgrp00');
define ('MGROUP_HEADING', 'mgrp01');
define ('MGROUP_NAMESPACE', 'mgrp02');

/**
 * group a multi-dimensional array by each level heading
 * @param array $sort_array : array to be grouped (result of 'msort' function)
 *                             last column should contain real dates if you need dates in words
 * @param mixed $group_opts :
 *                    AS ARGS:
 *                             key, type, dformat [,order, type, dformat]... [,real_dates]
 *                              key      = group by key/column
 *                              type     = one of the MGROUP types
 *                              dformat  = date format (if used)
 *                   AS ARRAY:
 *                             $group_opts['key'][<order>] = column key to group by
 *                             $group_opts['type'][<order>] = grouping type [MGROUP...]
 *                             $group_opts['dformat'][<order>] = date formatting string
 *
 * @return array $results   : array of arrays: (level, display_name, page_id), e.g. array(1, 'Main Title')
 *                              array(0, '...') =>  0 = normal row item (not heading)
 */
function mgroup(&$sort_array, $group_opts) {

    // if complete option array was provided
    if (is_array($group_opts)) {
        $level = count($group_opts['key']) - 1;

    // if not presume the above, one-by-one format
    } else {
        $args = func_get_args();

        $type_enums = array(
                            MGROUP_HEADING,
                            MGROUP_NAMESPACE,
                            );

        // get all the grouping options
        // order (which key/column), type (grouping type see MGROUP_...), dformat (real date display format),... repeated
        $group_opts = array();
        $order = -1;
        foreach ($args as $arg) {
            if (is_numeric($arg)) {
                $order++;
                $group_opts['key'][$order] = $arg;
                $group_opts['type'] [$order]= MGROUP_HEADING; // defaults
                $group_opts['dformat'] [$order]= '';
            } elseif ($order > -1) {
                if (in_array($arg, $type_enums)) {
                    $group_opts['type'][$order] = $arg;
                } else {
                    $group_opts['dformat'][$order] = $arg;
                }
            }
        }
        $level = $order;
    }

    $prevs = array();
    $results = array();
    $idx = 0;

    foreach($sort_array as $row) {
        _add_heading($results, $sort_array, $group_opts, $level, $idx, $prevs);
        $results[] = array(0, $row[NAME_KEY], $row[ID_KEY]);
        $idx++;
    }
    return $results;
}

/**
 * private function used by mgroup only!
 */
function _add_heading(&$results, &$sort_array, &$group_opts, $level, $idx, &$prevs) {
    static $end_col = 0;

    // recurse to find all parent headings
    if ($level > 0) {
        _add_heading($results, $sort_array, $group_opts, $level - 1, $idx, $prevs);
    }
    $group_type = $group_opts['type'][$level];

    $prev = (isset($prevs[$level])) ? $prevs[$level] : '';
    $key = $group_opts['key'][$level];
    $cur = $sort_array[$idx][$key];
    if ($cur != $prev) {
        $prevs[$level] = $cur;

        if ($group_type === MGROUP_HEADING) {
            $date_format = $group_opts['dformat'][$level];
            if ( ! empty($date_format)) {
                // the real date is always the last column (or item in array row)
                // static is used to avoid checking array length repeatedly
                if ($end_col == 0) $end_col = count($sort_array[0]) - 1;
                $cur = strftime($date_format, $sort_array[$idx][$end_col]);
            }
            $results[] = array($level + 1, $cur, '');

        } elseif ($group_type === MGROUP_NAMESPACE) {
            $cur_ns = explode(':', $cur);
            $prev_ns = explode(':', $prev);
            // only show namespaces that are different from the previous heading
            for ($i= 0; $i < count($cur_ns); $i++) {
                if ($cur_ns[$i] != $prev_ns[$i]) {
                    $hl = $level + $i + 1;
                    $results[] = array($hl , $cur_ns[$i], '');
                }
            }
        }
    }
}
?>
blob
mark :63
data 2414
div.dokuwiki div#pagequery {
    position:relative;
    margin:0 0 1em 0;
    border-width:1px;
}
div.dokuwiki div#pagequery table {
    border-collapse:collapse;
    width:100%;
    margin:0;
}
div.dokuwiki div#pagequery,
div.dokuwiki div#pagequery td {
	border-style:solid;
	border-color:#D7D5D4;
}
div.dokuwiki div#pagequery td {
	padding:8px 10px;
	background-color:white;
    border-width:0 1px 0 0;
}
div.dokuwiki div#pagequery.noborder,
div.dokuwiki div#pagequery td.noborder {
    border-width:0;
}
div.dokuwiki div#pagequery td:nth-last-child(1) {
    border-width:0;
}

div.dokuwiki div#pagequery h1,
div.dokuwiki div#pagequery h2,
div.dokuwiki div#pagequery h3,
div.dokuwiki div#pagequery h4,
div.dokuwiki div#pagequery h5,
div.dokuwiki div#pagequery h6 {
    padding:0.06em 0 0.03em 0;
    margin:0;
    margin-bottom:2px;
    color:#A0A0A0;
}
div.dokuwiki div#pagequery h3,
div.dokuwiki div#pagequery h4,
div.dokuwiki div#pagequery h5,
div.dokuwiki div#pagequery h6 {
    font-weight:normal;
}
div.dokuwiki div#pagequery h1 {
    font-size:134%;
    padding:0px 0px 3px 7px;
    background:#EDEDED;
    -moz-border-radius:6px;
    -webkit-border-radius:6px;
}
div.dokuwiki div#pagequery h2 {font-size:125%; font-weight:bold;}
div.dokuwiki div#pagequery h3 {font-size:114%;}
div.dokuwiki div#pagequery h4 {font-size:108%;}
div.dokuwiki div#pagequery h5 {font-size:100%;}
div.dokuwiki div#pagequery h6 {font-size:95%;}


div.dokuwiki div#pagequery ul {
    list-style:none;
    margin:0 0 8px 0;
	text-align:left;
}
div.dokuwiki div#pagequery ul.nogroup {
    margin:0 0 5px 3px;
}
div.dokuwiki div#pagequery li {
	padding-left:10px;
	list-style-position:inside;
	text-indent:-10px;
    line-height:135%;
}
div.dokuwiki div#pagequery a:hover,
div.dokuwiki div#pagequery blockquote a {
    text-decoration:none;
    color:#202020!important;
}
div.dokuwiki div#pagequery a.top {
    position:absolute;
    bottom:0.4em;;
    right:0.5em;
    font-style:italic;
    color:#A0A0A0;
}
/* credit: blockquote:plugin */
div.dokuwiki div#pagequery blockquote {
    font-size:80%;
	margin: 5px 15px 10px 15px !important;
	border: 1px dotted __border__ !important;
	background: #FAFACE url(images/blockquote.gif) no-repeat 5px 5px !important;
	padding: 10px 15px 15px 18px !important;
    -moz-border-radius: 6px;
    -webkit-border-radius: 6px;
}
div.dokuwiki div#pagequery blockquote a {
    margin-left:12px;
}

blob
mark :64
data 29192
<?php
/**
 * PageQuery Plugin: search for and list pages, sorted/grouped by name, date, creator, etc
 *
 * @license    GPL 2 (http://www.gnu.org/licenses/gpl.html)
 * @author	   Symon Bent <hendrybadao@gmail.com>
 */
// must be run within Dokuwiki
if(!defined('DOKU_INC')) die();

if (!defined('DOKU_LF')) define('DOKU_LF', "\n");
if (!defined('DOKU_TAB')) define('DOKU_TAB', "\t");
if (!defined('DOKU_PLUGIN')) define('DOKU_PLUGIN',DOKU_INC.'lib/plugins/');

require_once(DOKU_PLUGIN . 'syntax.php');
require_once(DOKU_INC . 'inc/fulltext.php');
require_once(DOKU_PLUGIN . 'pagequery/inc/msort.php');

define ('NAME_KEY', 1);
define ('ID_KEY', 0);
define ('START_KEY', 2);

class syntax_plugin_pagequery extends DokuWiki_Syntax_Plugin {
    private $dformat = '';
    private $inwords = false;
    private $nostart = false;
    private $maxns = 0;

	function getType() {
		return 'substition';
	}

	function getPType() {
		return 'block';
	}

	function getSort() {
		return 98;
	}

	function connectTo($mode) {
		//Default is a word cloud style, looks good when combined with plugin:box
		$this->Lexer->addSpecialPattern('\{\{pagequery>.*?\}\}', $mode, 'plugin_pagequery');
	}
    /**
     * Parses all the pagequery options:
     * Insert the pagequery markup wherever you want your list to appear. E.g:
     *
     *   {{pagequery>}}
     *
     *   {{pagequery>[query];fulltext;sort=key:direction,key2:direction;group;limit=??;cols=?;inwords;proper}}
     *
     * Parameters as follows:
     * 1. query:    any expression directly after the >; can use all Dokuwiki search options (see manual)
     * 2. fulltext: use a full-text search, instead of page_id only [default]
     * 3. sort:     keys to sort by, in order of sorting. Each key can be followed by prefered sorting order
     *              available keys:
     *                  a, ab, abc          by 1st letter, 2 letters, or 3 letters
     *                  name                by page name (no namespace) [not grouped]
     *                  page|id             by full page id, including namespace [not grouped]
     *                  ns                  by namespace (without page name)
     *                  mdate, cdate        by modified|created dates (full) [not grouped]
     *                  m[year][month][day] by modified [year][month][day]; any combination accepted
     *                  c[year][month][day] by created [year][month][day]; any combination accepted
     *                  creator             by page author
     *              date sort default to descending, string sorts to ascending
     * 4. group:    show group headers for each change in sort keys
     *              Note: keys with no duplicated cannot be grouped (i.e. name, page|id, mdate, cdate)
     * 5. limit:    maximum number of results to return
     * 6. inwords:  use real month and day names instead of just numbers
     * 7. cols:     number of columns in displayed list (max = 6)
     * 8. proper:   display page names and namespace in Proper Case (i.e. no _'s and Capitalised)
                    header/hdr = group headers only, name = page name only, both = both!
     * 9. border:   turn on borders
     *10. fullregex:only useful on page name searches; allows a raw regex mode on the full page id
     *11. nostart:  ignore any 'start' pages in namespace (based on "config:start")
     *12. maxns:    maximum namespace level to be displayed; e.g. maxns=3 => one:two:three
     *13. title:    show 1st page heading instead of page name
     *14. abstract: should an excerpt of the wikipage be shown:
     *              use :tooltip to show as a pop-up only
     *              use :<number> to show 1st n items in list with an abstract
     *15. natsort:  use natural sorting order (good for words beginning with numbers)
     *16. case:     respect case when sorting, i.e. a != A when sorting.  a-z then A-Z (opp. to PHP term, easier on novices)
     *
     * All options are optional, and the list will default to a boring long 1-column list...
     */
	function handle($match, $state, $pos, &$handler) {
        global $conf;
        $this->dformat = $conf['dformat'];

		$match = substr($match, 12, -2); // strip markup incl. pagequery>
		$args = explode(';', $match);
        $query = $args[0];
        $fulltext = false;
        $sort = array();
        $group = false;
        $limit = 0;  //Default max items displayed. '0' => no limit
        $maxns = 0;  // Maximum no. of namespace levels to display
        $proper = 'none';
        $cols = 1;
        $border = 'none';
        $title = false; // use title instead of name
        $snippet = 'tooltip';
        $fullregex = false;
        $case = false;
        $natsort = false;

        foreach ($args as $arg) {
            list($key, $value) = explode('=', $arg);
            switch ($key) {
                case 'fulltext':
                    $fulltext = true;
                    break;
                case 'sort':
                    $values = explode(',', $value);
                    foreach ($values as $value) {
                        list($key, $dir) = explode(':', $value);
                        $sort[] = array($key, $dir);
                    }
                    break;
                case 'group':
                    $group = true;
                    break;
                case 'limit':
                    $limit = $value;
                    break;
                case 'maxns':
                    $maxns = $value;
                    break;
                case 'inwords':
                    $inwords = true;
                    break;
                case 'proper':
                    switch ($value) {
                        case 'hdr':
                        case 'header':
                        case 'group':
                            $proper = 'header';
                            break;
                        case 'name':
                        case 'page':
                            $proper = 'name';
                            break;
                        default:
                            $proper = 'both';
                    }
                    break;
                case 'cols':
                    $cols = ($value > 6) ? 6 : $value;
                    break;
                case 'border':
                    switch ($value) {
                        case 'none':
                        case 'inside':
                        case 'outside':
                        case 'both':
                            $border = $value;
                            break;
                        default:
                            $border = 'both';
                    }
                    break;
				case 'fullregex':
					$fullregex = true;
					break;
                case 'nostart':
                    $nostart = true;
                    break;
                case 'title':
                    $title = true;
                    break;
                case 'abstract':    // old syntax, remove after some time? (2011-03-15)
                case 'snippet':
                    switch ($value) {
                        case '':
                        case 'tooltip':
                            $snippet = 'tooltip';
                            break;
                        default:
                            if ($value >= 0) {
                                $snippet = $value;
                            }
                    }
                    break;
                case 'case':
                    $case = true;
                    break;
                case 'natsort':
                    $natsort = true;
                    break;
            }
        }
        de&&bug('border', $border);
		return array($query, $fulltext, $sort, $group, $limit, $maxns, $proper,
                      $cols, $inwords, $border, $fullregex, $nostart, $title,
                      $snippet, $case, $natsort);
	}

    function render($mode, &$renderer, $data) {
        $sortkeys = array();
        $incl_ns = array();
        $excl_ns = array();

        list($query, $fulltext, $sort, $group, $limit, $maxns, $proper,
              $cols, $inwords, $border, $fullregex, $nostart, $title,
              $snippet, $case, $natsort) = $data;

        if ($mode == 'xhtml') {
            // first get a raw list of matching results
            if ($fulltext) {
                $results = array_keys(ft_pageSearch($query, $highlight));
            } else {
                // allow for raw regex mode, for power users, this searches the full page id
                if ($fullregex) {
                    $pageonly = false;
                } else {
                    list($query, $incl_ns, $excl_ns) = $this->_parse_ns_query($query);
                    $pageonly = true;
                }
                $results = $this->_pageLookup($query, $pageonly, $incl_ns, $excl_ns, $nostart, $maxns);
            }

            // basic result page markup (always needed)
            $noborder_css = ' class="noborder" ';
            $border_style = ($border == 'outside' || $border == 'both') ? '' : $noborder_css;
            $renderer->doc .= '<div id="pagequery" ' . $border_style . '>' . DOKU_LF;
            $renderer->doc .= '<table><tbody><tr>' . DOKU_LF;

            if ( ! empty($results)) {
                // this section is where the essential pagequery functionality happens...

                // prepare the necessary sorting arrays, as per users options
                list($sort_array, $sort_opts, $group_opts) =
                    $this->_get_options($results, $sort, $title, $proper, $inwords, $case, $natsort);

                // now do the sorting
                msort($sort_array, $sort_opts);

                // limit the result list length if required; this can only be done after sorting!
                $results = ($limit > 0) ? array_slice($results, 0, $limit) : $results;

                // and finally the grouping
                if ($group) $results = mgroup($sort_array, $group_opts);

                // now render the actual result list
                $was_heading = false;
                $cont_level = 1;
                $idx = 0;
                $col = 0;
                $rows = ceil(count($results) / $cols);  // proposed column row size
                $width = floor(100 / $cols);
                $snippet_cnt = 0;    // needed by the snippet section
                $jump_txt= $this->getLang('jump_section');
                $border_style = ($border == 'inside' || $border == 'both') ? '' : $noborder_css;

                foreach ($results as $line) {
                    list($level, $name, $id) = $line;

                    // are we ready to start a new column? (up to max allowed)
                    if ($col < $cols && $idx % $rows == 0) {
                        $ready_for_col = true;
                        $col++;
                    }
                    $is_heading = ($level > 0);
                    if ($is_heading) {
                        $heading = $name;
                        if ($proper == 'header' || $proper == 'both') $heading = $this->_proper($heading);
                    }
                    if ($group === false) {
                        $indent_style = ' class="nogroup"';
                    } else {
                        $indent = ($is_heading) ? $level - 1 : $cont_level - 1;
                        $indent_style = ' style="margin-left:' . $indent * 10 . 'px"';
                    }
                    // Begin new column if: 1.we are at the start, 2.at a heading or 3.if there is no grouping
                    if ($ready_for_col && ! $was_heading) {
                        $top_id = 'top-' . mt_rand();
                        $jump_tip = sprintf($jump_txt, $heading);
                        // close the previous column if necessary; also add a 'jump to anchor'
                        $cont_close = ( ! $is_heading) ? '<a title="'. $jump_tip . '" href="#' .
                                        $top_id . '">' . "<h$cont_level>... </h$cont_level></a>" : '';
                        $cont_open = ($idx > 0 && ! $is_heading) ? "<h$cont_level$indent_style" .
                                        ' id="' . $top_id . '">' . "$heading...</h$cont_level>" : '';
                        $close = ($idx > 0) ? $cont_close . '</ul></td>' . DOKU_LF : '';
                        $renderer->doc .= $close . '<td' . $border_style . ' valign="top" width="' . $width . '%">' . $cont_open . DOKU_LF;
                        $ready_for_col = false;
                        $was_heading = true;    //needed to begin a new page id list
                    }
                    if ($is_heading) {
                        // close previous sub list if necessary
                        if ( ! $was_heading) {
                            $renderer->doc .= '</ul>' . DOKU_LF;
                        }
                        $renderer->doc .= "<h$level$indent_style>$heading</h$level>" . DOKU_LF;
                        $was_heading = true;
                        $cont_level = $level + 1;
                    } else {
                        // open a new sub list if necessary
                        if ($was_heading || $idx == 0) {
                            $renderer->doc .= "<ul$indent_style>";
                        }
                        // deal with normal page links
                        $link = $this->_render_wikilink($id, $name, $snippet, $snippet_cnt);
                        $snippet_cnt++;
                        $renderer->doc .= $link;
                        $was_heading = false;
                    }
                    $idx++;
                }
                $renderer->doc .= '</ul></td>';
            } else {
                // display a "no results" message if empty
                $renderer->doc .= '<td><p>' . $this->getLang("no_results") .
                                  '"<strong>' . $query . '</strong>"</p></td>' . DOKU_LF;
            }
            $renderer->doc .= '</tr>' . DOKU_LF;
            $renderer->doc .= '</tbody></table>';
            $renderer->doc .= '<a class="top" href="#' . $top_id . '">' . $this->getLang('link_to_top') . '</a>';
            $renderer->doc .= '</div>' . DOKU_LF;
            return true;
        } else {
            return false;
        }
    }

    /**
     * Renders the page link, plus tooltip, abstract, casing, etc...
     * @param string $id
     * @param bool  $proper
     * @param bool  $title
     * @param mixed $abstract
     */
    private function _render_wikilink($id, $name, $snippet, $snippet_cnt) {

        $id = (strpos($id, ':') === false) ? ':' . $id : $id;   // : needed for root pages

        // show the "snippet" as a tooltip
        // -or- as a nice quoted snippet ( la blockquote plugin)
        $box = '';
        if ($snippet != 'none') {
            $abstract = $this->_abstract($id);
            if ($snippet == 'tooltip' || ($snippet > 0 && $snippet_cnt >= $snippet)) {
                $link = $this->_html_wikilink_tooltip($id, $name, $abstract);
            } elseif ($snippet == 'all' || ($snippet >= 0 && $snippet_cnt < $snippet)) {
                list($link, $box) = $this->_html_wikilink_snippet($id, $name, $abstract);
            }
        } else {
            $link = html_wikilink($id, $name);
        }
        return '<li>' . $link . '</li>' . DOKU_LF . $box;
    }

    private function _proper($id) {
         $id = str_replace(':', ': ', $id);
         $id = str_replace('_', ' ', $id);
         $id = ucwords($id);
         $id = str_replace(': ', ':', $id);
         return $id;
    }
    /**
     * swap normal link title (popup) for a more useful preview
     *
     * @param string $id    page id
     * @param string $name  display name
     * @return complete href link
     */
    private function _html_wikilink_tooltip($id, $name, $tooltip) {
        $link = html_wikilink($id, $name);
        $tooltip = str_replace("\n", '  ', $tooltip);
        $link = preg_replace('/title=\".+?\"/', 'title="' . $tooltip . '"', $link, 1);
        return $link;
    }
    private function _html_wikilink_snippet($id, $name, $snippet) {
        $link = html_wikilink($id, $name);
        $detail = str_replace("\n\n", '<br/>', $snippet);
        $more = html_wikilink($id, 'more...');
        $detail = '<blockquote>' . $detail . $more . '</blockquote>' . DOKU_LF;
        return array($link, $detail);
    }

    private function _abstract($id) {
        $abstract = p_get_metadata($id, 'description abstract', true);
        $abstract = htmlspecialchars($abstract, ENT_QUOTES, 'UTF-8');
        return $abstract;
    }

    /**
     * Parse out the namespace, and convert to a regex for array search
     * -or- ensure that normal search are only within pagename not its namespace
     *
     * @param string $query user page query
     * @return processed query with regex markup as needed for namespace recognition
     */
    private function _parse_ns_query($query) {
        $incl_ns = array();
        $excl_ns = array();
        $page_qry = '';
        $tokens = explode(' ', $query);
        if (count($tokens) == 1) {
            $page_qry = $query;
        } else {
            foreach ($tokens as $token) {
                if (preg_match('/^(?:\^|-ns:)(.+)$/u', $token, $matches)) {
                    $excl_ns[] = $matches[1];
                } elseif (preg_match('/^(?:@|ns:)(.+)$/u', $token, $matches)) {
                    $incl_ns[] = $matches[1];
                } else {
                    $page_qry .= ' ' . $token;
                }
            }
        }
        $page_qry = trim($page_qry);
		if ($page_qry == '*') $page_qry = '.*';
        return array($page_qry, $incl_ns, $excl_ns);
    }

    /**
     * Builds the sorting array: adds extra items for each sorting key
     *
     * @param array     $ids        array of page ids to be sorted
     * @param array     $sortkeys   list of array keys to sort by
     * @param bool      $title      use page heading instead of name for sorting
     * @param bool      $proper     use proper case where possible
     * @param bool      $inwords    show dates in words where possible
     * @param bool      $case       honour case when sorting
     * @param bool      $natsort    natural sorting, the human way
     * @return void
     */
    private function _get_options($ids, $sortkeys, $title, $proper, $inwords, $case, $natsort) {
        global $conf;

        $sort_opts = array();
        $group_opts = array();

        $dformat = array();
        $wformat = array();

        $row = 0;
        $end_col = START_KEY + count($sortkeys);

        foreach ($ids as $id) {
            $meta = p_get_metadata ($id, false, true);
            if ( ! isset($meta['date']['modified'])) {
                $meta['date']['modified'] = $meta['date']['created'];
            }
            // use page heading instead of page name
            if ($title && isset($meta['title'])) {
                $name = $meta['title'];
            } else {
                $name = noNS($id);
            }
            if ($proper == 'name' || $proper == 'both') {
                $name = $this->_proper($name);
            }
            // first column is the basic page id
            $sort_array[$row][ID_KEY] = $id;
            // second column is the display 'name' (used when sorting by 'name')
            // this also avoids rebuilding the display name when building links (DRY)
            $sort_array[$row][NAME_KEY] = $name;
            $col = START_KEY;

            foreach ($sortkeys as $sortkey) {
                $key = $sortkey[0];
                switch ($key) {
                    case 'a':
                        $value = $this->_first($name, 1);
                        break;
                    case 'ab':
                        $value = $this->_first($name, 2);
                        break;
                    case 'abc':
                        $value = $this->_first($name, 3);
                        break;
                    case 'name':
                        // a name column already exists by default (col 1)
                        continue;
                    case 'id':
                    case 'page':
                        $value = $id;
                        break;
                    case 'ns':
                        $value = getNS($id);
                        if (empty($value)) $value = '[' . $conf['start'] . ']';
                        break;
                    case 'creator':
                        $value = $meta['creator'];
                        break;
                    case 'mdate':
                        $value = $meta['date']['modified'];
                        break;
                    case 'cdate':
                        $value = $meta['date']['created'];
                        break;
                    default:
                        // date sorting types (groupable)
                        $dtype = $key[0];
                        if ($dtype == 'c' || $dtype == 'm') {
                            // we only set real date once per id (needed for grouping)
                            // not per sort column--the date should remain same across all columns
                            // this is always the last column!
                            if ($col == START_KEY) {
                                if ($dtype == 'c') {
                                    $date = $meta['date']['created'];
                                } else {
                                    $date = $meta['date']['modified'];
                                }
                                $sort_array[$row][$end_col] = $date;
                            } else {
                                $date = $sort_array[$row][$end_col] ;
                            }
                            // only set date formats once per sort column/key (not per id!)
                            if ($row == 0) {
                                $dformat[$col] = $this->_date_format($key);
                                // collect date in word format for potential use in grouping
                                if ($inwords) {
                                    $wformat[$col] = $this->_date_format_words($dformat[$col]);
                                } else {
                                    $wformat[$col] = '';
                                }
                            }
                            // create a string date used for sorting only
                            // (we cannot just use the real date otherwise it would not group correctly)
                            $value = strftime($dformat[$col], $date);
                        }
                }
                $sort_array[$row][$col] = $value;
                $col++;
            }
            $row++;
        }

        $cnt = START_KEY;
        $order = 0;
        foreach ($sortkeys as $sortkey) {
            list($key, $opt) = $sortkey;

            if ($key == 'name') {
                $col = NAME_KEY;
                // do not incease $cnt so that this col number will be re-used
                // next time through
            } else {
                $col = $cnt;
                $cnt++;
            }
            $sort_opts['key'][] = $col;

            // now the sort direction
            switch ($opt) {
                case 'a':
                case 'asc':
                    $dir = MSORT_ASC;
                    break;
                case 'd':
                case 'desc':
                    $dir = MSORT_DESC;
                    break;
                default:
                    // sort descending by default; text ascending
                    // watch for other sort options beginning with c or m ....!
                    if ($key[0] == 'c' || $key[0] == 'm') {
                        $dir = MSORT_DESC;
                    } else {
                        $dir = MSORT_ASC;
                    }
            }
            $sort_opts['dir'][] = $dir;

            // set the sort array's data type
            $is_ns = false;
            switch ($key) {
                case 'mdate':
                case 'cdate':
                    $type = MSORT_NUMERIC;
                    break;
                default:
                    if ($case) {
                        // case matters: a-z then A-Z
                        $type = ($natsort) ? MSORT_NAT : MSORT_STRING;
                    } else {
                        // case-insensitive
                        $type = ($natsort) ? MSORT_NAT_CASE : MSORT_STRING_CASE;
                    }
            }
            $sort_opts['type'][] = $type;

            // now establish grouping options
            switch ($key) {
                // name strings and full dates cannot be meaningfully grouped (no duplicates!)
                case 'mdate':
                case 'cdate':
                case 'name':
                case 'id':
                case 'page':
                    $group_by = MGROUP_NONE;
                    break;
                case 'ns':
                    $group_by = MGROUP_NAMESPACE;
                    break;
                default:
                    $group_by = MGROUP_HEADING;
            }
            if ($group_by != MGROUP_NONE) {
                $group_opts['key'][$order] = $col;
                $group_opts['type'][$order] = $group_by;
                $group_opts['dformat'][$order] = $wformat[$col];
                $order++;
            }
        }
        return array($sort_array, $sort_opts, $group_opts);
    }

    // returns first $count letters from $text
    private function _first($text, $count) {
        if ($count > 0) {
            return utf8_substr($text, 0, $count);
        }
    }

    /** parse the c|m-year-month-day option
     *
     * @param string  $key
     * @return string
     */
    private function _date_format($key) {
        if (strpos($key, 'year') !== false) $dkey[] = '%Y';
        if (strpos($key, 'month') !== false) $dkey[] = '%m';
        if (strpos($key, 'day') !== false) $dkey[] = '%d';
        $dformat = implode('-', $dkey);
        return $dformat;
    }

    /**
     * provide month and day format in real words if required
     * used for display only; $dformat is used for correct sorting!
     *
     * @param string $dformat
     * @return string
     */
    private function _date_format_words($dformat) {
        $wformat = '';
        switch ($dformat) {
            case '%m':
                $wformat = "%B";
                break;
            case '%d':
                $wformat = "%#d%A ";
                break;
            case '%Y-%m':
                $wformat = "%B %Y";
                break;
            case '%m-%d':
                $wformat= "%B %#d, %A ";
                break;
            case '%Y-%m-%d':
                $wformat = "%A, %B %#d, %Y";
                break;
        }
        return $wformat;
    }

    /**
     * a heavily customised version of _ft_pageLookup in inc/fulltext.php
     * I just removed the preg_quote line to enable regexes in search query...
     * and the unnecessary usort line as I have my own sort routines
     *
     */
    private function _pageLookup($query, $pageonly, $incl_ns, $excl_ns, $nostart = true, $maxns = 0) {
        global $conf;

        $queries = trim($query);
        $pages = file($conf['indexdir'] . '/page.idx');
        // first deal with excluded namespaces, then included
        $pages = $this->_filter_ns($pages, $excl_ns, true);

        // now include ONLY the selected namespaces if provided
        $pages = $this->_filter_ns($pages, $incl_ns, false);

        $cnt = count($pages);
        for ($i = 0; $i < $cnt; $i++) {
            $page = $pages[$i];
            if ( ! page_exists($page) || isHiddenPage($page)) {
                unset($pages[$i]);
                continue;
            }
            if ($pageonly) $page = noNS($page);
            if (preg_match('/' . $query . '/i', $page) == 0) {
                unset($pages[$i]);
            }
        }
        if ( ! count($pages)) return array();

        $pages = array_map('trim',$pages);

        // check ACL permissions and remove any 'start' pages if req'd
        $start = $conf['start'];
        $pos = strlen($start);
        foreach($pages as $idx => $name) {
            if ($this->nostart && substr($name, -$pos) == $start) {
                unset($pages[$idx]);
            } elseif(auth_quickaclcheck(trim($pages[$idx])) < AUTH_READ){
                unset($pages[$idx]);
            } elseif ($this->maxns > 0 && (substr_count($name,':') + 1) > $this->maxns) {
                unset($pages[$idx]);    //skip this page
            }
        }
        return $pages;
    }

    private function _filter_ns($pages, $ns_qry, $exclude) {
        $invert = ($exclude) ? PREG_GREP_INVERT : 0;
        foreach ($ns_qry as $ns) {
            $regexes[] = '.*' . $ns . ':.*';
        }
        if ( ! empty($regexes)) {
            $regex = '/(' . implode('|', $regexes) . ')/';
            return array_values(preg_grep($regex, $pages, $invert));
        } else {
            return $pages;
        }
    }
}

blob
mark :66
data 2420
div.dokuwiki div#pagequery {
    position:relative;
    margin:0 0 1em 0;
    border-width:1px;
}
div.dokuwiki div#pagequery table {
    border-collapse:collapse;
    width:100%;
    margin:0;
}
div.dokuwiki div#pagequery,
div.dokuwiki div#pagequery td {
	border-style:solid;
	border-color:#D7D5D4;
}
div.dokuwiki div#pagequery td {
	padding:8px 10px;
	background-color:white;
    border-width:0 1px 0 0;
}
div.dokuwiki div#pagequery.noborder,
div.dokuwiki div#pagequery td.noborder {
    border-width:0;
}
div.dokuwiki div#pagequery td:nth-last-child(1) {
    border-width:0;
}

div.dokuwiki div#pagequery h1,
div.dokuwiki div#pagequery h2,
div.dokuwiki div#pagequery h3,
div.dokuwiki div#pagequery h4,
div.dokuwiki div#pagequery h5,
div.dokuwiki div#pagequery h6 {
    padding:0.06em 0 0.03em 0;
    margin:0;
    margin-bottom:2px;
    color:#A0A0A0;
}
div.dokuwiki div#pagequery h3,
div.dokuwiki div#pagequery h4,
div.dokuwiki div#pagequery h5,
div.dokuwiki div#pagequery h6 {
    font-weight:normal;
}
div.dokuwiki div#pagequery h1 {
    font-size:134%;
    padding:0px 0px 3px 7px;
    background:#EDEDED;
    -moz-border-radius:6px;
    -webkit-border-radius:6px;
}
div.dokuwiki div#pagequery h2 {font-size:125%; font-weight:bold;}
div.dokuwiki div#pagequery h3 {font-size:114%;}
div.dokuwiki div#pagequery h4 {font-size:108%;}
div.dokuwiki div#pagequery h5 {font-size:100%;}
div.dokuwiki div#pagequery h6 {font-size:95%;}


div.dokuwiki div#pagequery ul {
    list-style:none;
    margin:0 0 8px 0;
	text-align:left;
}
div.dokuwiki div#pagequery ul.nogroup {
    margin:0 0 5px 3px;
}
div.dokuwiki div#pagequery li {
	padding-left:10px;
	list-style-position:inside;
	text-indent:-10px;
    line-height:135%;
}
div.dokuwiki div#pagequery a:hover,
div.dokuwiki div#pagequery blockquote a:hover {
    text-decoration:none;
    color:#202020!important;
}
div.dokuwiki div#pagequery a.top {
    position:absolute;
    bottom:0.4em;;
    right:0.5em;
    font-style:italic;
    color:#A0A0A0;
}
/* credit: blockquote:plugin */
div.dokuwiki div#pagequery blockquote {
    font-size:80%;
	margin: 5px 15px 10px 15px !important;
	border: 1px dotted __border__ !important;
	background: #FAFACE url(images/blockquote.gif) no-repeat 5px 5px !important;
	padding: 10px 15px 15px 18px !important;
    -moz-border-radius: 6px;
    -webkit-border-radius: 6px;
}
div.dokuwiki div#pagequery blockquote a {
    margin-left:12px;
}

blob
mark :67
data 29244
<?php
/**
 * PageQuery Plugin: search for and list pages, sorted/grouped by name, date, creator, etc
 *
 * @license    GPL 2 (http://www.gnu.org/licenses/gpl.html)
 * @author	   Symon Bent <hendrybadao@gmail.com>
 */
// must be run within Dokuwiki
if(!defined('DOKU_INC')) die();

if (!defined('DOKU_LF')) define('DOKU_LF', "\n");
if (!defined('DOKU_TAB')) define('DOKU_TAB', "\t");
if (!defined('DOKU_PLUGIN')) define('DOKU_PLUGIN',DOKU_INC.'lib/plugins/');

require_once(DOKU_PLUGIN . 'syntax.php');
require_once(DOKU_INC . 'inc/fulltext.php');
require_once(DOKU_PLUGIN . 'pagequery/inc/msort.php');

define ('NAME_KEY', 1);
define ('ID_KEY', 0);
define ('START_KEY', 2);
define ('MAX_COLS', 6);

class syntax_plugin_pagequery extends DokuWiki_Syntax_Plugin {
    private $dformat = '';
    private $inwords = false;
    private $nostart = false;
    private $maxns = 0;

	function getType() {
		return 'substition';
	}

	function getPType() {
		return 'block';
	}

	function getSort() {
		return 98;
	}

	function connectTo($mode) {
		//Default is a word cloud style, looks good when combined with plugin:box
		$this->Lexer->addSpecialPattern('\{\{pagequery>.*?\}\}', $mode, 'plugin_pagequery');
	}
    /**
     * Parses all the pagequery options:
     * Insert the pagequery markup wherever you want your list to appear. E.g:
     *
     *   {{pagequery>}}
     *
     *   {{pagequery>[query];fulltext;sort=key:direction,key2:direction;group;limit=??;cols=?;inwords;proper}}
     *
     * Parameters as follows:
     * 1. query:    any expression directly after the >; can use all Dokuwiki search options (see manual)
     * 2. fulltext: use a full-text search, instead of page_id only [default]
     * 3. sort:     keys to sort by, in order of sorting. Each key can be followed by prefered sorting order
     *              available keys:
     *                  a, ab, abc          by 1st letter, 2 letters, or 3 letters
     *                  name                by page name (no namespace) [not grouped]
     *                  page|id             by full page id, including namespace [not grouped]
     *                  ns                  by namespace (without page name)
     *                  mdate, cdate        by modified|created dates (full) [not grouped]
     *                  m[year][month][day] by modified [year][month][day]; any combination accepted
     *                  c[year][month][day] by created [year][month][day]; any combination accepted
     *                  creator             by page author
     *              date sort default to descending, string sorts to ascending
     * 4. group:    show group headers for each change in sort keys
     *              Note: keys with no duplicate cannot be grouped (i.e. name, page|id, mdate, cdate)
     * 5. limit:    maximum number of results to return
     * 6. inwords:  use real month and day names instead of numeric dates
     * 7. cols:     number of columns in displayed list (max = 6)
     * 8. proper:   display page names and namespace in Proper Case (i.e. no _'s and Capitalised)
     *              header/hdr = group headers only, name = page name only, both = both!
     * 9. border:   turn on borders. 'inside' = between columns; 'outside' => border around table;
     *              'both' => in and out; 'none' => neither
     *10. fullregex:only useful on page name searches; allows a raw regex mode on the full page id
     *11. nostart:  ignore any 'start' pages in namespace (based on "config:start")
     *12. maxns:    maximum namespace level to be displayed; e.g. maxns=3 => one:two:three
     *13. title:    show 1st page heading instead of page name
     *14. snippet:  should an excerpt of the wikipage be shown:
     *              use :tooltip to show as a pop-up only
     *              use :<number> to show 1st n items in list with an abstract
     *15. natsort:  use natural sorting order (good for words beginning with numbers)
     *16. case:     respect case when sorting, i.e. a != A when sorting.  a-z then A-Z (opp. to PHP term, easier on novices)
     *
     * All options are optional, and the list will default to a boring long 1-column list...
     */
	function handle($match, $state, $pos, &$handler) {
        global $conf;
        $this->dformat = $conf['dformat'];

		$match = substr($match, 12, -2); // strip markup incl. pagequery>
		$options = explode(';', $match);
        $query = $options[0];

        // establish a few defaults
        $fulltext = false;
        $sort = array();
        $group = false;
        $limit = 0;
        $maxns = 0;
        $cols = 1;
        $proper = 'none';
        $border = 'none';
        $snippet = 'tooltip';
        $title = false;
        $fullregex = false;
        $case = false;
        $natsort = false;

        foreach ($options as $option) {
            list($key, $value) = explode('=', $option);
            switch ($key) {
                case 'fulltext':
                    $fulltext = true;
                    break;
                case 'sort':
                    $values = explode(',', $value);
                    foreach ($values as $value) {
                        list($key, $dir) = explode(':', $value);
                        $sort[] = array($key, $dir);
                    }
                    break;
                case 'group':
                    $group = true;
                    break;
                case 'limit':
                    $limit = $value;
                    break;
                case 'maxns':
                    $maxns = $value;
                    break;
                case 'inwords':
                    $inwords = true;
                    break;
                case 'proper':
                    switch ($value) {
                        case 'hdr':
                        case 'header':
                        case 'group':
                            $proper = 'header';
                            break;
                        case 'name':
                        case 'page':
                            $proper = 'name';
                            break;
                        default:
                            $proper = 'both';
                    }
                    break;
                case 'cols':
                    $cols = ($value > MAX_COLS) ? MAX_COLS : $value;
                    break;
                case 'border':
                    switch ($value) {
                        case 'none':
                        case 'inside':
                        case 'outside':
                        case 'both':
                            $border = $value;
                            break;
                        default:
                            $border = 'both';
                    }
                    break;
				case 'fullregex':
					$fullregex = true;
					break;
                case 'nostart':
                    $nostart = true;
                    break;
                case 'title':
                    $title = true;
                    break;
                case 'abstract':    // old syntax, to be deprecated (2011-03-15)
                case 'snippet':
                    switch ($value) {
                        case '':
                        case 'tooltip':
                            $snippet = 'tooltip';
                            break;
                        default:
                            if ($value >= 0) {
                                $snippet = $value;
                            }
                    }
                    break;
                case 'case':
                    $case = true;
                    break;
                case 'natsort':
                    $natsort = true;
                    break;
            }
        }
		return array($query, $fulltext, $sort, $group, $limit, $maxns, $proper,
                      $cols, $inwords, $border, $fullregex, $nostart, $title,
                      $snippet, $case, $natsort);
	}

    function render($mode, &$renderer, $data) {
        $sortkeys = array();
        $incl_ns = array();
        $excl_ns = array();

        list($query, $fulltext, $sort, $group, $limit, $maxns, $proper,
              $cols, $inwords, $border, $fullregex, $nostart, $title,
              $snippet, $case, $natsort) = $data;

        if ($mode == 'xhtml') {
            // first get a raw list of matching results
            if ($fulltext) {
                $results = array_keys(ft_pageSearch($query, $highlight));
            } else {
                // allow for raw regex mode, for power users, this searches the full page id
                if ($fullregex) {
                    $pageonly = false;
                } else {
                    list($query, $incl_ns, $excl_ns) = $this->_parse_ns_query($query);
                    $pageonly = true;
                }
                $results = $this->_pageLookup($query, $pageonly, $incl_ns, $excl_ns, $nostart, $maxns);
            }

            // basic result page markup (always needed)
            $noborder_css = ' class="noborder" ';
            $border_style = ($border == 'outside' || $border == 'both') ? '' : $noborder_css;
            $renderer->doc .= '<div id="pagequery" ' . $border_style . '>' . DOKU_LF;
            // fixed point to jump back to at top of the table
            $top_id = 'top-' . mt_rand();
            $renderer->doc .= '<table id="' . $top_id . '"><tbody><tr>' . DOKU_LF;

            if ( ! empty($results)) {
                // this section is where the essential pagequery functionality happens...

                // prepare the necessary sorting arrays, as per users options
                list($sort_array, $sort_opts, $group_opts) =
                    $this->_get_options($results, $sort, $title, $proper, $inwords, $case, $natsort);

                // now do the sorting
                msort($sort_array, $sort_opts);

                // limit the result list length if required; this can only be done after sorting!
                $results = ($limit > 0) ? array_slice($results, 0, $limit) : $results;

                // and finally the grouping
                if ($group) $results = mgroup($sort_array, $group_opts);

                // now render the actual result list
                $was_heading = false;
                $cont_level = 1;
                $idx = 0;
                $col = 0;
                $rows = ceil(count($results) / $cols);  // proposed column row size
                $width = floor(100 / $cols);
                $snippet_cnt = 0;    // needed by the snippet section
                $jump_txt= $this->getLang('jump_section');
                $border_style = ($border == 'inside' || $border == 'both') ? '' : $noborder_css;

                foreach ($results as $line) {
                    list($level, $name, $id) = $line;

                    // are we ready to start a new column? (up to max allowed)
                    if ($col < $cols && $idx % $rows == 0) {
                        $ready_for_col = true;
                        $col++;
                    }
                    $is_heading = ($level > 0);
                    if ($is_heading) {
                        $heading = $name;
                        if ($proper == 'header' || $proper == 'both') $heading = $this->_proper($heading);
                    }
                    if ($group === false) {
                        $indent_style = ' class="nogroup"';
                    } else {
                        $indent = ($is_heading) ? $level - 1 : $cont_level - 1;
                        $indent_style = ' style="margin-left:' . $indent * 10 . 'px"';
                    }
                    // Begin new column if: 1.we are at the start, 2.at a heading or 3.if there is no grouping
                    if ($ready_for_col && ! $was_heading) {
                        $jump_tip = sprintf($jump_txt, $heading);
                        // close the previous column if necessary; also add a 'jump to anchor'
                        $cont_close = ( ! $is_heading) ? '<a title="'. $jump_tip . '" href="#' .
                                        $top_id . '">' . "<h$cont_level>... </h$cont_level></a>" : '';
                        $cont_open = ($idx > 0 && ! $is_heading) ? "<h$cont_level$indent_style>" . "$heading...</h$cont_level>" : '';
                        $close = ($idx > 0) ? $cont_close . '</ul></td>' . DOKU_LF : '';
                        $renderer->doc .= $close . '<td' . $border_style . ' valign="top" width="' . $width . '%">' . $cont_open . DOKU_LF;
                        $ready_for_col = false;
                        $was_heading = true;    //needed to begin a new page id list
                    }
                    if ($is_heading) {
                        // close previous sub list if necessary
                        if ( ! $was_heading) {
                            $renderer->doc .= '</ul>' . DOKU_LF;
                        }
                        $renderer->doc .= "<h$level$indent_style>$heading</h$level>" . DOKU_LF;
                        $was_heading = true;
                        $cont_level = $level + 1;
                    } else {
                        // open a new sub list if necessary
                        if ($was_heading || $idx == 0) {
                            $renderer->doc .= "<ul$indent_style>";
                        }
                        // deal with normal page links
                        $link = $this->_render_wikilink($id, $name, $snippet, $snippet_cnt);
                        $snippet_cnt++;
                        $renderer->doc .= $link;
                        $was_heading = false;
                    }
                    $idx++;
                }
                $renderer->doc .= '</ul></td>';
            } else {
                // display a "no results" message if empty
                $renderer->doc .= '<td><p>' . $this->getLang("no_results") .
                                  '"<strong>' . $query . '</strong>"</p></td>' . DOKU_LF;
            }
            $renderer->doc .= '</tr>' . DOKU_LF;
            $renderer->doc .= '</tbody></table>';
            $renderer->doc .= '<a class="top" href="#' . $top_id . '">' . $this->getLang('link_to_top') . '</a>';
            $renderer->doc .= '</div>' . DOKU_LF;
            return true;
        } else {
            return false;
        }
    }

    /**
     * Renders the page link, plus tooltip, abstract, casing, etc...
     * @param string $id
     * @param bool  $proper
     * @param bool  $title
     * @param mixed $abstract
     */
    private function _render_wikilink($id, $name, $snippet, $snippet_cnt) {

        $id = (strpos($id, ':') === false) ? ':' . $id : $id;   // : needed for root pages

        // show the "snippet" as a tooltip
        // -or- as a nice quoted snippet ( la blockquote plugin)
        $box = '';
        if ($snippet != 'none') {
            $abstract = $this->_abstract($id);
            if ($snippet == 'tooltip' || ($snippet > 0 && $snippet_cnt >= $snippet)) {
                $link = $this->_html_wikilink_tooltip($id, $name, $abstract);
            } elseif ($snippet == 'all' || ($snippet >= 0 && $snippet_cnt < $snippet)) {
                list($link, $box) = $this->_html_wikilink_snippet($id, $name, $abstract);
            }
        } else {
            $link = html_wikilink($id, $name);
        }
        return '<li>' . $link . '</li>' . DOKU_LF . $box;
    }

    private function _proper($id) {
         $id = str_replace(':', ': ', $id);
         $id = str_replace('_', ' ', $id);
         $id = ucwords($id);
         $id = str_replace(': ', ':', $id);
         return $id;
    }
    /**
     * swap normal link title (popup) for a more useful preview
     *
     * @param string $id    page id
     * @param string $name  display name
     * @return complete href link
     */
    private function _html_wikilink_tooltip($id, $name, $tooltip) {
        $link = html_wikilink($id, $name);
        $tooltip = str_replace("\n", '  ', $tooltip);
        $link = preg_replace('/title=\".+?\"/', 'title="' . $tooltip . '"', $link, 1);
        return $link;
    }
    private function _html_wikilink_snippet($id, $name, $snippet) {
        $link = html_wikilink($id, $name);
        $detail = str_replace("\n\n", '<br/>', $snippet);
        $more = html_wikilink($id, 'more...');
        $detail = '<blockquote>' . $detail . $more . '</blockquote>' . DOKU_LF;
        return array($link, $detail);
    }

    private function _abstract($id) {
        $abstract = p_get_metadata($id, 'description abstract', true);
        $abstract = htmlspecialchars($abstract, ENT_QUOTES, 'UTF-8');
        return $abstract;
    }

    /**
     * Parse out the namespace, and convert to a regex for array search
     * -or- ensure that normal search are only within pagename not its namespace
     *
     * @param string $query user page query
     * @return processed query with regex markup as needed for namespace recognition
     */
    private function _parse_ns_query($query) {
        $incl_ns = array();
        $excl_ns = array();
        $page_qry = '';
        $tokens = explode(' ', $query);
        if (count($tokens) == 1) {
            $page_qry = $query;
        } else {
            foreach ($tokens as $token) {
                if (preg_match('/^(?:\^|-ns:)(.+)$/u', $token, $matches)) {
                    $excl_ns[] = $matches[1];
                } elseif (preg_match('/^(?:@|ns:)(.+)$/u', $token, $matches)) {
                    $incl_ns[] = $matches[1];
                } else {
                    $page_qry .= ' ' . $token;
                }
            }
        }
        $page_qry = trim($page_qry);
		if ($page_qry == '*') $page_qry = '.*';
        return array($page_qry, $incl_ns, $excl_ns);
    }

    /**
     * Builds the sorting array: adds extra items for each sorting key
     *
     * @param array     $ids        array of page ids to be sorted
     * @param array     $sortkeys   list of array keys to sort by
     * @param bool      $title      use page heading instead of name for sorting
     * @param bool      $proper     use proper case where possible
     * @param bool      $inwords    show dates in words where possible
     * @param bool      $case       honour case when sorting
     * @param bool      $natsort    natural sorting, the human way
     * @return void
     */
    private function _get_options($ids, $sortkeys, $title, $proper, $inwords, $case, $natsort) {
        global $conf;

        $sort_opts = array();
        $group_opts = array();

        $dformat = array();
        $wformat = array();

        $row = 0;
        $end_col = START_KEY + count($sortkeys);

        foreach ($ids as $id) {
            $meta = p_get_metadata ($id, false, true);
            if ( ! isset($meta['date']['modified'])) {
                $meta['date']['modified'] = $meta['date']['created'];
            }
            // use page heading instead of page name
            if ($title && isset($meta['title'])) {
                $name = $meta['title'];
            } else {
                $name = noNS($id);
            }
            if ($proper == 'name' || $proper == 'both') {
                $name = $this->_proper($name);
            }
            // first column is the basic page id
            $sort_array[$row][ID_KEY] = $id;
            // second column is the display 'name' (used when sorting by 'name')
            // this also avoids rebuilding the display name when building links (DRY)
            $sort_array[$row][NAME_KEY] = $name;
            $col = START_KEY;

            foreach ($sortkeys as $sortkey) {
                $key = $sortkey[0];
                switch ($key) {
                    case 'a':
                        $value = $this->_first($name, 1);
                        break;
                    case 'ab':
                        $value = $this->_first($name, 2);
                        break;
                    case 'abc':
                        $value = $this->_first($name, 3);
                        break;
                    case 'name':
                        // a name column already exists by default (col 1)
                        continue;
                    case 'id':
                    case 'page':
                        $value = $id;
                        break;
                    case 'ns':
                        $value = getNS($id);
                        if (empty($value)) $value = '[' . $conf['start'] . ']';
                        break;
                    case 'creator':
                        $value = $meta['creator'];
                        break;
                    case 'mdate':
                        $value = $meta['date']['modified'];
                        break;
                    case 'cdate':
                        $value = $meta['date']['created'];
                        break;
                    default:
                        // date sorting types (groupable)
                        $dtype = $key[0];
                        if ($dtype == 'c' || $dtype == 'm') {
                            // we only set real date once per id (needed for grouping)
                            // not per sort column--the date should remain same across all columns
                            // this is always the last column!
                            if ($col == START_KEY) {
                                if ($dtype == 'c') {
                                    $date = $meta['date']['created'];
                                } else {
                                    $date = $meta['date']['modified'];
                                }
                                $sort_array[$row][$end_col] = $date;
                            } else {
                                $date = $sort_array[$row][$end_col] ;
                            }
                            // only set date formats once per sort column/key (not per id!)
                            if ($row == 0) {
                                $dformat[$col] = $this->_date_format($key);
                                // collect date in word format for potential use in grouping
                                if ($inwords) {
                                    $wformat[$col] = $this->_date_format_words($dformat[$col]);
                                } else {
                                    $wformat[$col] = '';
                                }
                            }
                            // create a string date used for sorting only
                            // (we cannot just use the real date otherwise it would not group correctly)
                            $value = strftime($dformat[$col], $date);
                        }
                }
                $sort_array[$row][$col] = $value;
                $col++;
            }
            $row++;
        }

        $cnt = START_KEY;
        $order = 0;
        foreach ($sortkeys as $sortkey) {
            list($key, $opt) = $sortkey;

            if ($key == 'name') {
                $col = NAME_KEY;
                // do not incease $cnt so that this col number will be re-used
                // next time through
            } else {
                $col = $cnt;
                $cnt++;
            }
            $sort_opts['key'][] = $col;

            // now the sort direction
            switch ($opt) {
                case 'a':
                case 'asc':
                    $dir = MSORT_ASC;
                    break;
                case 'd':
                case 'desc':
                    $dir = MSORT_DESC;
                    break;
                default:
                    // sort descending by default; text ascending
                    // watch for other sort options beginning with c or m ....!
                    if ($key[0] == 'c' || $key[0] == 'm') {
                        $dir = MSORT_DESC;
                    } else {
                        $dir = MSORT_ASC;
                    }
            }
            $sort_opts['dir'][] = $dir;

            // set the sort array's data type
            $is_ns = false;
            switch ($key) {
                case 'mdate':
                case 'cdate':
                    $type = MSORT_NUMERIC;
                    break;
                default:
                    if ($case) {
                        // case matters: a-z then A-Z
                        $type = ($natsort) ? MSORT_NAT : MSORT_STRING;
                    } else {
                        // case-insensitive
                        $type = ($natsort) ? MSORT_NAT_CASE : MSORT_STRING_CASE;
                    }
            }
            $sort_opts['type'][] = $type;

            // now establish grouping options
            switch ($key) {
                // name strings and full dates cannot be meaningfully grouped (no duplicates!)
                case 'mdate':
                case 'cdate':
                case 'name':
                case 'id':
                case 'page':
                    $group_by = MGROUP_NONE;
                    break;
                case 'ns':
                    $group_by = MGROUP_NAMESPACE;
                    break;
                default:
                    $group_by = MGROUP_HEADING;
            }
            if ($group_by != MGROUP_NONE) {
                $group_opts['key'][$order] = $col;
                $group_opts['type'][$order] = $group_by;
                $group_opts['dformat'][$order] = $wformat[$col];
                $order++;
            }
        }
        return array($sort_array, $sort_opts, $group_opts);
    }

    // returns first $count letters from $text
    private function _first($text, $count) {
        if ($count > 0) {
            return utf8_substr($text, 0, $count);
        }
    }

    /** parse the c|m-year-month-day option
     *
     * @param string  $key
     * @return string
     */
    private function _date_format($key) {
        if (strpos($key, 'year') !== false) $dkey[] = '%Y';
        if (strpos($key, 'month') !== false) $dkey[] = '%m';
        if (strpos($key, 'day') !== false) $dkey[] = '%d';
        $dformat = implode('-', $dkey);
        return $dformat;
    }

    /**
     * provide month and day format in real words if required
     * used for display only; $dformat is used for correct sorting!
     *
     * @param string $dformat
     * @return string
     */
    private function _date_format_words($dformat) {
        $wformat = '';
        switch ($dformat) {
            case '%m':
                $wformat = "%B";
                break;
            case '%d':
                $wformat = "%#d%A ";
                break;
            case '%Y-%m':
                $wformat = "%B %Y";
                break;
            case '%m-%d':
                $wformat= "%B %#d, %A ";
                break;
            case '%Y-%m-%d':
                $wformat = "%A, %B %#d, %Y";
                break;
        }
        return $wformat;
    }

    /**
     * a heavily customised version of _ft_pageLookup in inc/fulltext.php
     * I just removed the preg_quote line to enable regexes in search query...
     * and the unnecessary usort line as I have my own sort routines
     *
     */
    private function _pageLookup($query, $pageonly, $incl_ns, $excl_ns, $nostart = true, $maxns = 0) {
        global $conf;

        $queries = trim($query);
        $pages = file($conf['indexdir'] . '/page.idx');
        // first deal with excluded namespaces, then included
        $pages = $this->_filter_ns($pages, $excl_ns, true);

        // now include ONLY the selected namespaces if provided
        $pages = $this->_filter_ns($pages, $incl_ns, false);

        $cnt = count($pages);
        for ($i = 0; $i < $cnt; $i++) {
            $page = $pages[$i];
            if ( ! page_exists($page) || isHiddenPage($page)) {
                unset($pages[$i]);
                continue;
            }
            if ($pageonly) $page = noNS($page);
            if (preg_match('/' . $query . '/i', $page) == 0) {
                unset($pages[$i]);
            }
        }
        if ( ! count($pages)) return array();

        $pages = array_map('trim',$pages);

        // check ACL permissions and remove any 'start' pages if req'd
        $start = $conf['start'];
        $pos = strlen($start);
        foreach($pages as $idx => $name) {
            if ($this->nostart && substr($name, -$pos) == $start) {
                unset($pages[$idx]);
            } elseif(auth_quickaclcheck(trim($pages[$idx])) < AUTH_READ){
                unset($pages[$idx]);
            } elseif ($this->maxns > 0 && (substr_count($name,':') + 1) > $this->maxns) {
                unset($pages[$idx]);    //skip this page
            }
        }
        return $pages;
    }

    private function _filter_ns($pages, $ns_qry, $exclude) {
        $invert = ($exclude) ? PREG_GREP_INVERT : 0;
        foreach ($ns_qry as $ns) {
            $regexes[] = '.*' . $ns . ':.*';
        }
        if ( ! empty($regexes)) {
            $regex = '/(' . implode('|', $regexes) . ')/';
            return array_values(preg_grep($regex, $pages, $invert));
        } else {
            return $pages;
        }
    }
}

blob
mark :68
data 491
base    pagequery
author  Symon Bent
email   hendrybadao@gmail.com
date    2011-03-20
name    PageQuery Plugin (0.7)
desc    Search for (fulltext) and list wiki pages, sorted and optionally grouped by name, date, creator, abc, etc. in columns. Insert the pagequery markup wherever you want your list to appear.  E.g.{{pagequery>[query;fulltext;sort=key:direction,key2:direction;group;limit=??;cols=?;inwords;proper]}} [..] = optional
url     http://wiki.splitbrain.org/plugin:pagequery
blob
mark :71
data 2425
div.dokuwiki div#pagequery {
    position:relative;
    margin:0 0 1em 0;
    border-width:1px;
}
div.dokuwiki div#pagequery table {
    border-collapse:collapse;
    width:100%;
    margin:0;
}
div.dokuwiki div#pagequery,
div.dokuwiki div#pagequery td {
	border-style:solid;
	border-color:#D7D5D4;
}
div.dokuwiki div#pagequery td {
	padding:8px 10px 20px;
	background-color:white;
    border-width:0 1px 0 0;
}
div.dokuwiki div#pagequery.noborder,
div.dokuwiki div#pagequery td.noborder {
    border-width:0;
}
div.dokuwiki div#pagequery td:nth-last-child(1) {
    border-width:0;
}

div.dokuwiki div#pagequery h1,
div.dokuwiki div#pagequery h2,
div.dokuwiki div#pagequery h3,
div.dokuwiki div#pagequery h4,
div.dokuwiki div#pagequery h5,
div.dokuwiki div#pagequery h6 {
    padding:0.06em 0 0.03em 0;
    margin:0;
    margin-bottom:2px;
    color:#A0A0A0;
}
div.dokuwiki div#pagequery h3,
div.dokuwiki div#pagequery h4,
div.dokuwiki div#pagequery h5,
div.dokuwiki div#pagequery h6 {
    font-weight:normal;
}
div.dokuwiki div#pagequery h1 {
    font-size:134%;
    padding:0px 0px 3px 7px;
    background:#EDEDED;
    -moz-border-radius:6px;
    -webkit-border-radius:6px;
}
div.dokuwiki div#pagequery h2 {font-size:125%; font-weight:bold;}
div.dokuwiki div#pagequery h3 {font-size:114%;}
div.dokuwiki div#pagequery h4 {font-size:108%;}
div.dokuwiki div#pagequery h5 {font-size:100%;}
div.dokuwiki div#pagequery h6 {font-size:95%;}


div.dokuwiki div#pagequery ul {
    list-style:none;
    margin:0 0 8px 0;
	text-align:left;
}
div.dokuwiki div#pagequery ul.nogroup {
    margin:0 0 5px 3px;
}
div.dokuwiki div#pagequery li {
	padding-left:10px;
	list-style-position:inside;
	text-indent:-10px;
    line-height:135%;
}
div.dokuwiki div#pagequery a:hover,
div.dokuwiki div#pagequery blockquote a:hover {
    text-decoration:none;
    color:#202020!important;
}
div.dokuwiki div#pagequery a.top {
    position:absolute;
    bottom:0.4em;;
    right:0.5em;
    font-style:italic;
    color:#A0A0A0;
}
/* credit: blockquote:plugin */
div.dokuwiki div#pagequery blockquote {
    font-size:80%;
	margin: 5px 15px 10px 15px !important;
	border: 1px dotted __border__ !important;
	background: #FAFACE url(images/blockquote.gif) no-repeat 5px 5px !important;
	padding: 10px 15px 15px 18px !important;
    -moz-border-radius: 6px;
    -webkit-border-radius: 6px;
}
div.dokuwiki div#pagequery blockquote a {
    margin-left:12px;
}

blob
mark :72
data 29497
<?php
/**
 * PageQuery Plugin: search for and list pages, sorted/grouped by name, date, creator, etc
 *
 * @license    GPL 2 (http://www.gnu.org/licenses/gpl.html)
 * @author	   Symon Bent <hendrybadao@gmail.com>
 */
// must be run within Dokuwiki
if(!defined('DOKU_INC')) die();

if (!defined('DOKU_LF')) define('DOKU_LF', "\n");
if (!defined('DOKU_TAB')) define('DOKU_TAB', "\t");
if (!defined('DOKU_PLUGIN')) define('DOKU_PLUGIN',DOKU_INC.'lib/plugins/');

require_once(DOKU_PLUGIN . 'syntax.php');
require_once(DOKU_INC . 'inc/fulltext.php');
require_once(DOKU_PLUGIN . 'pagequery/inc/msort.php');

define ('NAME_KEY', 1);
define ('ID_KEY', 0);
define ('START_KEY', 2);
define ('MAX_COLS', 6);

class syntax_plugin_pagequery extends DokuWiki_Syntax_Plugin {
    private $dformat = '';
    private $inwords = false;
    private $nostart = false;
    private $maxns = 0;

	function getType() {
		return 'substition';
	}

	function getPType() {
		return 'block';
	}

	function getSort() {
		return 98;
	}

	function connectTo($mode) {
		//Default is a word cloud style, looks good when combined with plugin:box
		$this->Lexer->addSpecialPattern('\{\{pagequery>.*?\}\}', $mode, 'plugin_pagequery');
	}
    /**
     * Parses all the pagequery options:
     * Insert the pagequery markup wherever you want your list to appear. E.g:
     *
     *   {{pagequery>}}
     *
     *   {{pagequery>[query];fulltext;sort=key:direction,key2:direction;group;limit=??;cols=?;inwords;proper}}
     *
     * Parameters as follows:
     * 1. query:    any expression directly after the >; can use all Dokuwiki search options (see manual)
     * 2. fulltext: use a full-text search, instead of page_id only [default]
     * 3. sort:     keys to sort by, in order of sorting. Each key can be followed by prefered sorting order
     *              available keys:
     *                  a, ab, abc          by 1st letter, 2 letters, or 3 letters
     *                  name                by page name (no namespace) [not grouped]
     *                  page|id             by full page id, including namespace [not grouped]
     *                  ns                  by namespace (without page name)
     *                  mdate, cdate        by modified|created dates (full) [not grouped]
     *                  m[year][month][day] by modified [year][month][day]; any combination accepted
     *                  c[year][month][day] by created [year][month][day]; any combination accepted
     *                  creator             by page author
     *              date sort default to descending, string sorts to ascending
     * 4. group:    show group headers for each change in sort keys
     *              Note: keys with no duplicate cannot be grouped (i.e. name, page|id, mdate, cdate)
     * 5. limit:    maximum number of results to return
     * 6. inwords:  use real month and day names instead of numeric dates
     * 7. cols:     number of columns in displayed list (max = 6)
     * 8. proper:   display page names and namespace in Proper Case (i.e. no _'s and Capitalised)
     *              header/hdr = group headers only, name = page name only, both = both!
     * 9. border:   turn on borders. 'inside' = between columns; 'outside' => border around table;
     *              'both' => in and out; 'none' => neither
     *10. fullregex:only useful on page name searches; allows a raw regex mode on the full page id
     *11. nostart:  ignore any 'start' pages in namespace (based on "config:start")
     *12. maxns:    maximum namespace level to be displayed; e.g. maxns=3 => one:two:three
     *13. title:    show 1st page heading instead of page name
     *14. snippet:  should an excerpt of the wikipage be shown:
     *              use :tooltip to show as a pop-up only
     *              use :<number> to show 1st n items in list with an abstract
     *15. natsort:  use natural sorting order (good for words beginning with numbers)
     *16. case:     respect case when sorting, i.e. a != A when sorting.  a-z then A-Z (opp. to PHP term, easier on novices)
     *
     * All options are optional, and the list will default to a boring long 1-column list...
     */
	function handle($match, $state, $pos, &$handler) {
        global $conf;
        $this->dformat = $conf['dformat'];

		$match = substr($match, 12, -2); // strip markup incl. pagequery>
		$options = explode(';', $match);
        $query = $options[0];

        // establish a few defaults
        $fulltext = false;
        $sort = array();
        $group = false;
        $limit = 0;
        $maxns = 0;
        $cols = 1;
        $proper = 'none';
        $border = 'none';
        $snippet = 'tooltip';
        $title = false;
        $fullregex = false;
        $case = false;
        $natsort = false;

        foreach ($options as $option) {
            list($key, $value) = explode('=', $option);
            switch ($key) {
                case 'fulltext':
                    $fulltext = true;
                    break;
                case 'sort':
                    $values = explode(',', $value);
                    foreach ($values as $value) {
                        list($key, $dir) = explode(':', $value);
                        $sort[] = array($key, $dir);
                    }
                    break;
                case 'group':
                    $group = true;
                    break;
                case 'limit':
                    $limit = $value;
                    break;
                case 'maxns':
                    $maxns = $value;
                    break;
                case 'inwords':
                    $inwords = true;
                    break;
                case 'proper':
                    switch ($value) {
                        case 'hdr':
                        case 'header':
                        case 'group':
                            $proper = 'header';
                            break;
                        case 'name':
                        case 'page':
                            $proper = 'name';
                            break;
                        default:
                            $proper = 'both';
                    }
                    break;
                case 'cols':
                    $cols = ($value > MAX_COLS) ? MAX_COLS : $value;
                    break;
                case 'border':
                    switch ($value) {
                        case 'none':
                        case 'inside':
                        case 'outside':
                        case 'both':
                            $border = $value;
                            break;
                        default:
                            $border = 'both';
                    }
                    break;
				case 'fullregex':
					$fullregex = true;
					break;
                case 'nostart':
                    $nostart = true;
                    break;
                case 'title':
                    $title = true;
                    break;
                case 'abstract':    // old syntax, to be deprecated (2011-03-15)
                case 'snippet':
                    switch ($value) {
                        case '':
                        case 'tooltip':
                            $snippet = 'tooltip';
                            break;
                        default:
                            if ($value >= 0) {
                                $snippet = $value;
                            }
                    }
                    break;
                case 'case':
                    $case = true;
                    break;
                case 'natsort':
                    $natsort = true;
                    break;
            }
        }
		return array($query, $fulltext, $sort, $group, $limit, $maxns, $proper,
                      $cols, $inwords, $border, $fullregex, $nostart, $title,
                      $snippet, $case, $natsort);
	}

    function render($mode, &$renderer, $data) {
        $sortkeys = array();
        $incl_ns = array();
        $excl_ns = array();

        list($query, $fulltext, $sort, $group, $limit, $maxns, $proper,
              $cols, $inwords, $border, $fullregex, $nostart, $title,
              $snippet, $case, $natsort) = $data;

        if ($mode == 'xhtml') {
            // first get a raw list of matching results
            if ($fulltext) {
                $results = array_keys(ft_pageSearch($query, $highlight));
            } else {
                // allow for raw regex mode, for power users, this searches the full page id
                if ($fullregex) {
                    $pageonly = false;
                } else {
                    list($query, $incl_ns, $excl_ns) = $this->_parse_ns_query($query);
                    $pageonly = true;
                }
                $results = $this->_pageLookup($query, $pageonly, $incl_ns, $excl_ns, $nostart, $maxns);
            }

            // basic result page markup (always needed)
            $noborder_css = ' class="noborder" ';
            $border_style = ($border == 'outside' || $border == 'both') ? '' : $noborder_css;
            $renderer->doc .= '<div id="pagequery" ' . $border_style . '>' . DOKU_LF;
            // fixed point to jump back to at top of the table
            $top_id = 'top-' . mt_rand();
            $renderer->doc .= '<table id="' . $top_id . '"><tbody><tr>' . DOKU_LF;

            if ( ! empty($results)) {
                // this section is where the essential pagequery functionality happens...

                // prepare the necessary sorting arrays, as per users options
                list($sort_array, $sort_opts, $group_opts) =
                    $this->_get_options($results, $sort, $title, $proper, $inwords, $case, $natsort);

                // now do the sorting
                msort($sort_array, $sort_opts);

                // limit the result list length if required; this can only be done after sorting!
                $sort_array = ($limit > 0) ? array_slice($sort_array, 0, $limit) : $sort_array;

                // and finally the grouping
                if ($group) {
                    $sorted_results = mgroup($sort_array, $group_opts);
                } else {
                    foreach ($sort_array as $row) {
                        $sorted_results[] = array(0, $row[NAME_KEY], $row[ID_KEY]);
                    }
                }

                // now render the actual result list
                $was_heading = false;
                $cont_level = 1;
                $idx = 0;
                $col = 0;
                $rows = ceil(count($sorted_results) / $cols);  // proposed column row size
                $width = floor(100 / $cols);
                $snippet_cnt = 0;    // needed by the snippet section
                $jump_txt= $this->getLang('jump_section');
                $border_style = ($border == 'inside' || $border == 'both') ? '' : $noborder_css;

                foreach ($sorted_results as $line) {
                    list($level, $name, $id) = $line;

                    // are we ready to start a new column? (up to max allowed)
                    if ($col < $cols && $idx % $rows == 0) {
                        $ready_for_col = true;
                        $col++;
                    }
                    $is_heading = ($level > 0);
                    if ($is_heading) {
                        $heading = $name;
                        if ($proper == 'header' || $proper == 'both') $heading = $this->_proper($heading);
                    }
                    if ($group === false) {
                        $indent_style = ' class="nogroup"';
                    } else {
                        $indent = ($is_heading) ? $level - 1 : $cont_level - 1;
                        $indent_style = ' style="margin-left:' . $indent * 10 . 'px"';
                    }
                    // Begin new column if: 1.we are at the start, 2.at a heading or 3.if there is no grouping
                    if ($ready_for_col && ! $was_heading) {
                        $jump_tip = sprintf($jump_txt, $heading);
                        // close the previous column if necessary; also add a 'jump to anchor'
                        $cont_close = ( ! $is_heading) ? '<a title="'. $jump_tip . '" href="#' .
                                        $top_id . '">' . "<h$cont_level>... </h$cont_level></a>" : '';
                        $cont_open = ($idx > 0 && ! $is_heading) ? "<h$cont_level$indent_style>" . "$heading...</h$cont_level>" : '';
                        $close = ($idx > 0) ? $cont_close . '</ul></td>' . DOKU_LF : '';
                        $renderer->doc .= $close . '<td' . $border_style . ' valign="top" width="' . $width . '%">' . $cont_open . DOKU_LF;
                        $ready_for_col = false;
                        $was_heading = true;    //needed to begin a new page id list
                    }
                    if ($is_heading) {
                        // close previous sub list if necessary
                        if ( ! $was_heading) {
                            $renderer->doc .= '</ul>' . DOKU_LF;
                        }
                        $renderer->doc .= "<h$level$indent_style>$heading</h$level>" . DOKU_LF;
                        $was_heading = true;
                        $cont_level = $level + 1;
                    } else {
                        // open a new sub list if necessary
                        if ($was_heading || $idx == 0) {
                            $renderer->doc .= "<ul$indent_style>";
                        }
                        // deal with normal page links
                        $link = $this->_render_wikilink($id, $name, $snippet, $snippet_cnt);
                        $snippet_cnt++;
                        $renderer->doc .= $link;
                        $was_heading = false;
                    }
                    $idx++;
                }
                $renderer->doc .= '</ul></td>';
            } else {
                // display a "no results" message if empty
                $renderer->doc .= '<td><p>' . $this->getLang("no_results") .
                                  '"<strong>' . $query . '</strong>"</p></td>' . DOKU_LF;
            }
            $renderer->doc .= '</tr>' . DOKU_LF;
            $renderer->doc .= '</tbody></table>';
            $renderer->doc .= '<a class="top" href="#' . $top_id . '">' . $this->getLang('link_to_top') . '</a>';
            $renderer->doc .= '</div>' . DOKU_LF;
            return true;
        } else {
            return false;
        }
    }

    /**
     * Renders the page link, plus tooltip, abstract, casing, etc...
     * @param string $id
     * @param bool  $proper
     * @param bool  $title
     * @param mixed $abstract
     */
    private function _render_wikilink($id, $name, $snippet, $snippet_cnt) {

        $id = (strpos($id, ':') === false) ? ':' . $id : $id;   // : needed for root pages

        // show the "snippet" as a tooltip
        // -or- as a nice quoted snippet ( la blockquote plugin)
        $box = '';
        if ($snippet != 'none') {
            $abstract = $this->_abstract($id);
            if ($snippet == 'tooltip' || ($snippet > 0 && $snippet_cnt >= $snippet)) {
                $link = $this->_html_wikilink_tooltip($id, $name, $abstract);
            } elseif ($snippet == 'all' || ($snippet >= 0 && $snippet_cnt < $snippet)) {
                list($link, $box) = $this->_html_wikilink_snippet($id, $name, $abstract);
            }
        } else {
            $link = html_wikilink($id, $name);
        }
        return '<li>' . $link . '</li>' . DOKU_LF . $box;
    }

    private function _proper($id) {
         $id = str_replace(':', ': ', $id);
         $id = str_replace('_', ' ', $id);
         $id = ucwords($id);
         $id = str_replace(': ', ':', $id);
         return $id;
    }
    /**
     * swap normal link title (popup) for a more useful preview
     *
     * @param string $id    page id
     * @param string $name  display name
     * @return complete href link
     */
    private function _html_wikilink_tooltip($id, $name, $tooltip) {
        $link = html_wikilink($id, $name);
        $tooltip = str_replace("\n", '  ', $tooltip);
        $link = preg_replace('/title=\".+?\"/', 'title="' . $tooltip . '"', $link, 1);
        return $link;
    }
    private function _html_wikilink_snippet($id, $name, $snippet) {
        $link = html_wikilink($id, $name);
        $detail = str_replace("\n\n", '<br/>', $snippet);
        $more = html_wikilink($id, 'more...');
        $detail = '<blockquote>' . $detail . $more . '</blockquote>' . DOKU_LF;
        return array($link, $detail);
    }

    private function _abstract($id) {
        $abstract = p_get_metadata($id, 'description abstract', true);
        $abstract = htmlspecialchars($abstract, ENT_QUOTES, 'UTF-8');
        return $abstract;
    }

    /**
     * Parse out the namespace, and convert to a regex for array search
     * -or- ensure that normal search are only within pagename not its namespace
     *
     * @param string $query user page query
     * @return processed query with regex markup as needed for namespace recognition
     */
    private function _parse_ns_query($query) {
        $incl_ns = array();
        $excl_ns = array();
        $page_qry = '';
        $tokens = explode(' ', $query);
        if (count($tokens) == 1) {
            $page_qry = $query;
        } else {
            foreach ($tokens as $token) {
                if (preg_match('/^(?:\^|-ns:)(.+)$/u', $token, $matches)) {
                    $excl_ns[] = $matches[1];
                } elseif (preg_match('/^(?:@|ns:)(.+)$/u', $token, $matches)) {
                    $incl_ns[] = $matches[1];
                } else {
                    $page_qry .= ' ' . $token;
                }
            }
        }
        $page_qry = trim($page_qry);
		if ($page_qry == '*') $page_qry = '.*';
        return array($page_qry, $incl_ns, $excl_ns);
    }

    /**
     * Builds the sorting array: adds extra items for each sorting key
     *
     * @param array     $ids        array of page ids to be sorted
     * @param array     $sortkeys   list of array keys to sort by
     * @param bool      $title      use page heading instead of name for sorting
     * @param bool      $proper     use proper case where possible
     * @param bool      $inwords    show dates in words where possible
     * @param bool      $case       honour case when sorting
     * @param bool      $natsort    natural sorting, the human way
     * @return void
     */
    private function _get_options($ids, $sortkeys, $title, $proper, $inwords, $case, $natsort) {
        global $conf;

        $sort_opts = array();
        $group_opts = array();

        $dformat = array();
        $wformat = array();

        $row = 0;
        $end_col = START_KEY + count($sortkeys);

        foreach ($ids as $id) {
            $meta = p_get_metadata ($id, false, true);
            if ( ! isset($meta['date']['modified'])) {
                $meta['date']['modified'] = $meta['date']['created'];
            }
            // use page heading instead of page name
            if ($title && isset($meta['title'])) {
                $name = $meta['title'];
            } else {
                $name = noNS($id);
            }
            if ($proper == 'name' || $proper == 'both') {
                $name = $this->_proper($name);
            }
            // first column is the basic page id
            $sort_array[$row][ID_KEY] = $id;
            // second column is the display 'name' (used when sorting by 'name')
            // this also avoids rebuilding the display name when building links (DRY)
            $sort_array[$row][NAME_KEY] = $name;
            $col = START_KEY;

            foreach ($sortkeys as $sortkey) {
                $key = $sortkey[0];
                switch ($key) {
                    case 'a':
                        $value = $this->_first($name, 1);
                        break;
                    case 'ab':
                        $value = $this->_first($name, 2);
                        break;
                    case 'abc':
                        $value = $this->_first($name, 3);
                        break;
                    case 'name':
                        // a name column already exists by default (col 1)
                        continue;
                    case 'id':
                    case 'page':
                        $value = $id;
                        break;
                    case 'ns':
                        $value = getNS($id);
                        if (empty($value)) $value = '[' . $conf['start'] . ']';
                        break;
                    case 'creator':
                        $value = $meta['creator'];
                        break;
                    case 'mdate':
                        $value = $meta['date']['modified'];
                        break;
                    case 'cdate':
                        $value = $meta['date']['created'];
                        break;
                    default:
                        // date sorting types (groupable)
                        $dtype = $key[0];
                        if ($dtype == 'c' || $dtype == 'm') {
                            // we only set real date once per id (needed for grouping)
                            // not per sort column--the date should remain same across all columns
                            // this is always the last column!
                            if ($col == START_KEY) {
                                if ($dtype == 'c') {
                                    $date = $meta['date']['created'];
                                } else {
                                    $date = $meta['date']['modified'];
                                }
                                $sort_array[$row][$end_col] = $date;
                            } else {
                                $date = $sort_array[$row][$end_col] ;
                            }
                            // only set date formats once per sort column/key (not per id!)
                            if ($row == 0) {
                                $dformat[$col] = $this->_date_format($key);
                                // collect date in word format for potential use in grouping
                                if ($inwords) {
                                    $wformat[$col] = $this->_date_format_words($dformat[$col]);
                                } else {
                                    $wformat[$col] = '';
                                }
                            }
                            // create a string date used for sorting only
                            // (we cannot just use the real date otherwise it would not group correctly)
                            $value = strftime($dformat[$col], $date);
                        }
                }
                $sort_array[$row][$col] = $value;
                $col++;
            }
            $row++;
        }

        $cnt = START_KEY;
        $order = 0;
        foreach ($sortkeys as $sortkey) {
            list($key, $opt) = $sortkey;

            if ($key == 'name') {
                $col = NAME_KEY;
                // do not incease $cnt so that this col number will be re-used
                // next time through
            } else {
                $col = $cnt;
                $cnt++;
            }
            $sort_opts['key'][] = $col;

            // now the sort direction
            switch ($opt) {
                case 'a':
                case 'asc':
                    $dir = MSORT_ASC;
                    break;
                case 'd':
                case 'desc':
                    $dir = MSORT_DESC;
                    break;
                default:
                    // sort descending by default; text ascending
                    // watch for other sort options beginning with c or m ....!
                    if ($key[0] == 'c' || $key[0] == 'm') {
                        $dir = MSORT_DESC;
                    } else {
                        $dir = MSORT_ASC;
                    }
            }
            $sort_opts['dir'][] = $dir;

            // set the sort array's data type
            $is_ns = false;
            switch ($key) {
                case 'mdate':
                case 'cdate':
                    $type = MSORT_NUMERIC;
                    break;
                default:
                    if ($case) {
                        // case matters: a-z then A-Z
                        $type = ($natsort) ? MSORT_NAT : MSORT_STRING;
                    } else {
                        // case-insensitive
                        $type = ($natsort) ? MSORT_NAT_CASE : MSORT_STRING_CASE;
                    }
            }
            $sort_opts['type'][] = $type;

            // now establish grouping options
            switch ($key) {
                // name strings and full dates cannot be meaningfully grouped (no duplicates!)
                case 'mdate':
                case 'cdate':
                case 'name':
                case 'id':
                case 'page':
                    $group_by = MGROUP_NONE;
                    break;
                case 'ns':
                    $group_by = MGROUP_NAMESPACE;
                    break;
                default:
                    $group_by = MGROUP_HEADING;
            }
            if ($group_by != MGROUP_NONE) {
                $group_opts['key'][$order] = $col;
                $group_opts['type'][$order] = $group_by;
                $group_opts['dformat'][$order] = $wformat[$col];
                $order++;
            }
        }
        return array($sort_array, $sort_opts, $group_opts);
    }

    // returns first $count letters from $text
    private function _first($text, $count) {
        if ($count > 0) {
            return utf8_substr($text, 0, $count);
        }
    }

    /** parse the c|m-year-month-day option
     *
     * @param string  $key
     * @return string
     */
    private function _date_format($key) {
        if (strpos($key, 'year') !== false) $dkey[] = '%Y';
        if (strpos($key, 'month') !== false) $dkey[] = '%m';
        if (strpos($key, 'day') !== false) $dkey[] = '%d';
        $dformat = implode('-', $dkey);
        return $dformat;
    }

    /**
     * provide month and day format in real words if required
     * used for display only; $dformat is used for correct sorting!
     *
     * @param string $dformat
     * @return string
     */
    private function _date_format_words($dformat) {
        $wformat = '';
        switch ($dformat) {
            case '%m':
                $wformat = "%B";
                break;
            case '%d':
                $wformat = "%#d%A ";
                break;
            case '%Y-%m':
                $wformat = "%B %Y";
                break;
            case '%m-%d':
                $wformat= "%B %#d, %A ";
                break;
            case '%Y-%m-%d':
                $wformat = "%A, %B %#d, %Y";
                break;
        }
        return $wformat;
    }

    /**
     * a heavily customised version of _ft_pageLookup in inc/fulltext.php
     * I just removed the preg_quote line to enable regexes in search query...
     * and the unnecessary usort line as I have my own sort routines
     *
     */
    private function _pageLookup($query, $pageonly, $incl_ns, $excl_ns, $nostart = true, $maxns = 0) {
        global $conf;

        $queries = trim($query);
        $pages = file($conf['indexdir'] . '/page.idx');
        // first deal with excluded namespaces, then included
        $pages = $this->_filter_ns($pages, $excl_ns, true);

        // now include ONLY the selected namespaces if provided
        $pages = $this->_filter_ns($pages, $incl_ns, false);

        $cnt = count($pages);
        for ($i = 0; $i < $cnt; $i++) {
            $page = $pages[$i];
            if ( ! page_exists($page) || isHiddenPage($page)) {
                unset($pages[$i]);
                continue;
            }
            if ($pageonly) $page = noNS($page);
            if (preg_match('/' . $query . '/i', $page) == 0) {
                unset($pages[$i]);
            }
        }
        if ( ! count($pages)) return array();

        $pages = array_map('trim',$pages);

        // check ACL permissions and remove any 'start' pages if req'd
        $start = $conf['start'];
        $pos = strlen($start);
        foreach($pages as $idx => $name) {
            if ($this->nostart && substr($name, -$pos) == $start) {
                unset($pages[$idx]);
            } elseif(auth_quickaclcheck(trim($pages[$idx])) < AUTH_READ){
                unset($pages[$idx]);
            } elseif ($this->maxns > 0 && (substr_count($name,':') + 1) > $this->maxns) {
                unset($pages[$idx]);    //skip this page
            }
        }
        return $pages;
    }

    private function _filter_ns($pages, $ns_qry, $exclude) {
        $invert = ($exclude) ? PREG_GREP_INVERT : 0;
        foreach ($ns_qry as $ns) {
            $regexes[] = '.*' . $ns . ':.*';
        }
        if ( ! empty($regexes)) {
            $regex = '/(' . implode('|', $regexes) . ')/';
            return array_values(preg_grep($regex, $pages, $invert));
        } else {
            return $pages;
        }
    }
}

blob
mark :74
data 10872
<?php
// keep key associations
define('MSORT_KEEP_ASSOC', 'msort01');

// additional sorting type
define('MSORT_NUMERIC', 'msort02');
define('MSORT_REGULAR', 'msort03');
define('MSORT_STRING', 'msort04');
define('MSORT_STRING_CASE', 'msort05'); // case insensitive
define('MSORT_NAT', 'msort06');         // natural sorting
define('MSORT_NAT_CASE', 'msort07');    // natural sorting, case insensitive

define('MSORT_ASC', 'msort08');
define('MSORT_DESC', 'msort09');

define('MSORT_DEFAULT_DIRECTION', MSORT_ASC);
define('MSORT_DEFAULT_TYPE', MSORT_STRING);

/**
 * A replacement for array_mulitsort which permits natural and caseless sorting
 * This function will sort an 'array of rows' only (not array of 'columns')
 *
 * @param array $sort_array  : multi-dimensional array of arrays, where the first index refers to the row number
 *                             and the second to the column number (e.g. $array[row_number][column_number])
 *                             i.e. = array(
 *                                          array('name1', 'job1', 'start_date1', 'rank1'),
 *                                          array('name2', 'job2', 'start_date2', 'rank2'),
 *                                          ...
 *                                          );
 *
 * @param mixed $sort_opts   : options for how the array should be sorted
 *                   : AS ARGS
 *                             $key, $type, $direction [,$key2, $type2, $direction2, ...etc], $assoc
 *                             $key      = key/column to sort by
 *                             $type     = sorting type, one of following:
 *                                           MSORT_NUMERIC
 *                                           MSORT_REGULAR
 *                                           MSORT_STRING
 *                                           MSORT_STRING_CASE  : caseless sorting
 *                                           MSORT_NAT          : natural sorting
 *                                           MSORT_NAT_CASE
 *                             $direction = sorting direction:
 *                                           MSORT_ASC
 *                                           MSORT_DESC
 *                             $assoc     = keep associative array keys (uasort)
 *                                           MSORT_KEEP_ASSOC
 *                    :AS ARRAY
 *                             $sort_opts['key'][<column>] = 'key'
 *                             $sort_opts['type'][<column>] = 'type'
 *                             $sort_opts['dir'][<column>] = 'dir'
 *                             $sort_opts['assoc'][<column>] = MSORT_KEEP_ASSOC | true
 * @return boolean
 */

function msort(&$sort_array, $sort_opts) {

    // if a full sort_opts array was passed
    if (is_array($sort_opts)) {
        if (isset($sort_opts['assoc'])) {
            $keep_assoc = true;
        }
    // else separate the options from the function args
    } else {
        $args = func_get_args();

        if (end($args) == MSORT_KEEP_ASSOC) {
            $keep_assoc = true;
            array_pop($args);
        }

        // make sure there is something to sort
        if (empty($args)) return true;

        $type_enums = array(
                           MSORT_NUMERIC,
                           MSORT_REGULAR,
                           MSORT_STRING,
                           MSORT_STRING_CASE,
                           MSORT_NAT,
                           MSORT_NAT_CASE
                           );
        $direction_enums = array(
                                MSORT_ASC,
                                MSORT_DESC
                                );

        // work through the args list (SORT_KEY, SORT_TYPE, SORT_DIRECTION)
        $order = -1;
        foreach ($args as $arg) {
            // is it a sort direction?
            if (in_array($arg, $direction_enums)) {
                $sort_opts['dir'][$order] = $arg;
            // is it a sort type?
            } elseif (in_array($arg, $type_enums)) {
                $sort_opts['type'][$order] = $arg;
            // is it a sort array?
            } elseif (is_numeric($arg)) {
                $order++;
                $sort_opts['key'][$order] = $arg;
                $sort_opts['type'][$order] = MSORT_DEFAULT_TYPE;
                $sort_opts['dir'][$order] = MSORT_DEFAULT_DIRECTION;
            }
        }
    }

    // Determine which u..sort function (with or without associations).
    $sort_func = ($keep_assoc) ? 'uasort' : 'usort';

    // Sort the data and get the result.
    $result = $sort_func (
        $sort_array,
        function(array &$left, array &$right) use($sort_opts) {

            // Assume that the entries are the same.
            $cmp = 0;

            // Work through each sort column
            foreach($sort_opts['key'] as $idx => $key) {

                // Handle the different sort types.
                switch ($sort_opts['type'][$idx]) {
                    case MSORT_NUMERIC:
                        $key_cmp = ((intval($left[$key]) == intval($right[$key])) ? 0 :
                                   ((intval($left[$key]) < intval($right[$key])) ? -1 : 1 ) );
                        break;

                    case MSORT_STRING:
                        $key_cmp = strcmp((string)$left[$key], (string)$right[$key]);
                        break;

                    case MSORT_STRING_CASE: //case-insensitive
                        $key_cmp = strcasecmp((string)$left[$key], (string)$right[$key]);
                        break;

                    case MSORT_NAT:
                        $key_cmp = strnatcmp((string)$left[$key], (string)$right[$key]);
                        break;

                    case MSORT_NAT_CASE:    //case-insensitive
                        $key_cmp = strnatcasecmp((string)$left[$key], (string)$right[$key]);
                        break;

                    case MSORT_REGULAR:
                    default :
                        $key_cmp = (($left[$key] == $right[$key]) ? 0 :
                                   (($left[$key] < $right[$key]) ? -1 : 1 ) );
                    break;
                }

                // Is the column in the two arrays the same?
                if ($key_cmp == 0) {
                    continue;
                }

                // Are we sorting descending?
                $cmp = $key_cmp * (($sort_opts['dir'][$idx] == MSORT_DESC) ? -1 : 1);

                // no need for remaining keys as there was a difference
                break;
            }
            return $cmp;
        }
    );
	return $result;
}



// grouping types
define ('MGROUP_NONE', 'mgrp00');
define ('MGROUP_HEADING', 'mgrp01');
define ('MGROUP_NAMESPACE', 'mgrp02');

/**
 * group a multi-dimensional array by each level heading
 * @param array $sort_array : array to be grouped (result of 'msort' function)
 *                             last column should contain real dates if you need dates in words
 * @param mixed $group_opts :
 *                    AS ARGS:
 *                             key, type, dformat [,order, type, dformat]... [,real_dates]
 *                              key      = group by key/column
 *                              type     = one of the MGROUP types
 *                              dformat  = date format (if used)
 *                   AS ARRAY:
 *                             $group_opts['key'][<order>] = column key to group by
 *                             $group_opts['type'][<order>] = grouping type [MGROUP...]
 *                             $group_opts['dformat'][<order>] = date formatting string
 *
 * @return array $results   : array of arrays: (level, display_name, page_id), e.g. array(1, 'Main Title')
 *                              array(0, '...') =>  0 = normal row item (not heading)
 */
function mgroup(&$sort_array, $group_opts) {

    // if complete option array was provided
    if (is_array($group_opts)) {
        $level = count($group_opts['key']) - 1;

    // if not presume the above, one-by-one format
    } else {
        $args = func_get_args();

        $type_enums = array(
                            MGROUP_HEADING,
                            MGROUP_NAMESPACE,
                            );

        // get all the grouping options
        // order (which key/column), type (grouping type see MGROUP_...), dformat (real date display format),... repeated
        $group_opts = array();
        $order = -1;
        foreach ($args as $arg) {
            if (is_numeric($arg)) {
                $order++;
                $group_opts['key'][$order] = $arg;
                $group_opts['type'] [$order]= MGROUP_HEADING; // defaults
                $group_opts['dformat'] [$order]= '';
            } elseif ($order > -1) {
                if (in_array($arg, $type_enums)) {
                    $group_opts['type'][$order] = $arg;
                } else {
                    $group_opts['dformat'][$order] = $arg;
                }
            }
        }
        $level = $order;
    }

    $prevs = array();
    $results = array();
    $idx = 0;

    foreach($sort_array as $row) {
        _add_heading($results, $sort_array, $group_opts, $level, $idx, $prevs);
        $results[] = array(0, $row[NAME_KEY], $row[ID_KEY]);
        $idx++;
    }
    return $results;
}

/**
 * private function used by mgroup only!
 */
function _add_heading(&$results, &$sort_array, &$group_opts, $level, $idx, &$prevs) {
    static $end_col = 0;

    // recurse to find all parent headings
    if ($level > 0) {
        _add_heading($results, $sort_array, $group_opts, $level - 1, $idx, $prevs);
    }
    $group_type = $group_opts['type'][$level];

    $prev = (isset($prevs[$level])) ? $prevs[$level] : '';
    $key = $group_opts['key'][$level];
    $cur = $sort_array[$idx][$key];
    if ($cur != $prev) {
        $prevs[$level] = $cur;

        if ($group_type === MGROUP_HEADING) {
            $date_format = $group_opts['dformat'][$level];
            if ( ! empty($date_format)) {
                // the real date is always the last column (or item in array row)
                // static is used to avoid checking array length repeatedly
                if ($end_col == 0) $end_col = count($sort_array[0]) - 1;
                $cur = strftime($date_format, $sort_array[$idx][$end_col]);
            }
            $results[] = array($level + 1, $cur, '');

        } elseif ($group_type === MGROUP_NAMESPACE) {
            $cur_ns = explode(':', $cur);
            $prev_ns = explode(':', $prev);
            // only show namespaces that are different from the previous heading
            for ($i= 0; $i < count($cur_ns); $i++) {
                if ($cur_ns[$i] != $prev_ns[$i]) {
                    $hl = $level + $i + 1;
                    $results[] = array($hl , $cur_ns[$i], '');
                }
            }
        }
    }
}
?>
blob
mark :76
data 2785
div.dokuwiki div#pagequery {
    position:relative;
    margin:0 0 1em 0;
    border-width:1px;
}
div.dokuwiki div#pagequery table {
    border-collapse:collapse;
    width:100%;
    margin:0;
}
div.dokuwiki div#pagequery,
div.dokuwiki div#pagequery td {
	border-style:solid;
	border-color:#D7D5D4;
}
div.dokuwiki div#pagequery td {
	padding:8px 10px 20px;
	background-color:white;
    border-width:0 1px 0 0;
}
div.dokuwiki div#pagequery.noborder,
div.dokuwiki div#pagequery td.noborder {
    border-width:0;
}
div.dokuwiki div#pagequery td:nth-last-child(1) {
    border-width:0;
}

div.dokuwiki div#pagequery h1,
div.dokuwiki div#pagequery h2,
div.dokuwiki div#pagequery h3,
div.dokuwiki div#pagequery h4,
div.dokuwiki div#pagequery h5,
div.dokuwiki div#pagequery h6 {
    padding:0.06em 0 0.03em 0;
    margin:0;
    margin-bottom:2px;
    color:#A0A0A0;
}
div.dokuwiki div#pagequery h3,
div.dokuwiki div#pagequery h4,
div.dokuwiki div#pagequery h5,
div.dokuwiki div#pagequery h6 {
    font-weight:normal;
}
div.dokuwiki div#pagequery h1 {
    font-size:134%;
    padding:0px 0px 3px 7px;
    background:#EDEDED;
    -moz-border-radius:6px;
    -webkit-border-radius:6px;
}
div.dokuwiki div#pagequery h2 {font-size:125%; font-weight:bold;}
div.dokuwiki div#pagequery h3 {font-size:114%;}
div.dokuwiki div#pagequery h4 {font-size:108%;}
div.dokuwiki div#pagequery h5 {font-size:100%;}
div.dokuwiki div#pagequery h6 {font-size:95%;}


div.dokuwiki div#pagequery ul {
    list-style:none;
    margin:0 0 8px 0;
	text-align:left;
}
div.dokuwiki div#pagequery ul.nogroup {
    margin:0 0 5px 3px;
}
div.dokuwiki div#pagequery li {
	padding-left:10px;
	list-style-position:inside;
	text-indent:-10px;
    line-height:135%;
}
div.dokuwiki div#pagequery a:hover,
div.dokuwiki div#pagequery blockquote a:hover {
    text-decoration:none;
    color:#202020!important;
}
div.dokuwiki div#pagequery a.top {
    position:absolute;
    bottom:0.4em;;
    right:0.5em;
    font-style:italic;
    color:#A0A0A0;
}
/* credit: blockquote:plugin */
div.dokuwiki div#pagequery blockquote {
    font-size:80%;
	margin:5px 15px 10px 15px !important;
	border:1px dotted __border__ !important;
	background:#FAFACE url(images/blockquote.gif) no-repeat 5px 5px !important;
	padding:10px 15px 15px 18px !important;
    -moz-border-radius:6px;
    -webkit-border-radius:6px;
}
div.dokuwiki div#pagequery blockquote a {
    margin-left:12px;
}
div.dokuwiki div#pagequery p.noresults {
    color:#899BB2 !important;
    font-size:1.2em;
    margin-left:1.2em;
}
div.dokuwiki div#pagequery p.noresults span {
    font-size:0.8em;
    line-height:1.2em;
    font-style:italic;
    padding:3px 6px;
    margin-right:0.3em;
    background-color:#EDEDED;
    -moz-border-radius:3px;
    -webkit-border-radius:3px;
}

blob
mark :77
data 31009
<?php
/**
 * PageQuery Plugin: search for and list pages, sorted/grouped by name, date, creator, etc
 *
 * @license    GPL 2 (http://www.gnu.org/licenses/gpl.html)
 * @author	   Symon Bent <hendrybadao@gmail.com>
 */

// must be run within Dokuwiki
if(!defined('DOKU_INC')) die();

if (!defined('DOKU_LF')) define('DOKU_LF', "\n");
if (!defined('DOKU_TAB')) define('DOKU_TAB', "\t");
if (!defined('DOKU_PLUGIN')) define('DOKU_PLUGIN',DOKU_INC.'lib/plugins/');

require_once(DOKU_PLUGIN . 'syntax.php');
require_once(DOKU_INC . 'inc/fulltext.php');
require_once(DOKU_PLUGIN . 'pagequery/inc/msort.php');

define ('ID_KEY', 0);
define ('NAME_KEY', 1);
define ('START_KEY', 2);
define ('MAX_COLS', 6);

class syntax_plugin_pagequery extends DokuWiki_Syntax_Plugin {

	function getType() {
		return 'substition';
	}

	function getPType() {
		return 'block';
	}

	function getSort() {
		return 98;
	}

	function connectTo($mode) {
		$this->Lexer->addSpecialPattern('\{\{pagequery>.*?\}\}', $mode, 'plugin_pagequery');
	}

    /**
     * Parses all the pagequery options:
     * Insert the pagequery markup wherever you want your list to appear. E.g:
     *
     *   {{pagequery>}}
     *
     *   {{pagequery>[query];fulltext;sort=key:direction,key2:direction;group;limit=??;cols=?;inwords;proper}}
     *
     * Parameters as follows:
     * 1. query:    any expression directly after the >; can use all Dokuwiki search options (see manual)
     * 2. fulltext: use a full-text search, instead of page_id only [default]
     * 3. sort:     keys to sort by, in order of sorting. Each key can be followed by prefered sorting order
     *              available keys:
     *                  a, ab, abc          by 1st letter, 2 letters, or 3 letters
     *                  name                by page name (no namespace) or 1st heading [not grouped]
     *                  page|id             by full page id, including namespace [not grouped]
     *                  ns                  by namespace (without page name)
     *                  mdate, cdate        by modified|created dates (full) [not grouped]
     *                  m[year][month][day] by modified [year][month][day]; any combination accepted
     *                  c[year][month][day] by created [year][month][day]; any combination accepted
     *                  creator             by page author
     *              date sort default to descending, string sorts to ascending
     * 4. group:    show group headers for each change in sort keys
     *              Note: keys with no duplicate cannot be grouped (i.e. name, page|id, mdate, cdate)
     * 5. limit:    maximum number of results to return
     * 6. inwords:  use real month and day names instead of numeric dates
     * 7. cols:     number of columns in displayed list (max = 6)
     * 8. proper:   display page names and namespace in Proper Case (i.e. no _'s and Capitalised)
     *              header/hdr = group headers only, name = page name only, both = both!
     * 9. border:   turn on borders. 'inside' = between columns; 'outside' => border around table;
     *              'both' => in and out; 'none' => neither
     *10. fullregex:only useful on page name searches; allows a raw regex mode on the full page id
     *11. nostart:  ignore any 'start' pages in namespace (based on "config:start")
     *12. maxns:    maximum namespace level to be displayed; e.g. maxns=3 => one:two:three
     *13. title:    show 1st page heading instead of page name
     *14. snippet:  should an excerpt of the wikipage be shown:
     *              use :tooltip to show as a pop-up only
     *              use :<number> to show 1st n items in list with an abstract
     *15. natsort:  use natural sorting order (good for words beginning with numbers)
     *16. case:     respect case when sorting, i.e. a != A when sorting.  a-z then A-Z (opp. to PHP term, easier on novices)
     *
     * All options are optional, and the list will default to a boring long 1-column list...
     */
	function handle($match, $state, $pos, &$handler) {

		$match = substr($match, 12, -2); // strip markup "{{pagequery>"
		$options = explode(';', $match);
        $query = $options[0];

        // establish some basic option defaults
        $sort = array();
        $fulltext = false;
        $group = false;
        $limit = 0;
        $maxns = 0;
        $cols = 1;
        $proper = 'none';
        $border = 'none';
        $snippet = 'tooltip';
        $title = false;
        $fullregex = false;
        $case = false;
        $natsort = false;

        foreach ($options as $option) {
            list($key, $value) = explode('=', $option);
            switch ($key) {
                case 'fulltext':
                    $fulltext = true;
                    break;
                case 'sort':
                    $values = explode(',', $value);
                    foreach ($values as $value) {
                        list($key, $dir) = explode(':', $value);
                        $sort[] = array($key, $dir);
                    }
                    break;
                case 'group':
                    $group = true;
                    break;
                case 'limit':
                    $limit = $value;
                    break;
                case 'maxns':
                    $maxns = $value;
                    break;
                case 'inwords':
                    $inwords = true;
                    break;
                case 'proper':
                    switch ($value) {
                        case 'hdr':
                        case 'header':
                        case 'group':
                            $proper = 'header';
                            break;
                        case 'name':
                        case 'page':
                            $proper = 'name';
                            break;
                        default:
                            $proper = 'both';
                    }
                    break;
                case 'cols':
                    $cols = ($value > MAX_COLS) ? MAX_COLS : $value;
                    break;
                case 'border':
                    switch ($value) {
                        case 'none':
                        case 'inside':
                        case 'outside':
                        case 'both':
                            $border = $value;
                            break;
                        default:
                            $border = 'both';
                    }
                    break;
				case 'fullregex':
					$fullregex = true;
					break;
                case 'nostart':
                    $nostart = true;
                    break;
                case 'title':
                    $title = true;
                    break;
                case 'abstract':    // old syntax, to be deprecated (2011-03-15)
                case 'snippet':
                    switch ($value) {
                        case '':
                        case 'tooltip':
                            $snippet = 'tooltip';
                            break;
                        default:
                            if ($value >= 0) {
                                $snippet = $value;
                            }
                    }
                    break;
                case 'case':
                    $case = true;
                    break;
                case 'natsort':
                    $natsort = true;
                    break;
            }
        }
		return array($query, $fulltext, $sort, $group, $limit, $maxns, $proper,
                      $cols, $inwords, $border, $fullregex, $nostart, $title,
                      $snippet, $case, $natsort);
	}

    function render($mode, &$renderer, $data) {
        $sortkeys = array();
        $incl_ns = array();
        $excl_ns = array();

        list($query, $fulltext, $sort, $group, $limit, $maxns, $proper,
              $cols, $inwords, $border, $fullregex, $nostart, $title,
              $snippet, $case, $natsort) = $data;

        if ($mode == 'xhtml') {

            // first get a raw list of matching results

            if ($fulltext) {
                // full text (Dokuwiki style) searching
                $results = array_keys(ft_pageSearch($query, $highlight));
            } else {
                // by page id only (
                if ($fullregex) {
                    // allow for raw regex mode, for power users, this searches the full page id
                    $pageonly = false;
                } else {
                    list($query, $incl_ns, $excl_ns) = $this->_parse_ns_query($query);
                    $pageonly = true;
                }
                if ($query == '*') $query = '.*';   // a lazy man's option!
                $results = $this->_page_lookup($query, $pageonly, $incl_ns, $excl_ns, $nostart, $maxns);
            }

            if ( ! empty($results)) {
                // this section is where the essential pagequery functionality happens...

                // prepare the necessary sorting arrays, as per users options
                list($sort_array, $sort_opts, $group_opts) =
                    $this->_get_options($results, $sort, $title, $proper, $inwords, $case, $natsort);

                // now do the sorting (inc/msort.php)
                msort($sort_array, $sort_opts);

                // limit the result list length if required; this can only be done after sorting!
                $sort_array = ($limit > 0) ? array_slice($sort_array, 0, $limit) : $sort_array;

                // and finally the grouping
                if ($group) {
                    $keys = array(NAME_KEY, ID_KEY);
                    $sorted_results = mgroup($sort_array, $keys, $group_opts);
                } else {
                    foreach ($sort_array as $row) {
                        $sorted_results[] = array(0, $row[NAME_KEY], $row[ID_KEY]);
                    }
                }
                $renderer->doc .= $this->_render_list($sorted_results, $cols, $proper, $snippet, $border);
            } else {
                $renderer->doc .= $this->_render_no_list($query);
            }
            return true;
        } else {
            return false;
        }
    }
    private function _adjusted_height($sorted_results, $ratios) {
        // ratio of different heading heights (%), to ensure more even use of columns (h1 -> h6)
        foreach ($sorted_results as $row) {
            $adjusted_height += $ratios[$row[0]];
        }
        return $adjusted_height;
    }
    /**
     * Render a simple "no results" message
     *
     * @param string $query => original query
     * @return string
     */
    private function _render_no_list($query) {
        $render = '<div id="pagequery" class="noborder">' . DOKU_LF;
        $render .= '<p class="noresults"><span>pagequery</span>' . $this->getLang("no_results") .
                                  '&nbsp; <strong>' . $query . '</strong></p>' . DOKU_LF;
        $render .= '</div>' . DOKU_LF;
        return $render;
    }
    /**
     * Render the final pagequery results list as HTML, indented and in columns as required
     *
     * @param array  $sorted_results
     * @param int    $cols
     * @param bool   $proper
     * @param string $snippet
     * @param string $border
     * @return string => HTML rendered list
     */
    private function _render_list($sorted_results, $cols, $proper, $snippet, $border) {
        $ratios = array(.80, 1.3, 1.17, 1.1, 1.03, .96, .90);   // link, h1, h2, h3, h4, h5, h6
        $render = '';
        $prev_was_heading = false;
        $ready_for_col = true;
        $cont_level = 1;
        $idx = 0;
        $col = 0;
        $col_height = $this->_adjusted_height($sorted_results, $ratios) / $cols;
        $cur_height = 0;
        $width = floor(100 / $cols);
        $snippet_cnt = 0;    // needed by the snippet section for tracking
        $jump_txt= $this->getLang('jump_section');
        $border_style = ($border == 'inside' || $border == 'both') ? '' : $noborder_css;
        $first = true;

        // basic result page markup (always needed)
        $noborder_css = ' class="noborder" ';
        $border_style = ($border == 'outside' || $border == 'both') ? '' : $noborder_css;
        $render .= '<div id="pagequery" ' . $border_style . '>' . DOKU_LF;
        $top_id = 'top-' . mt_rand();   // fixed point to jump back to at top of the table
        $render .= '<table id="' . $top_id . '"><tbody><tr>' . DOKU_LF;

        // now render the pagequery list
        foreach ($sorted_results as $line) {
            list($level, $name, $id) = $line;

            // is it time to start a new column?
            if ($ready_for_col === false && $col < $cols && $cur_height >= $col_height) {
                $ready_for_col = true;
                $col++;
            }

            // how should headings be displayed?
            $is_heading = ($level > 0);
            if ($is_heading) {
                $heading = $name;
                if ($proper == 'header' || $proper == 'both') $heading = $this->_proper($heading);
            }

            // no need for indent if there is no grouping
            if ($group === false) {
                $indent_style = ' class="nogroup"';
            } else {
                $indent = ($is_heading) ? $level - 1 : $cont_level - 1;
                $indent_style = ' style="margin-left:' . $indent * 10 . 'px"';
            }

            // Begin new column if: 1) we are at the start, 2) last item was not a heading or 3) if there is no grouping
            if ($ready_for_col && ! $prev_was_heading) {
                $jump_tip = sprintf($jump_txt, $heading);
                // close the previous column if necessary; also add a 'jump to anchor'
                $cont_close = ( ! $is_heading) ? '<a title="'. $jump_tip . '" href="#' .
                                $top_id . '">' . "<h$cont_level>... </h$cont_level></a>" : '';
                $cont_open = ( ! $first && ! $is_heading) ? "<h$cont_level$indent_style>" . "$heading...</h$cont_level>" : '';
                $close = ( ! $first) ? $cont_close . '</ul></td>' . DOKU_LF : '';
                $render .= $close . '<td' . $border_style . ' valign="top" width="' . $width . '%">' . $cont_open . DOKU_LF;
                $ready_for_col = false;
                $prev_was_heading = true;    // needed correctly style page link lists
                $cur_height = 0;
            }

            // finally display the appropriate heading or page link(s)
            if ($is_heading) {
                // close previous sub list if necessary
                if ( ! $prev_was_heading) {
                    $render .= '</ul>' . DOKU_LF;
                }
                $render .= "<h$level$indent_style>$heading</h$level>" . DOKU_LF;
                $prev_was_heading = true;
                $cont_level = $level + 1;
            } else {
                // open a new sub list if necessary
                if ($prev_was_heading || $first) {
                    $render .= "<ul$indent_style>";
                }
                // deal with normal page links
                $link = $this->_render_wikilink($id, $name, $snippet, $snippet_cnt);
                $snippet_cnt++;
                $render .= $link;
                $prev_was_heading = false;
            }
            $cur_height += $ratios[$level];
            $first = false;
        }
        $render .= '</ul></td></tr>' . DOKU_LF;
        $render .= '</tbody></table>' . DOKU_LF;
        $render .= '<a class="top" href="#' . $top_id . '">' . $this->getLang('link_to_top') . '</a>' . DOKU_LF;
        $render .= '</div>' . DOKU_LF;

        return $render;
    }

    /**
     * Renders the page link, plus tooltip, abstract, casing, etc...
     * @param string $id
     * @param bool  $proper
     * @param bool  $title
     * @param mixed $abstract
     */
    private function _render_wikilink($id, $name, $snippet, $snippet_cnt) {

        $id = (strpos($id, ':') === false) ? ':' . $id : $id;   // : needed for root pages (root level)

        $box = '';
        if ($snippet != 'none') {
            $abstract = $this->_abstract($id);
            // show the "snippet" as a tooltip
            if ($snippet == 'tooltip' || ($snippet > 0 && $snippet_cnt >= $snippet)) {
                $link = $this->_html_wikilink_tooltip($id, $name, $abstract);
            // -or- as a nice quoted snippet ( la blockquote plugin)
            } elseif ($snippet == 'all' || ($snippet >= 0 && $snippet_cnt < $snippet)) {
                list($link, $box) = $this->_html_wikilink_snippet($id, $name, $abstract);
            }
        } else {
            // Plain old wikilink
            $link = html_wikilink($id, $name);
        }
        return '<li>' . $link . '</li>' . DOKU_LF . $box;
    }

    private function _proper($id) {
         $id = str_replace(':', ': ', $id); // make a little whitespace before words so ucwords can work!
         $id = str_replace('_', ' ', $id);
         $id = ucwords($id);
         $id = str_replace(': ', ':', $id);
         return $id;
    }
    /**
     * Swap normal link title (popup) for a more useful preview
     *
     * @param string $id    page id
     * @param string $name  display name
     * @return complete href link
     */
    private function _html_wikilink_tooltip($id, $name, $tooltip) {
        $link = html_wikilink($id, $name);
        $tooltip = str_replace("\n", '  ', $tooltip);
        $link = preg_replace('/title=\".+?\"/', 'title="' . $tooltip . '"', $link, 1);
        return $link;
    }

    private function _html_wikilink_snippet($id, $name, $snippet) {
        $link = html_wikilink($id, $name);
        $detail = str_replace("\n\n", '<br/>', $snippet);
        $more = html_wikilink($id, 'more...');
        $detail = '<blockquote>' . $detail . $more . '</blockquote>' . DOKU_LF;
        return array($link, $detail);
    }

    private function _abstract($id) {
        $abstract = p_get_metadata($id, 'description abstract', true);
        $abstract = htmlspecialchars($abstract, ENT_QUOTES, 'UTF-8');
        return $abstract;
    }

    /**
     * Parse out the namespace, and convert to a regex for array search
     *
     * @param  string $query user page query
     * @return string        processed query with regex markup as needed for namespace recognition
     */
    private function _parse_ns_query($query) {
        $incl_ns = array();
        $excl_ns = array();
        $page_qry = '';
        $tokens = explode(' ', $query);
        if (count($tokens) == 1) {
            $page_qry = $query;
        } else {
            foreach ($tokens as $token) {
                if (preg_match('/^(?:\^|-ns:)(.+)$/u', $token, $matches)) {
                    $excl_ns[] = $matches[1];
                } elseif (preg_match('/^(?:@|ns:)(.+)$/u', $token, $matches)) {
                    $incl_ns[] = $matches[1];
                } else {
                    $page_qry .= ' ' . $token;
                }
            }
        }
        $page_qry = trim($page_qry);
        return array($page_qry, $incl_ns, $excl_ns);
    }

    /**
     * Builds the sorting array: array of arrays (0 = id, 1 = name, 2 =..., 3 = ... , etc)
     *
     * @param array     $ids        array of page ids to be sorted
     * @param array     $sortkeys   list of array keys to sort by
     * @param bool      $title      use page heading instead of name for sorting
     * @param bool      $proper     use proper case where possible
     * @param bool      $inwords    show dates in words where possible
     * @param bool      $case       honour case when sorting
     * @param bool      $natsort    natural sorting, the human way
     *
     * @return array    $sort_array array of array(one value for each key to be sorted)
     *                   $sort_opts  sorting options for the msort function
     *                   $group_opts grouping options for the mgroup function
     */
    private function _get_options($ids, $sortkeys, $title, $proper, $inwords, $case, $natsort) {
        global $conf;

        $sort_opts = array();
        $group_opts = array();

        $dformat = array();
        $wformat = array();

        $row = 0;
        $end_col = START_KEY + count($sortkeys);

        foreach ($ids as $id) {
            $meta = p_get_metadata ($id, false, true);
            if ( ! isset($meta['date']['modified'])) {
                $meta['date']['modified'] = $meta['date']['created'];
            }
            // use page heading instead of page name
            if ($title && isset($meta['title'])) {
                $name = $meta['title'];
            } else {
                $name = noNS($id);
            }
            if ($proper == 'name' || $proper == 'both') {
                $name = $this->_proper($name);
            }
            // first column is the basic page id
            $sort_array[$row][ID_KEY] = $id;
            // second column is the display 'name' (used when sorting by 'name')
            // this also avoids rebuilding the display name when building links later (DRY)
            $sort_array[$row][NAME_KEY] = $name;
            $col = START_KEY;

            foreach ($sortkeys as $sortkey) {
                $key = $sortkey[0];
                switch ($key) {
                    case 'a':
                        $value = $this->_first($name, 1);
                        break;
                    case 'ab':
                        $value = $this->_first($name, 2);
                        break;
                    case 'abc':
                        $value = $this->_first($name, 3);
                        break;
                    case 'name':
                        // a name column already exists by default (col 1)
                        continue;
                    case 'id':
                    case 'page':
                        $value = $id;
                        break;
                    case 'ns':
                        $value = getNS($id);
                        if (empty($value)) $value = '[' . $conf['start'] . ']';
                        break;
                    case 'creator':
                        $value = $meta['creator'];
                        break;
                    case 'mdate':
                        $value = $meta['date']['modified'];
                        break;
                    case 'cdate':
                        $value = $meta['date']['created'];
                        break;
                    default:
                        // date sorting types (groupable)
                        $dtype = $key[0];
                        if ($dtype == 'c' || $dtype == 'm') {
                            // we only set real date once per id (needed for grouping)
                            // not per sort column--the date should remain same across all columns
                            // this is always the last column!
                            if ($col == START_KEY) {
                                if ($dtype == 'c') {
                                    $date = $meta['date']['created'];
                                } else {
                                    $date = $meta['date']['modified'];
                                }
                                $sort_array[$row][$end_col] = $date;
                            } else {
                                $date = $sort_array[$row][$end_col] ;
                            }
                            // only set date formats once per sort column/key (not per id!)
                            if ($row == 0) {
                                $dformat[$col] = $this->_date_format($key);
                                // collect date in word format for potential use in grouping
                                if ($inwords) {
                                    $wformat[$col] = $this->_date_format_words($dformat[$col]);
                                } else {
                                    $wformat[$col] = '';
                                }
                            }
                            // create a string date used for sorting only
                            // (we cannot just use the real date otherwise it would not group correctly)
                            $value = strftime($dformat[$col], $date);
                        }
                }
                $sort_array[$row][$col] = $value;
                $col++;
            }
            $row++;
        }

        $cnt = START_KEY;
        $order = 0;
        foreach ($sortkeys as $sortkey) {
            list($key, $opt) = $sortkey;

            if ($key == 'name') {
                $col = NAME_KEY;
                // this col number will be re-used next time through
            } else {
                $col = $cnt;
                $cnt++;
            }
            $sort_opts['key'][] = $col;

            // now the sort direction
            switch ($opt) {
                case 'a':
                case 'asc':
                    $dir = MSORT_ASC;
                    break;
                case 'd':
                case 'desc':
                    $dir = MSORT_DESC;
                    break;
                default:
                    // sort descending by default; text ascending
                    // watch for other sort options beginning with c or m ....!
                    if ($key[0] == 'c' || $key[0] == 'm') {
                        $dir = MSORT_DESC;
                    } else {
                        $dir = MSORT_ASC;
                    }
            }
            $sort_opts['dir'][] = $dir;

            // set the sort array's data type
            $is_ns = false;
            switch ($key) {
                case 'mdate':
                case 'cdate':
                    $type = MSORT_NUMERIC;
                    break;
                default:
                    if ($case) {
                        // case sensitive: a-z then A-Z
                        $type = ($natsort) ? MSORT_NAT : MSORT_STRING;
                    } else {
                        // case-insensitive
                        $type = ($natsort) ? MSORT_NAT_CASE : MSORT_STRING_CASE;
                    }
            }
            $sort_opts['type'][] = $type;

            // now establish grouping options
            switch ($key) {
                // name strings and full dates cannot be meaningfully grouped (no duplicates!)
                case 'mdate':
                case 'cdate':
                case 'name':
                case 'id':
                case 'page':
                    $group_by = MGROUP_NONE;
                    break;
                case 'ns':
                    $group_by = MGROUP_NAMESPACE;
                    break;
                default:
                    $group_by = MGROUP_HEADING;
            }
            if ($group_by != MGROUP_NONE) {
                $group_opts['key'][$order] = $col;
                $group_opts['type'][$order] = $group_by;
                $group_opts['dformat'][$order] = $wformat[$col];
                $order++;
            }
        }
        return array($sort_array, $sort_opts, $group_opts);
    }

    // returns first $count letters from $text
    private function _first($text, $count) {
        if ($count > 0) {
            return utf8_substr($text, 0, $count);
        }
    }

    /**
     * Parse the c|m-year-month-day option; used for sorting/grouping
     *
     * @param string  $key
     * @return string
     */
    private function _date_format($key) {
        if (strpos($key, 'year') !== false) $dkey[] = '%Y';
        if (strpos($key, 'month') !== false) $dkey[] = '%m';
        if (strpos($key, 'day') !== false) $dkey[] = '%d';
        $dformat = implode('-', $dkey);
        return $dformat;
    }

    /**
     * provide month and day format in real words if required
     * used for display only ($dformat is used for sorting/grouping)
     *
     * @param string $dformat
     * @return string
     */
    private function _date_format_words($dformat) {
        $wformat = '';
        switch ($dformat) {
            case '%m':
                $wformat = "%B";
                break;
            case '%d':
                $wformat = "%#d%A ";
                break;
            case '%Y-%m':
                $wformat = "%B %Y";
                break;
            case '%m-%d':
                $wformat= "%B %#d, %A ";
                break;
            case '%Y-%m-%d':
                $wformat = "%A, %B %#d, %Y";
                break;
        }
        return $wformat;
    }

    /**
     * A heavily customised version of _ft_pageLookup in inc/fulltext.php
     * no sorting!
     */
    private function _page_lookup($query, $pageonly, $incl_ns, $excl_ns, $nostart = true, $maxns = 0) {
        global $conf;

        $queries = trim($query);
        $pages = file($conf['indexdir'] . '/page.idx');

        // first deal with excluded namespaces, then included
        $pages = $this->_filter_ns($pages, $excl_ns, true);

        // now include ONLY the selected namespaces if provided
        $pages = $this->_filter_ns($pages, $incl_ns, false);

        $cnt = count($pages);
        for ($i = 0; $i < $cnt; $i++) {
            $page = $pages[$i];
            if ( ! page_exists($page) || isHiddenPage($page)) {
                unset($pages[$i]);
                continue;
            }
            if ($pageonly) $page = noNS($page);
            /*
             * This is the actual "search" expression!
             * Note: preg_grep cannot be used because the pageonly option above
             *       (need to allow for "^" syntax)
             * The @ prevents problems with invalid queries!
             */
            if (@preg_match('/' . $query . '/i', $page) == 0) {
                unset($pages[$i]);
            }
        }
        if ( ! count($pages)) return array();

        $pages = array_map('trim',$pages);

        // check ACL permissions and remove any 'start' pages if req'd
        $start = $conf['start'];
        $pos = strlen($start);
        foreach($pages as $idx => $name) {
            if ($nostart && substr($name, -$pos) == $start) {
                unset($pages[$idx]);
            } elseif(auth_quickaclcheck(trim($pages[$idx])) < AUTH_READ){
                unset($pages[$idx]);
            } elseif ($maxns > 0 && (substr_count($name,':') + 1) > $maxns) {
                unset($pages[$idx]);    //skip this page
            }
        }
        return $pages;
    }

    private function _filter_ns($pages, $ns_qry, $exclude) {
        $invert = ($exclude) ? PREG_GREP_INVERT : 0;
        foreach ($ns_qry as $ns) {
            $regexes[] = '.*' . $ns . ':.*';
        }
        if ( ! empty($regexes)) {
            $regex = '/(' . implode('|', $regexes) . ')/';
            return array_values(preg_grep($regex, $pages, $invert));
        } else {
            return $pages;
        }
    }
}
?>
blob
mark :78
data 500
base    pagequery
author  Symon Bent
email   hendrybadao@gmail.com
date    2011-04-01
name    PageQuery Plugin
desc    Search for (fulltext) and list wiki pages, sorted and optionally grouped by name, date, creator, abc, etc. in columns. Insert the pagequery markup wherever you want your list to appear.  E.g.{{pagequery>[query;fulltext;sort=key:direction,key2:direction;group;limit=??;cols=?;inwords;proper]}} [..] = optional
url     http://wiki.splitbrain.org/plugin:pagequery
version 0.7.1
blob
mark :79
data 11019
<?php
// keep key associations
define('MSORT_KEEP_ASSOC', 'msort01');

// additional sorting type
define('MSORT_NUMERIC', 'msort02');
define('MSORT_REGULAR', 'msort03');
define('MSORT_STRING', 'msort04');
define('MSORT_STRING_CASE', 'msort05'); // case insensitive
define('MSORT_NAT', 'msort06');         // natural sorting
define('MSORT_NAT_CASE', 'msort07');    // natural sorting, case insensitive

define('MSORT_ASC', 'msort08');
define('MSORT_DESC', 'msort09');

define('MSORT_DEFAULT_DIRECTION', MSORT_ASC);
define('MSORT_DEFAULT_TYPE', MSORT_STRING);

/**
 * A replacement for array_mulitsort which permits natural and caseless sorting
 * This function will sort an 'array of rows' only (not array of 'columns')
 *
 * @param array $sort_array  : multi-dimensional array of arrays, where the first index refers to the row number
 *                             and the second to the column number (e.g. $array[row_number][column_number])
 *                             i.e. = array(
 *                                          array('name1', 'job1', 'start_date1', 'rank1'),
 *                                          array('name2', 'job2', 'start_date2', 'rank2'),
 *                                          ...
 *                                          );
 *
 * @param mixed $sort_opts   : options for how the array should be sorted
 *                   : AS ARGS
 *                             $key, $type, $direction [,$key2, $type2, $direction2, ...etc], $assoc
 *                             $key      = key/column to sort by
 *                             $type     = sorting type, one of following:
 *                                           MSORT_NUMERIC
 *                                           MSORT_REGULAR
 *                                           MSORT_STRING
 *                                           MSORT_STRING_CASE  : caseless sorting
 *                                           MSORT_NAT          : natural sorting
 *                                           MSORT_NAT_CASE
 *                             $direction = sorting direction:
 *                                           MSORT_ASC
 *                                           MSORT_DESC
 *                             $assoc     = keep associative array keys (uasort)
 *                                           MSORT_KEEP_ASSOC
 *                    :AS ARRAY
 *                             $sort_opts['key'][<column>] = 'key'
 *                             $sort_opts['type'][<column>] = 'type'
 *                             $sort_opts['dir'][<column>] = 'dir'
 *                             $sort_opts['assoc'][<column>] = MSORT_KEEP_ASSOC | true
 * @return boolean
 */

function msort(&$sort_array, $sort_opts) {

    // if a full sort_opts array was passed
    if (is_array($sort_opts)) {
        if (isset($sort_opts['assoc'])) {
            $keep_assoc = true;
        }
    // else separate the options from the function args
    } else {
        $args = func_get_args();

        if (end($args) == MSORT_KEEP_ASSOC) {
            $keep_assoc = true;
            array_pop($args);
        }

        // make sure there is something to sort
        if (empty($args)) return true;

        $type_enums = array(
                           MSORT_NUMERIC,
                           MSORT_REGULAR,
                           MSORT_STRING,
                           MSORT_STRING_CASE,
                           MSORT_NAT,
                           MSORT_NAT_CASE
                           );
        $direction_enums = array(
                                MSORT_ASC,
                                MSORT_DESC
                                );

        // work through the args list (SORT_KEY, SORT_TYPE, SORT_DIRECTION)
        $order = -1;
        foreach ($args as $arg) {
            // is it a sort direction?
            if (in_array($arg, $direction_enums)) {
                $sort_opts['dir'][$order] = $arg;
            // is it a sort type?
            } elseif (in_array($arg, $type_enums)) {
                $sort_opts['type'][$order] = $arg;
            // is it a sort array?
            } elseif (is_numeric($arg)) {
                $order++;
                $sort_opts['key'][$order] = $arg;
                $sort_opts['type'][$order] = MSORT_DEFAULT_TYPE;
                $sort_opts['dir'][$order] = MSORT_DEFAULT_DIRECTION;
            }
        }
    }

    // Determine which u..sort function (with or without associations).
    $sort_func = ($keep_assoc) ? 'uasort' : 'usort';

    // Sort the data and get the result.
    $result = $sort_func (
        $sort_array,
        function(array &$left, array &$right) use($sort_opts) {

            // Assume that the entries are the same.
            $cmp = 0;

            // Work through each sort column
            foreach($sort_opts['key'] as $idx => $key) {

                // Handle the different sort types.
                switch ($sort_opts['type'][$idx]) {
                    case MSORT_NUMERIC:
                        $key_cmp = ((intval($left[$key]) == intval($right[$key])) ? 0 :
                                   ((intval($left[$key]) < intval($right[$key])) ? -1 : 1 ) );
                        break;

                    case MSORT_STRING:
                        $key_cmp = strcmp((string)$left[$key], (string)$right[$key]);
                        break;

                    case MSORT_STRING_CASE: //case-insensitive
                        $key_cmp = strcasecmp((string)$left[$key], (string)$right[$key]);
                        break;

                    case MSORT_NAT:
                        $key_cmp = strnatcmp((string)$left[$key], (string)$right[$key]);
                        break;

                    case MSORT_NAT_CASE:    //case-insensitive
                        $key_cmp = strnatcasecmp((string)$left[$key], (string)$right[$key]);
                        break;

                    case MSORT_REGULAR:
                    default :
                        $key_cmp = (($left[$key] == $right[$key]) ? 0 :
                                   (($left[$key] < $right[$key]) ? -1 : 1 ) );
                    break;
                }

                // Is the column in the two arrays the same?
                if ($key_cmp == 0) {
                    continue;
                }

                // Are we sorting descending?
                $cmp = $key_cmp * (($sort_opts['dir'][$idx] == MSORT_DESC) ? -1 : 1);

                // no need for remaining keys as there was a difference
                break;
            }
            return $cmp;
        }
    );
	return $result;
}



// grouping types
define ('MGROUP_NONE', 'mgrp00');
define ('MGROUP_HEADING', 'mgrp01');
define ('MGROUP_NAMESPACE', 'mgrp02');

/**
 * group a multi-dimensional array by each level heading
 * @param array $sort_array : array to be grouped (result of 'msort' function)
 *                             last column should contain real dates if you need dates in words
 * @param array $keys       : which keys (columns) should be returned in results array? (index position)
 * @param mixed $group_opts :  AS ARRAY:
 *                             $group_opts['key'][<order>] = column key to group by
 *                             $group_opts['type'][<order>] = grouping type [MGROUP...]
 *                             $group_opts['dformat'][<order>] = date formatting string
 *
 * @return array $results   : array of arrays: (level, display_name, page_id), e.g. array(1, 'Main Title')
 *                              array(0, '...') =>  0 = normal row item (not heading)
 */
function mgroup(&$sort_array, $keys, $group_opts) {
    $level = count($group_opts['key']) - 1;
    $prevs = array();
    $results = array();
    $idx = 0;

    foreach($sort_array as $row) {
        _add_heading($results, $sort_array, $group_opts, $level, $idx, $prevs);
        $result = array(0); // basic item (page link) is level 0
        for ($i = 0; $i < count($keys); $i++) {
            $result[] = $row[$keys[$i]];
        }
        $results[] = $result;
        $idx++;
    }
    return $results;
}
/**
 * as above, but by args:
*                    AS ARGS:
*                              key, type, dformat [,order, type, dformat]... [,real_dates]
*                              key      = group by key/column
*                              type     = one of the MGROUP types
*                              dformat  = date format (if used)
 *
 * @param array $sort_array
 * @param array $cols
 * @param mixed $group_opts
 */
function mgroup_args($sort_array, $get_cols, $group_opts) {
    $args = func_get_args();

    $type_enums = array(
                        MGROUP_HEADING,
                        MGROUP_NAMESPACE,
                        );

    // get all the grouping options
    // order (which key/column), type (grouping type see MGROUP_...), dformat (real date display format),... repeated
    $group_opts = array();
    $order = -1;
    foreach ($args as $arg) {
        if (is_numeric($arg)) {
            $order++;
            $group_opts['key'][$order] = $arg;
            $group_opts['type'] [$order]= MGROUP_HEADING; // defaults
            $group_opts['dformat'] [$order]= '';
        } elseif ($order > -1) {
            if (in_array($arg, $type_enums)) {
                $group_opts['type'][$order] = $arg;
            } else {
                $group_opts['dformat'][$order] = $arg;
            }
        }
    }
    $level = $order;
}

/**
 * private function used by mgroup only!
 */
function _add_heading(&$results, &$sort_array, &$group_opts, $level, $idx, &$prevs) {
    static $end_col = 0;

    // recurse to find all parent headings
    if ($level > 0) {
        _add_heading($results, $sort_array, $group_opts, $level - 1, $idx, $prevs);
    }
    $group_type = $group_opts['type'][$level];

    $prev = (isset($prevs[$level])) ? $prevs[$level] : '';
    $key = $group_opts['key'][$level];
    $cur = $sort_array[$idx][$key];
    if ($cur != $prev) {
        $prevs[$level] = $cur;

        if ($group_type === MGROUP_HEADING) {
            $date_format = $group_opts['dformat'][$level];
            if ( ! empty($date_format)) {
                // the real date is always the last column (or item in array row)
                // static is used to avoid checking array length repeatedly
                if ($end_col == 0) $end_col = count($sort_array[0]) - 1;
                $cur = strftime($date_format, $sort_array[$idx][$end_col]);
            }
            $results[] = array($level + 1, $cur, '');

        } elseif ($group_type === MGROUP_NAMESPACE) {
            $cur_ns = explode(':', $cur);
            $prev_ns = explode(':', $prev);
            // only show namespaces that are different from the previous heading
            for ($i= 0; $i < count($cur_ns); $i++) {
                if ($cur_ns[$i] != $prev_ns[$i]) {
                    $hl = $level + $i + 1;
                    $results[] = array($hl , $cur_ns[$i], '');
                }
            }
        }
    }
}
?>
blob
mark :81
data 496
base    pagequery
author  Symon Bent
email   hendrybadao@gmail.com
date    2011-04-01
name    PageQuery Plugin
desc    Search for (fulltext) and list wiki pages, sorted and optionally grouped by name, date, creator, abc, etc. in columns. Insert the pagequery markup wherever you want your list to appear.  E.g.{{pagequery>[query;fulltext;sort=key:direction,key2:direction;group;limit=??;cols=?;inwords;proper]}} [..] = optional
url     http://wiki.splitbrain.org/plugin:pagequery
version 0.7.1
blob
mark :83
data 31037
<?php
/**
 * PageQuery Plugin: search for and list pages, sorted/grouped by name, date, creator, etc
 *
 * @license    GPL 2 (http://www.gnu.org/licenses/gpl.html)
 * @author	   Symon Bent <hendrybadao@gmail.com>
 */

// must be run within Dokuwiki
if(!defined('DOKU_INC')) die();

if (!defined('DOKU_LF')) define('DOKU_LF', "\n");
if (!defined('DOKU_TAB')) define('DOKU_TAB', "\t");
if (!defined('DOKU_PLUGIN')) define('DOKU_PLUGIN',DOKU_INC.'lib/plugins/');

require_once(DOKU_PLUGIN . 'syntax.php');
require_once(DOKU_INC . 'inc/fulltext.php');
require_once(DOKU_PLUGIN . 'pagequery/inc/msort.php');

define ('ID_KEY', 0);
define ('NAME_KEY', 1);
define ('START_KEY', 2);
define ('MAX_COLS', 6);

class syntax_plugin_pagequery extends DokuWiki_Syntax_Plugin {

	function getType() {
		return 'substition';
	}

	function getPType() {
		return 'block';
	}

	function getSort() {
		return 98;
	}

	function connectTo($mode) {
		$this->Lexer->addSpecialPattern('\{\{pagequery>.*?\}\}', $mode, 'plugin_pagequery');
	}

    /**
     * Parses all the pagequery options:
     * Insert the pagequery markup wherever you want your list to appear. E.g:
     *
     *   {{pagequery>}}
     *
     *   {{pagequery>[query];fulltext;sort=key:direction,key2:direction;group;limit=??;cols=?;inwords;proper}}
     *
     * Parameters as follows:
     * 1. query:    any expression directly after the >; can use all Dokuwiki search options (see manual)
     * 2. fulltext: use a full-text search, instead of page_id only [default]
     * 3. sort:     keys to sort by, in order of sorting. Each key can be followed by prefered sorting order
     *              available keys:
     *                  a, ab, abc          by 1st letter, 2 letters, or 3 letters
     *                  name                by page name (no namespace) or 1st heading [not grouped]
     *                  page|id             by full page id, including namespace [not grouped]
     *                  ns                  by namespace (without page name)
     *                  mdate, cdate        by modified|created dates (full) [not grouped]
     *                  m[year][month][day] by modified [year][month][day]; any combination accepted
     *                  c[year][month][day] by created [year][month][day]; any combination accepted
     *                  creator             by page author
     *              date sort default to descending, string sorts to ascending
     * 4. group:    show group headers for each change in sort keys
     *              Note: keys with no duplicate cannot be grouped (i.e. name, page|id, mdate, cdate)
     * 5. limit:    maximum number of results to return
     * 6. inwords:  use real month and day names instead of numeric dates
     * 7. cols:     number of columns in displayed list (max = 6)
     * 8. proper:   display page names and namespace in Proper Case (i.e. no _'s and Capitalised)
     *              header/hdr = group headers only, name = page name only, both = both!
     * 9. border:   turn on borders. 'inside' = between columns; 'outside' => border around table;
     *              'both' => in and out; 'none' => neither
     *10. fullregex:only useful on page name searches; allows a raw regex mode on the full page id
     *11. nostart:  ignore any 'start' pages in namespace (based on "config:start")
     *12. maxns:    maximum namespace level to be displayed; e.g. maxns=3 => one:two:three
     *13. title:    show 1st page heading instead of page name
     *14. snippet:  should an excerpt of the wikipage be shown:
     *              use :tooltip to show as a pop-up only
     *              use :<number> to show 1st n items in list with an abstract
     *15. natsort:  use natural sorting order (good for words beginning with numbers)
     *16. case:     respect case when sorting, i.e. a != A when sorting.  a-z then A-Z (opp. to PHP term, easier on novices)
     *
     * All options are optional, and the list will default to a boring long 1-column list...
     */
	function handle($match, $state, $pos, &$handler) {

		$match = substr($match, 12, -2); // strip markup "{{pagequery>"
		$options = explode(';', $match);
        $query = $options[0];

        // establish some basic option defaults
        $sort = array();
        $fulltext = false;
        $group = false;
        $limit = 0;
        $maxns = 0;
        $cols = 1;
        $proper = 'none';
        $border = 'none';
        $snippet = 'tooltip';
        $title = false;
        $fullregex = false;
        $case = false;
        $natsort = false;

        foreach ($options as $option) {
            list($key, $value) = explode('=', $option);
            switch ($key) {
                case 'fulltext':
                    $fulltext = true;
                    break;
                case 'sort':
                    $values = explode(',', $value);
                    foreach ($values as $value) {
                        list($key, $dir) = explode(':', $value);
                        $sort[] = array($key, $dir);
                    }
                    break;
                case 'group':
                    $group = true;
                    break;
                case 'limit':
                    $limit = $value;
                    break;
                case 'maxns':
                    $maxns = $value;
                    break;
                case 'inwords':
                    $inwords = true;
                    break;
                case 'proper':
                    switch ($value) {
                        case 'hdr':
                        case 'header':
                        case 'group':
                            $proper = 'header';
                            break;
                        case 'name':
                        case 'page':
                            $proper = 'name';
                            break;
                        default:
                            $proper = 'both';
                    }
                    break;
                case 'cols':
                    $cols = ($value > MAX_COLS) ? MAX_COLS : $value;
                    break;
                case 'border':
                    switch ($value) {
                        case 'none':
                        case 'inside':
                        case 'outside':
                        case 'both':
                            $border = $value;
                            break;
                        default:
                            $border = 'both';
                    }
                    break;
				case 'fullregex':
					$fullregex = true;
					break;
                case 'nostart':
                    $nostart = true;
                    break;
                case 'title':
                    $title = true;
                    break;
                case 'abstract':    // old syntax, to be deprecated (2011-03-15)
                case 'snippet':
                    switch ($value) {
                        case '':
                        case 'tooltip':
                            $snippet = 'tooltip';
                            break;
                        default:
                            if ($value >= 0) {
                                $snippet = $value;
                            }
                    }
                    break;
                case 'case':
                    $case = true;
                    break;
                case 'natsort':
                    $natsort = true;
                    break;
            }
        }
		return array($query, $fulltext, $sort, $group, $limit, $maxns, $proper,
                      $cols, $inwords, $border, $fullregex, $nostart, $title,
                      $snippet, $case, $natsort);
	}

    function render($mode, &$renderer, $data) {
        $sortkeys = array();
        $incl_ns = array();
        $excl_ns = array();

        list($query, $fulltext, $sort, $group, $limit, $maxns, $proper,
              $cols, $inwords, $border, $fullregex, $nostart, $title,
              $snippet, $case, $natsort) = $data;

        if ($mode == 'xhtml') {

            // first get a raw list of matching results

            if ($fulltext) {
                // full text (Dokuwiki style) searching
                $results = array_keys(ft_pageSearch($query, $highlight));
            } else {
                // by page id only (
                if ($fullregex) {
                    // allow for raw regex mode, for power users, this searches the full page id
                    $pageonly = false;
                } else {
                    list($query, $incl_ns, $excl_ns) = $this->_parse_ns_query($query);
                    $pageonly = true;
                }
                if ($query == '*') $query = '.*';   // a lazy man's option!
                $results = $this->_page_lookup($query, $pageonly, $incl_ns, $excl_ns, $nostart, $maxns);
            }

            if ( ! empty($results)) {
                // this section is where the essential pagequery functionality happens...

                // prepare the necessary sorting arrays, as per users options
                list($sort_array, $sort_opts, $group_opts) =
                    $this->_get_options($results, $sort, $title, $proper, $inwords, $case, $natsort);

                // now do the sorting (inc/msort.php)
                msort($sort_array, $sort_opts);

                // limit the result list length if required; this can only be done after sorting!
                $sort_array = ($limit > 0) ? array_slice($sort_array, 0, $limit) : $sort_array;

                // and finally the grouping
                if ($group) {
                    $keys = array(NAME_KEY, ID_KEY);
                    $sorted_results = mgroup($sort_array, $keys, $group_opts);
                } else {
                    foreach ($sort_array as $row) {
                        $sorted_results[] = array(0, $row[NAME_KEY], $row[ID_KEY]);
                    }
                }
                $renderer->doc .= $this->_render_list($sorted_results, $cols, $proper, $snippet, $border);
            } else {
                $renderer->doc .= $this->_render_no_list($query);
            }
            return true;
        } else {
            return false;
        }
    }
    private function _adjusted_height($sorted_results, $ratios) {
        // ratio of different heading heights (%), to ensure more even use of columns (h1 -> h6)
        foreach ($sorted_results as $row) {
            $adjusted_height += $ratios[$row[0]];
        }
        return $adjusted_height;
    }
    /**
     * Render a simple "no results" message
     *
     * @param string $query => original query
     * @return string
     */
    private function _render_no_list($query) {
        $render = '<div id="pagequery" class="noborder">' . DOKU_LF;
        $render .= '<p class="noresults"><span>pagequery</span>' . $this->getLang("no_results") .
                                  '&nbsp; <strong>' . $query . '</strong></p>' . DOKU_LF;
        $render .= '</div>' . DOKU_LF;
        return $render;
    }
    /**
     * Render the final pagequery results list as HTML, indented and in columns as required
     *
     * @param array  $sorted_results
     * @param int    $cols
     * @param bool   $proper
     * @param string $snippet
     * @param string $border
     * @return string => HTML rendered list
     */
    private function _render_list($sorted_results, $cols, $proper, $snippet, $border) {
        $ratios = array(.80, 1.3, 1.17, 1.1, 1.03, .96, .90);   // link, h1, h2, h3, h4, h5, h6
        $render = '';
        $prev_was_heading = false;
        $can_start_col = true;
        $cont_level = 1;
        $idx = 0;
        $col = 0;
        $col_height = $this->_adjusted_height($sorted_results, $ratios) / $cols;
        $cur_height = 0;
        $width = floor(100 / $cols);
        $snippet_cnt = 0;    // needed by the snippet section for tracking
        $jump_txt= $this->getLang('jump_section');
        $border_style = ($border == 'inside' || $border == 'both') ? '' : $noborder_css;
        $is_first = true;

        // basic result page markup (always needed)
        $noborder_css = ' class="noborder" ';
        $border_style = ($border == 'outside' || $border == 'both') ? '' : $noborder_css;
        $render .= '<div id="pagequery" ' . $border_style . '>' . DOKU_LF;
        $top_id = 'top-' . mt_rand();   // fixed point to jump back to at top of the table
        $render .= '<table id="' . $top_id . '"><tbody><tr>' . DOKU_LF;

        // now render the pagequery list
        foreach ($sorted_results as $line) {
            list($level, $name, $id) = $line;
            $is_heading = ($level > 0);

            // is it time to start a new column?
            if ($can_start_col === false && $col < $cols && $cur_height >= $col_height) {
                $can_start_col = true;
                $col++;
            }

            // how should headings be displayed?
            if ($is_heading) {
                $heading = $name;
                if ($proper == 'header' || $proper == 'both') $heading = $this->_proper($heading);
            }

            // no need for indent if there is no grouping
            if ($group === false) {
                $indent_style = ' class="nogroup"';
            } else {
                $indent = ($is_heading) ? $level - 1 : $cont_level - 1;
                $indent_style = ' style="margin-left:' . $indent * 10 . 'px"';
            }

            // Begin new column if: 1) we are at the start, 2) last item was not a heading or 3) if there is no grouping
            if ($can_start_col && ! $prev_was_heading) {
                $jump_tip = sprintf($jump_txt, $heading);
                // close the previous column if necessary; also adds a 'jump to anchor'
                $col_close = ( ! $is_heading) ? '<a title="'. $jump_tip . '" href="#' .
                                $top_id . '">' . "<h$cont_level>... </h$cont_level></a>" : '';
                $col_close = ( ! $is_first) ? $col_close . '</ul></td>' . DOKU_LF : '';
                $col_open = ( ! $is_first && ! $is_heading) ? "<h$cont_level$indent_style>" . "$heading...</h$cont_level>" : '';
                $render .= $col_close . '<td' . $border_style . ' valign="top" width="' . $width . '%">' . $col_open . DOKU_LF;
                $can_start_col = false;
                $prev_was_heading = true;    // needed correctly style page link lists <ul>...
                $cur_height = 0;
            }

            // finally display the appropriate heading or page link(s)
            if ($is_heading) {
                // close previous sub list if necessary
                if ( ! $prev_was_heading) {
                    $render .= '</ul>' . DOKU_LF;
                }
                $render .= "<h$level$indent_style>$heading</h$level>" . DOKU_LF;
                $prev_was_heading = true;
                $cont_level = $level + 1;
            } else {
                // open a new sub list if necessary
                if ($prev_was_heading || $is_first) {
                    $render .= "<ul$indent_style>";
                }
                // deal with normal page links
                $link = $this->_render_wikilink($id, $name, $snippet, $snippet_cnt);
                $snippet_cnt++;
                $render .= $link;
                $prev_was_heading = false;
            }
            $cur_height += $ratios[$level];
            $is_first = false;
        }
        $render .= '</ul></td></tr>' . DOKU_LF;
        $render .= '</tbody></table>' . DOKU_LF;
        $render .= '<a class="top" href="#' . $top_id . '">' . $this->getLang('link_to_top') . '</a>' . DOKU_LF;
        $render .= '</div>' . DOKU_LF;

        return $render;
    }

    /**
     * Renders the page link, plus tooltip, abstract, casing, etc...
     * @param string $id
     * @param bool  $proper
     * @param bool  $title
     * @param mixed $abstract
     */
    private function _render_wikilink($id, $name, $snippet, $snippet_cnt) {

        $id = (strpos($id, ':') === false) ? ':' . $id : $id;   // : needed for root pages (root level)

        $box = '';
        if ($snippet != 'none') {
            $abstract = $this->_abstract($id);
            // show the "snippet" as a tooltip
            if ($snippet == 'tooltip' || ($snippet > 0 && $snippet_cnt >= $snippet)) {
                $link = $this->_html_wikilink_tooltip($id, $name, $abstract);
            // -or- as a nice quoted snippet ( la blockquote plugin)
            } elseif ($snippet == 'all' || ($snippet >= 0 && $snippet_cnt < $snippet)) {
                list($link, $box) = $this->_html_wikilink_snippet($id, $name, $abstract);
            }
        } else {
            // Plain old wikilink
            $link = html_wikilink($id, $name);
        }
        return '<li>' . $link . '</li>' . DOKU_LF . $box;
    }

    private function _proper($id) {
         $id = str_replace(':', ': ', $id); // make a little whitespace before words so ucwords can work!
         $id = str_replace('_', ' ', $id);
         $id = ucwords($id);
         $id = str_replace(': ', ':', $id);
         return $id;
    }
    /**
     * Swap normal link title (popup) for a more useful preview
     *
     * @param string $id    page id
     * @param string $name  display name
     * @return complete href link
     */
    private function _html_wikilink_tooltip($id, $name, $tooltip) {
        $link = html_wikilink($id, $name);
        $tooltip = str_replace("\n", '  ', $tooltip);
        $link = preg_replace('/title=\".+?\"/', 'title="' . $tooltip . '"', $link, 1);
        return $link;
    }

    private function _html_wikilink_snippet($id, $name, $snippet) {
        $link = html_wikilink($id, $name);
        $detail = str_replace("\n\n", '<br/>', $snippet);
        $more = html_wikilink($id, 'more...');
        $detail = '<blockquote>' . $detail . $more . '</blockquote>' . DOKU_LF;
        return array($link, $detail);
    }

    private function _abstract($id) {
        $abstract = p_get_metadata($id, 'description abstract', true);
        $abstract = htmlspecialchars($abstract, ENT_QUOTES, 'UTF-8');
        return $abstract;
    }

    /**
     * Parse out the namespace, and convert to a regex for array search
     *
     * @param  string $query user page query
     * @return string        processed query with regex markup as needed for namespace recognition
     */
    private function _parse_ns_query($query) {
        $incl_ns = array();
        $excl_ns = array();
        $page_qry = '';
        $tokens = explode(' ', $query);
        if (count($tokens) == 1) {
            $page_qry = $query;
        } else {
            foreach ($tokens as $token) {
                if (preg_match('/^(?:\^|-ns:)(.+)$/u', $token, $matches)) {
                    $excl_ns[] = $matches[1];
                } elseif (preg_match('/^(?:@|ns:)(.+)$/u', $token, $matches)) {
                    $incl_ns[] = $matches[1];
                } else {
                    $page_qry .= ' ' . $token;
                }
            }
        }
        $page_qry = trim($page_qry);
        return array($page_qry, $incl_ns, $excl_ns);
    }

    /**
     * Builds the sorting array: array of arrays (0 = id, 1 = name, 2 =..., 3 = ... , etc)
     *
     * @param array     $ids        array of page ids to be sorted
     * @param array     $sortkeys   list of array keys to sort by
     * @param bool      $title      use page heading instead of name for sorting
     * @param bool      $proper     use proper case where possible
     * @param bool      $inwords    show dates in words where possible
     * @param bool      $case       honour case when sorting
     * @param bool      $natsort    natural sorting, the human way
     *
     * @return array    $sort_array array of array(one value for each key to be sorted)
     *                   $sort_opts  sorting options for the msort function
     *                   $group_opts grouping options for the mgroup function
     */
    private function _get_options($ids, $sortkeys, $title, $proper, $inwords, $case, $natsort) {
        global $conf;

        $sort_opts = array();
        $group_opts = array();

        $dformat = array();
        $wformat = array();

        $row = 0;
        $end_col = START_KEY + count($sortkeys);

        foreach ($ids as $id) {
            $meta = p_get_metadata ($id, false, true);
            if ( ! isset($meta['date']['modified'])) {
                $meta['date']['modified'] = $meta['date']['created'];
            }
            // use page heading instead of page name
            if ($title && isset($meta['title'])) {
                $name = $meta['title'];
            } else {
                $name = noNS($id);
            }
            if ($proper == 'name' || $proper == 'both') {
                $name = $this->_proper($name);
            }
            // first column is the basic page id
            $sort_array[$row][ID_KEY] = $id;
            // second column is the display 'name' (used when sorting by 'name')
            // this also avoids rebuilding the display name when building links later (DRY)
            $sort_array[$row][NAME_KEY] = $name;
            $col = START_KEY;

            foreach ($sortkeys as $sortkey) {
                $key = $sortkey[0];
                switch ($key) {
                    case 'a':
                        $value = $this->_first($name, 1);
                        break;
                    case 'ab':
                        $value = $this->_first($name, 2);
                        break;
                    case 'abc':
                        $value = $this->_first($name, 3);
                        break;
                    case 'name':
                        // a name column already exists by default (col 1)
                        continue;
                    case 'id':
                    case 'page':
                        $value = $id;
                        break;
                    case 'ns':
                        $value = getNS($id);
                        if (empty($value)) $value = '[' . $conf['start'] . ']';
                        break;
                    case 'creator':
                        $value = $meta['creator'];
                        break;
                    case 'mdate':
                        $value = $meta['date']['modified'];
                        break;
                    case 'cdate':
                        $value = $meta['date']['created'];
                        break;
                    default:
                        // date sorting types (groupable)
                        $dtype = $key[0];
                        if ($dtype == 'c' || $dtype == 'm') {
                            // we only set real date once per id (needed for grouping)
                            // not per sort column--the date should remain same across all columns
                            // this is always the last column!
                            if ($col == START_KEY) {
                                if ($dtype == 'c') {
                                    $date = $meta['date']['created'];
                                } else {
                                    $date = $meta['date']['modified'];
                                }
                                $sort_array[$row][$end_col] = $date;
                            } else {
                                $date = $sort_array[$row][$end_col] ;
                            }
                            // only set date formats once per sort column/key (not per id!)
                            if ($row == 0) {
                                $dformat[$col] = $this->_date_format($key);
                                // collect date in word format for potential use in grouping
                                if ($inwords) {
                                    $wformat[$col] = $this->_date_format_words($dformat[$col]);
                                } else {
                                    $wformat[$col] = '';
                                }
                            }
                            // create a string date used for sorting only
                            // (we cannot just use the real date otherwise it would not group correctly)
                            $value = strftime($dformat[$col], $date);
                        }
                }
                $sort_array[$row][$col] = $value;
                $col++;
            }
            $row++;
        }

        $cnt = START_KEY;
        $order = 0;
        foreach ($sortkeys as $sortkey) {
            list($key, $opt) = $sortkey;

            if ($key == 'name') {
                $col = NAME_KEY;
                // this col number will be re-used next time through
            } else {
                $col = $cnt;
                $cnt++;
            }
            $sort_opts['key'][] = $col;

            // now the sort direction
            switch ($opt) {
                case 'a':
                case 'asc':
                    $dir = MSORT_ASC;
                    break;
                case 'd':
                case 'desc':
                    $dir = MSORT_DESC;
                    break;
                default:
                    // sort descending by default; text ascending
                    // watch for other sort options beginning with c or m ....!
                    if ($key[0] == 'c' || $key[0] == 'm') {
                        $dir = MSORT_DESC;
                    } else {
                        $dir = MSORT_ASC;
                    }
            }
            $sort_opts['dir'][] = $dir;

            // set the sort array's data type
            $is_ns = false;
            switch ($key) {
                case 'mdate':
                case 'cdate':
                    $type = MSORT_NUMERIC;
                    break;
                default:
                    if ($case) {
                        // case sensitive: a-z then A-Z
                        $type = ($natsort) ? MSORT_NAT : MSORT_STRING;
                    } else {
                        // case-insensitive
                        $type = ($natsort) ? MSORT_NAT_CASE : MSORT_STRING_CASE;
                    }
            }
            $sort_opts['type'][] = $type;

            // now establish grouping options
            switch ($key) {
                // name strings and full dates cannot be meaningfully grouped (no duplicates!)
                case 'mdate':
                case 'cdate':
                case 'name':
                case 'id':
                case 'page':
                    $group_by = MGROUP_NONE;
                    break;
                case 'ns':
                    $group_by = MGROUP_NAMESPACE;
                    break;
                default:
                    $group_by = MGROUP_HEADING;
            }
            if ($group_by != MGROUP_NONE) {
                $group_opts['key'][$order] = $col;
                $group_opts['type'][$order] = $group_by;
                $group_opts['dformat'][$order] = $wformat[$col];
                $order++;
            }
        }
        return array($sort_array, $sort_opts, $group_opts);
    }

    // returns first $count letters from $text
    private function _first($text, $count) {
        if ($count > 0) {
            return utf8_substr($text, 0, $count);
        }
    }

    /**
     * Parse the c|m-year-month-day option; used for sorting/grouping
     *
     * @param string  $key
     * @return string
     */
    private function _date_format($key) {
        if (strpos($key, 'year') !== false) $dkey[] = '%Y';
        if (strpos($key, 'month') !== false) $dkey[] = '%m';
        if (strpos($key, 'day') !== false) $dkey[] = '%d';
        $dformat = implode('-', $dkey);
        return $dformat;
    }

    /**
     * provide month and day format in real words if required
     * used for display only ($dformat is used for sorting/grouping)
     *
     * @param string $dformat
     * @return string
     */
    private function _date_format_words($dformat) {
        $wformat = '';
        switch ($dformat) {
            case '%m':
                $wformat = "%B";
                break;
            case '%d':
                $wformat = "%#d%A ";
                break;
            case '%Y-%m':
                $wformat = "%B %Y";
                break;
            case '%m-%d':
                $wformat= "%B %#d, %A ";
                break;
            case '%Y-%m-%d':
                $wformat = "%A, %B %#d, %Y";
                break;
        }
        return $wformat;
    }

    /**
     * A heavily customised version of _ft_pageLookup in inc/fulltext.php
     * no sorting!
     */
    private function _page_lookup($query, $pageonly, $incl_ns, $excl_ns, $nostart = true, $maxns = 0) {
        global $conf;

        $queries = trim($query);
        $pages = file($conf['indexdir'] . '/page.idx');

        // first deal with excluded namespaces, then included
        $pages = $this->_filter_ns($pages, $excl_ns, true);

        // now include ONLY the selected namespaces if provided
        $pages = $this->_filter_ns($pages, $incl_ns, false);

        $cnt = count($pages);
        for ($i = 0; $i < $cnt; $i++) {
            $page = $pages[$i];
            if ( ! page_exists($page) || isHiddenPage($page)) {
                unset($pages[$i]);
                continue;
            }
            if ($pageonly) $page = noNS($page);
            /*
             * This is the actual "search" expression!
             * Note: preg_grep cannot be used because the pageonly option above
             *       (need to allow for "^" syntax)
             * The @ prevents problems with invalid queries!
             */
            if (@preg_match('/' . $query . '/i', $page) == 0) {
                unset($pages[$i]);
            }
        }
        if ( ! count($pages)) return array();

        $pages = array_map('trim',$pages);

        // check ACL permissions and remove any 'start' pages if req'd
        $start = $conf['start'];
        $pos = strlen($start);
        foreach($pages as $idx => $name) {
            if ($nostart && substr($name, -$pos) == $start) {
                unset($pages[$idx]);
            } elseif(auth_quickaclcheck(trim($pages[$idx])) < AUTH_READ){
                unset($pages[$idx]);
            } elseif ($maxns > 0 && (substr_count($name,':') + 1) > $maxns) {
                unset($pages[$idx]);    //skip this page
            }
        }
        return $pages;
    }

    private function _filter_ns($pages, $ns_qry, $exclude) {
        $invert = ($exclude) ? PREG_GREP_INVERT : 0;
        foreach ($ns_qry as $ns) {
            $regexes[] = '.*' . $ns . ':.*';
        }
        if ( ! empty($regexes)) {
            $regex = '/(' . implode('|', $regexes) . ')/';
            return array_values(preg_grep($regex, $pages, $invert));
        } else {
            return $pages;
        }
    }
}
?>
blob
mark :85
data 3057
div.dokuwiki div#pagequery {
    position:relative;
    margin:0 0 1em 0;
    padding:4px;
    border-width:1px;
    -moz-border-radius:8px;
    -webkit-border-radius:8px;
}
div.dokuwiki div#pagequery table {
    border-collapse:collapse;
    width:100%;
    margin:0;
}
div.dokuwiki div#pagequery,
div.dokuwiki div#pagequery td {
	border-style:solid;
	border-color:#D7D5D4;
}
div.dokuwiki div#pagequery td {
	padding:8px 10px 20px;
	background-color:white;
    border-width:0 1px 0 0;
}
div.dokuwiki div#pagequery.noborder,
div.dokuwiki div#pagequery td.noborder,
div.dokuwiki div#pagequery td:nth-last-child(1),
div.dokuwiki div#pagequery li.noborder {
    border-width:0;
}

div.dokuwiki div#pagequery h1,
div.dokuwiki div#pagequery h2,
div.dokuwiki div#pagequery h3,
div.dokuwiki div#pagequery h4,
div.dokuwiki div#pagequery h5,
div.dokuwiki div#pagequery h6 {
    padding:0.06em 0 0.03em 0;
    margin:0;
    margin-bottom:2px;
    color:#A0A0A0;
}
div.dokuwiki div#pagequery h3,
div.dokuwiki div#pagequery h4,
div.dokuwiki div#pagequery h5,
div.dokuwiki div#pagequery h6 {
    font-weight:normal;
}
div.dokuwiki div#pagequery h1 {
    font-size:134%;
    padding:0px 0px 3px 7px;
    background:#EDEDED;
    -moz-border-radius:6px;
    -webkit-border-radius:6px;
}
div.dokuwiki div#pagequery h2 {font-size:125%; font-weight:bold;}
div.dokuwiki div#pagequery h3 {font-size:114%;}
div.dokuwiki div#pagequery h4 {font-size:108%;}
div.dokuwiki div#pagequery h5 {font-size:100%;}
div.dokuwiki div#pagequery h6 {font-size:95%;}


div.dokuwiki div#pagequery ul {
    list-style:none;
    margin:0 0 8px 0;
	text-align:left;
}
div.dokuwiki div#pagequery ul.nogroup {
    margin:0 0 5px 3px;
}
div.dokuwiki div#pagequery li {
	padding-left:10px;
	text-indent:-10px;
    line-height:135%;
    border-top:1px dotted #D7D5D4;
}
div.dokuwiki div#pagequery li span {
    font-size:80%;
    font-style:italic !important;
    margin:0 0.5em;
}
div.dokuwiki div#pagequery li:nth-child(1) {
    border:0;
}
div.dokuwiki div#pagequery a:hover,
div.dokuwiki div#pagequery blockquote a:hover {
    text-decoration:none;
    color:#202020!important;
}
div.dokuwiki div#pagequery a.top {
    position:absolute;
    bottom:0.4em;;
    right:0.5em;
    font-style:italic;
    color:#A0A0A0;
}
/* credit: blockquote:plugin */
div.dokuwiki div#pagequery blockquote {
    font-size:80%;
	margin:5px 15px 10px 15px !important;
	border:1px dotted __border__ !important;
	background:#FAFACE url(images/blockquote.gif) no-repeat 5px 5px !important;
	padding:10px 15px 15px 18px !important;
    -moz-border-radius:6px;
    -webkit-border-radius:6px;
}
div.dokuwiki div#pagequery blockquote a {
    margin-left:12px;
}
div.dokuwiki div#pagequery p.noresults {
    color:#899BB2 !important;
    font-size:1.2em;
    margin-left:1.2em;
}
div.dokuwiki div#pagequery p.noresults span {
    font-size:0.8em;
    line-height:1.2em;
    font-style:italic;
    padding:3px 6px;
    margin-right:0.3em;
    background-color:#EDEDED;
    -moz-border-radius:3px;
    -webkit-border-radius:3px;
}

blob
mark :86
data 31863
<?php
/**
 * PageQuery Plugin: search for and list pages, sorted/grouped by name, date, creator, etc
 *
 * @license    GPL 2 (http://www.gnu.org/licenses/gpl.html)
 * @author	   Symon Bent <hendrybadao@gmail.com>
 */

// must be run within Dokuwiki
if(!defined('DOKU_INC')) die();

if (!defined('DOKU_LF')) define('DOKU_LF', "\n");
if (!defined('DOKU_TAB')) define('DOKU_TAB', "\t");
if (!defined('DOKU_PLUGIN')) define('DOKU_PLUGIN',DOKU_INC.'lib/plugins/');

require_once(DOKU_PLUGIN . 'syntax.php');
require_once(DOKU_INC . 'inc/fulltext.php');
require_once(DOKU_PLUGIN . 'pagequery/inc/msort.php');

define ('ID_KEY', 0);
define ('NAME_KEY', 1);
define ('START_KEY', 2);
define ('MAX_COLS', 6);

class syntax_plugin_pagequery extends DokuWiki_Syntax_Plugin {

	function getType() {
		return 'substition';
	}

	function getPType() {
		return 'block';
	}

	function getSort() {
		return 98;
	}

	function connectTo($mode) {
		$this->Lexer->addSpecialPattern('\{\{pagequery>.*?\}\}', $mode, 'plugin_pagequery');
	}

    /**
     * Parses all the pagequery options:
     * Insert the pagequery markup wherever you want your list to appear. E.g:
     *
     *   {{pagequery>}}
     *
     *   {{pagequery>[query];fulltext;sort=key:direction,key2:direction;group;limit=??;cols=?;inwords;proper}}
     *
     * Parameters as follows:
     * 1. query:    any expression directly after the >; can use all Dokuwiki search options (see manual)
     * 2. fulltext: use a full-text search, instead of page_id only [default]
     * 3. sort:     keys to sort by, in order of sorting. Each key can be followed by prefered sorting order
     *              available keys:
     *                  a, ab, abc          by 1st letter, 2 letters, or 3 letters
     *                  name                by page name (no namespace) or 1st heading [not grouped]
     *                  page|id             by full page id, including namespace [not grouped]
     *                  ns                  by namespace (without page name)
     *                  mdate, cdate        by modified|created dates (full) [not grouped]
     *                  m[year][month][day] by modified [year][month][day]; any combination accepted
     *                  c[year][month][day] by created [year][month][day]; any combination accepted
     *                  creator             by page author
     *              date sort default to descending, string sorts to ascending
     * 4. group:    show group headers for each change in sort keys
     *              Note: keys with no duplicate cannot be grouped (i.e. name, page|id, mdate, cdate)
     * 5. limit:    maximum number of results to return
     * 6. inwords:  use real month and day names instead of numeric dates
     * 7. cols:     number of columns in displayed list (max = 6)
     * 8. proper:   display page names and namespace in Proper Case (i.e. no _'s and Capitalised)
     *              header/hdr = group headers only, name = page name only, both = both!
     * 9. border:   turn on borders. 'inside' = between columns; 'outside' => border around table;
     *              'both' => in and out; 'none' => neither
     *10. fullregex:only useful on page name searches; allows a raw regex mode on the full page id
     *11. nostart:  ignore any 'start' pages in namespace (based on "config:start")
     *12. maxns:    maximum namespace level to be displayed; e.g. maxns=3 => one:two:three
     *13. title:    show 1st page heading instead of page name
     *14. snippet:  should an excerpt of the wikipage be shown:
     *              use :tooltip to show as a pop-up only
     *              use :<number> to show 1st n items in list with an abstract
     *15. natsort:  use natural sorting order (good for words beginning with numbers)
     *16. case:     respect case when sorting, i.e. a != A when sorting.  a-z then A-Z (opp. to PHP term, easier on novices)
     *
     * All options are optional, and the list will default to a boring long 1-column list...
     */
	function handle($match, $state, $pos, &$handler) {

		$match = substr($match, 12, -2); // strip markup "{{pagequery>"
		$options = explode(';', $match);
        $query = $options[0];

        // establish some basic option defaults
        $sort = array();
        $fulltext = false;
        $group = false;
        $limit = 0;
        $maxns = 0;
        $cols = 1;
        $proper = 'none';
        $border = 'none';
        $snippet = 'tooltip';
        $title = false;
        $fullregex = false;
        $case = false;
        $natsort = false;
        $underline = false;

        foreach ($options as $option) {
            list($key, $value) = explode('=', $option);
            switch ($key) {
                case 'fulltext':
                    $fulltext = true;
                    break;
                case 'sort':
                    $values = explode(',', $value);
                    foreach ($values as $value) {
                        list($key, $dir) = explode(':', $value);
                        $sort[] = array($key, $dir);
                    }
                    break;
                case 'group':
                    $group = true;
                    break;
                case 'limit':
                    $limit = $value;
                    break;
                case 'maxns':
                    $maxns = $value;
                    break;
                case 'inwords':
                    $inwords = true;
                    break;
                case 'proper':
                    switch ($value) {
                        case 'hdr':
                        case 'header':
                        case 'group':
                            $proper = 'header';
                            break;
                        case 'name':
                        case 'page':
                            $proper = 'name';
                            break;
                        default:
                            $proper = 'both';
                    }
                    break;
                case 'cols':
                    $cols = ($value > MAX_COLS) ? MAX_COLS : $value;
                    break;
                case 'border':
                    switch ($value) {
                        case 'none':
                        case 'inside':
                        case 'outside':
                        case 'both':
                            $border = $value;
                            break;
                        default:
                            $border = 'both';
                    }
                    break;
				case 'fullregex':
					$fullregex = true;
					break;
                case 'nostart':
                    $nostart = true;
                    break;
                case 'title':
                    $title = true;
                    break;
                case 'abstract':    // old syntax, to be deprecated (2011-03-15)
                case 'snippet':
                    switch ($value) {
                        case '':
                        case 'tooltip':
                            $snippet = 'tooltip';
                            break;
                        default:
                            if ($value >= 0) {
                                $snippet = $value;
                            } elseif (substr($value, 0, 6) == 'inline') {
                                $snippet = $value;
                            }
                    }
                    break;
                case 'case':
                    $case = true;
                    break;
                case 'natsort':
                    $natsort = true;
                    break;
                case 'underline':
                    $underline = true;
                    break;
            }
        }
		return array($query, $fulltext, $sort, $group, $limit, $maxns, $proper,
                      $cols, $inwords, $border, $fullregex, $nostart, $title,
                      $snippet, $case, $natsort, $underline);
	}

    function render($mode, &$renderer, $data) {
        $sortkeys = array();
        $incl_ns = array();
        $excl_ns = array();

        list($query, $fulltext, $sort, $group, $limit, $maxns, $proper,
              $cols, $inwords, $border, $fullregex, $nostart, $title,
              $snippet, $case, $natsort, $underline) = $data;

        if ($mode == 'xhtml') {
            // first get a raw list of matching results

            if ($fulltext) {
                // full text (Dokuwiki style) searching
                $results = array_keys(ft_pageSearch($query, $highlight));
            } else {
                // by page id only (
                if ($fullregex) {
                    // allow for raw regex mode, for power users, this searches the full page id
                    $pageonly = false;
                } else {
                    list($query, $incl_ns, $excl_ns) = $this->_parse_ns_query($query);
                    $pageonly = true;
                }
                if ($query == '*') $query = '.*';   // a lazy man's option!
                $results = $this->_page_lookup($query, $pageonly, $incl_ns, $excl_ns, $nostart, $maxns);
            }

            if ( ! empty($results)) {
                // this section is where the essential pagequery functionality happens...

                // prepare the necessary sorting arrays, as per users options
                list($sort_array, $sort_opts, $group_opts) =
                    $this->_get_options($results, $sort, $title, $proper, $inwords, $case, $natsort);

                // now do the sorting (inc/msort.php)
                msort($sort_array, $sort_opts);

                // limit the result list length if required; this can only be done after sorting!
                $sort_array = ($limit > 0) ? array_slice($sort_array, 0, $limit) : $sort_array;

                // and finally the grouping
                if ($group) {
                    $keys = array(NAME_KEY, ID_KEY);
                    $sorted_results = mgroup($sort_array, $keys, $group_opts);
                } else {
                    foreach ($sort_array as $row) {
                        $sorted_results[] = array(0, $row[NAME_KEY], $row[ID_KEY]);
                    }
                }
                $renderer->doc .= $this->_render_list($sorted_results, $cols, $proper, $snippet, $border, $underline);
            } else {
                $renderer->doc .= $this->_render_no_list($query);
            }
            return true;
        } else {
            return false;
        }
    }

    private function _adjusted_height($sorted_results, $ratios) {
        // ratio of different heading heights (%), to ensure more even use of columns (h1 -> h6)
        foreach ($sorted_results as $row) {
            $adjusted_height += $ratios[$row[0]];
        }
        return $adjusted_height;
    }

    /**
     * Render a simple "no results" message
     *
     * @param string $query => original query
     * @return string
     */
    private function _render_no_list($query) {
        $render = '<div id="pagequery" class="noborder">' . DOKU_LF;
        $render .= '<p class="noresults"><span>pagequery</span>' . $this->getLang("no_results") .
                                  '&nbsp; <strong>' . $query . '</strong></p>' . DOKU_LF;
        $render .= '</div>' . DOKU_LF;
        return $render;
    }
    /**
     * Render the final pagequery results list as HTML, indented and in columns as required
     *
     * @param array  $sorted_results
     * @param int    $cols
     * @param bool   $proper
     * @param string $snippet
     * @param string $border
     * @return string => HTML rendered list
     */
    private function _render_list($sorted_results, $cols, $proper, $snippet, $border, $underline) {
        $ratios = array(.80, 1.3, 1.17, 1.1, 1.03, .96, .90);   // link, h1, h2, h3, h4, h5, h6
        $render = '';
        $prev_was_heading = false;
        $can_start_col = true;
        $cont_level = 1;
        $idx = 0;
        $col = 0;
        $col_height = $this->_adjusted_height($sorted_results, $ratios) / $cols;
        $cur_height = 0;
        $width = floor(100 / $cols);
        $snippet_cnt = 0;    // needed by the snippet section for tracking
        $jump_txt= $this->getLang('jump_section');
        $border_style = ($border == 'inside' || $border == 'both') ? '' : $noborder_css;
        $is_first = true;

        // basic result page markup (always needed)
        $noborder_css = ' class="noborder" ';
        $border_style = ($border == 'outside' || $border == 'both') ? '' : $noborder_css;
        $render .= '<div id="pagequery" ' . $border_style . '>' . DOKU_LF;
        $top_id = 'top-' . mt_rand();   // fixed point to jump back to at top of the table
        $render .= '<table id="' . $top_id . '"><tbody><tr>' . DOKU_LF;

        // now render the pagequery list
        foreach ($sorted_results as $line) {
            list($level, $name, $id) = $line;
            $is_heading = ($level > 0);

            // is it time to start a new column?
            if ($can_start_col === false && $col < $cols && $cur_height >= $col_height) {
                $can_start_col = true;
                $col++;
            }

            // how should headings be displayed?
            if ($is_heading) {
                $heading = $name;
                if ($proper == 'header' || $proper == 'both') $heading = $this->_proper($heading);
            }

            // no need for indent if there is no grouping
            if ($group === false) {
                $indent_style = ' class="nogroup"';
            } else {
                $indent = ($is_heading) ? $level - 1 : $cont_level - 1;
                $indent_style = ' style="margin-left:' . $indent * 10 . 'px"';
            }

            // Begin new column if: 1) we are at the start, 2) last item was not a heading or 3) if there is no grouping
            if ($can_start_col && ! $prev_was_heading) {
                $jump_tip = sprintf($jump_txt, $heading);
                // close the previous column if necessary; also adds a 'jump to anchor'
                $col_close = ( ! $is_heading) ? '<a title="'. $jump_tip . '" href="#' .
                                $top_id . '">' . "<h$cont_level>... </h$cont_level></a>" : '';
                $col_close = ( ! $is_first) ? $col_close . '</ul></td>' . DOKU_LF : '';
                $col_open = ( ! $is_first && ! $is_heading) ? "<h$cont_level$indent_style>" . "$heading...</h$cont_level>" : '';
                $render .= $col_close . '<td' . $border_style . ' valign="top" width="' . $width . '%">' . $col_open . DOKU_LF;
                $can_start_col = false;
                $prev_was_heading = true;    // needed correctly style page link lists <ul>...
                $cur_height = 0;
            }

            // finally display the appropriate heading or page link(s)
            if ($is_heading) {
                // close previous sub list if necessary
                if ( ! $prev_was_heading) {
                    $render .= '</ul>' . DOKU_LF;
                }
                $render .= "<h$level$indent_style>$heading</h$level>" . DOKU_LF;
                $prev_was_heading = true;
                $cont_level = $level + 1;
            } else {
                // open a new sub list if necessary
                if ($prev_was_heading || $is_first) {
                    $render .= "<ul$indent_style>";
                }
                // deal with normal page links
                $link = $this->_render_wikilink($id, $name, $snippet, $snippet_cnt, $underline);
                $snippet_cnt++;
                $render .= $link;
                $prev_was_heading = false;
            }
            $cur_height += $ratios[$level];
            $is_first = false;
        }
        $render .= '</ul></td></tr>' . DOKU_LF;
        $render .= '</tbody></table>' . DOKU_LF;
        $render .= '<a class="top" href="#' . $top_id . '">' . $this->getLang('link_to_top') . '</a>' . DOKU_LF;
        $render .= '</div>' . DOKU_LF;

        return $render;
    }

    /**
     * Renders the page link, plus tooltip, abstract, casing, etc...
     * @param string $id
     * @param bool  $proper
     * @param bool  $title
     * @param mixed $abstract
     */
    private function _render_wikilink($id, $name, $snippet, $snippet_cnt, $underline) {

        $id = (strpos($id, ':') === false) ? ':' . $id : $id;   // : needed for root pages (root level)

        $box = '';
        if ($snippet != 'none') {
            list($snippet, $word_max) = explode(':', $snippet);
            $abstract = $this->_abstract($id);
            // show the "snippet" as a tooltip
            if ($snippet == 'tooltip' || ($snippet > 0 && $snippet_cnt >= $snippet)) {
                $link = $this->_html_wikilink_tooltip($id, $name, $abstract);
            } elseif ($snippet == 'inline') {
                $words = str_replace("\n", " ", $abstract);
                $words = wordwrap($words, $word_max);
                $words = strtok($words, "\n") . '...';
                $link = $this->_html_wikilink_tooltip($id, $name, $abstract);
                $link .= '<span>' . $words . '</span>';
            // -or- as a nice quoted snippet ( la blockquote plugin)
            } elseif ($snippet == 'all' || $snippet == 0 || ($snippet >= 0 && $snippet_cnt < $snippet)) {
                list($link, $box) = $this->_html_wikilink_snippet($id, $name, $abstract);
            }
        } else {
            // Plain old wikilink
            $link = html_wikilink($id, $name);
        }
        $noborder = ($underline) ? '' : ' class="noborder"';
        return "<li$noborder>" . $link . '</li>' . DOKU_LF . $box;
    }

    private function _proper($id) {
         $id = str_replace(':', ': ', $id); // make a little whitespace before words so ucwords can work!
         $id = str_replace('_', ' ', $id);
         $id = ucwords($id);
         $id = str_replace(': ', ':', $id);
         return $id;
    }
    /**
     * Swap normal link title (popup) for a more useful preview
     *
     * @param string $id    page id
     * @param string $name  display name
     * @return complete href link
     */
    private function _html_wikilink_tooltip($id, $name, $tooltip) {
        $link = html_wikilink($id, $name);
        $tooltip = str_replace("\n", '  ', $tooltip);
        $link = preg_replace('/title=\".+?\"/', 'title="' . $tooltip . '"', $link, 1);
        return $link;
    }

    private function _html_wikilink_snippet($id, $name, $snippet) {
        $link = html_wikilink($id, $name);
        $detail = str_replace("\n\n", '<br/>', $snippet);
        $more = html_wikilink($id, 'more...');
        $detail = '<blockquote>' . $detail . $more . '</blockquote>' . DOKU_LF;
        return array($link, $detail);
    }

    private function _abstract($id) {
        $abstract = p_get_metadata($id, 'description abstract', true);
        $abstract = htmlspecialchars($abstract, ENT_QUOTES, 'UTF-8');
        return $abstract;
    }

    /**
     * Parse out the namespace, and convert to a regex for array search
     *
     * @param  string $query user page query
     * @return string        processed query with regex markup as needed for namespace recognition
     */
    private function _parse_ns_query($query) {
        $incl_ns = array();
        $excl_ns = array();
        $page_qry = '';
        $tokens = explode(' ', $query);
        if (count($tokens) == 1) {
            $page_qry = $query;
        } else {
            foreach ($tokens as $token) {
                if (preg_match('/^(?:\^|-ns:)(.+)$/u', $token, $matches)) {
                    $excl_ns[] = $matches[1];
                } elseif (preg_match('/^(?:@|ns:)(.+)$/u', $token, $matches)) {
                    $incl_ns[] = $matches[1];
                } else {
                    $page_qry .= ' ' . $token;
                }
            }
        }
        $page_qry = trim($page_qry);
        return array($page_qry, $incl_ns, $excl_ns);
    }

    /**
     * Builds the sorting array: array of arrays (0 = id, 1 = name, 2 =..., 3 = ... , etc)
     *
     * @param array     $ids        array of page ids to be sorted
     * @param array     $sortkeys   list of array keys to sort by
     * @param bool      $title      use page heading instead of name for sorting
     * @param bool      $proper     use proper case where possible
     * @param bool      $inwords    show dates in words where possible
     * @param bool      $case       honour case when sorting
     * @param bool      $natsort    natural sorting, the human way
     *
     * @return array    $sort_array array of array(one value for each key to be sorted)
     *                   $sort_opts  sorting options for the msort function
     *                   $group_opts grouping options for the mgroup function
     */
    private function _get_options($ids, $sortkeys, $title, $proper, $inwords, $case, $natsort) {
        global $conf;

        $sort_opts = array();
        $group_opts = array();

        $dformat = array();
        $wformat = array();

        $row = 0;
        $end_col = START_KEY + count($sortkeys);

        foreach ($ids as $id) {
            $meta = p_get_metadata ($id, false, true);
            if ( ! isset($meta['date']['modified'])) {
                $meta['date']['modified'] = $meta['date']['created'];
            }
            // use page heading instead of page name
            if ($title && isset($meta['title'])) {
                $name = $meta['title'];
            } else {
                $name = noNS($id);
            }
            if ($proper == 'name' || $proper == 'both') {
                $name = $this->_proper($name);
            }
            // first column is the basic page id
            $sort_array[$row][ID_KEY] = $id;
            // second column is the display 'name' (used when sorting by 'name')
            // this also avoids rebuilding the display name when building links later (DRY)
            $sort_array[$row][NAME_KEY] = $name;
            $col = START_KEY;

            foreach ($sortkeys as $sortkey) {
                $key = $sortkey[0];
                switch ($key) {
                    case 'a':
                        $value = $this->_first($name, 1);
                        break;
                    case 'ab':
                        $value = $this->_first($name, 2);
                        break;
                    case 'abc':
                        $value = $this->_first($name, 3);
                        break;
                    case 'name':
                        // a name column already exists by default (col 1)
                        continue;
                    case 'id':
                    case 'page':
                        $value = $id;
                        break;
                    case 'ns':
                        $value = getNS($id);
                        if (empty($value)) $value = '[' . $conf['start'] . ']';
                        break;
                    case 'creator':
                        $value = $meta['creator'];
                        break;
                    case 'mdate':
                        $value = $meta['date']['modified'];
                        break;
                    case 'cdate':
                        $value = $meta['date']['created'];
                        break;
                    default:
                        // date sorting types (groupable)
                        $dtype = $key[0];
                        if ($dtype == 'c' || $dtype == 'm') {
                            // we only set real date once per id (needed for grouping)
                            // not per sort column--the date should remain same across all columns
                            // this is always the last column!
                            if ($col == START_KEY) {
                                if ($dtype == 'c') {
                                    $date = $meta['date']['created'];
                                } else {
                                    $date = $meta['date']['modified'];
                                }
                                $sort_array[$row][$end_col] = $date;
                            } else {
                                $date = $sort_array[$row][$end_col] ;
                            }
                            // only set date formats once per sort column/key (not per id!)
                            if ($row == 0) {
                                $dformat[$col] = $this->_date_format($key);
                                // collect date in word format for potential use in grouping
                                if ($inwords) {
                                    $wformat[$col] = $this->_date_format_words($dformat[$col]);
                                } else {
                                    $wformat[$col] = '';
                                }
                            }
                            // create a string date used for sorting only
                            // (we cannot just use the real date otherwise it would not group correctly)
                            $value = strftime($dformat[$col], $date);
                        }
                }
                $sort_array[$row][$col] = $value;
                $col++;
            }
            $row++;
        }

        $cnt = START_KEY;
        $order = 0;
        foreach ($sortkeys as $sortkey) {
            list($key, $opt) = $sortkey;

            if ($key == 'name') {
                $col = NAME_KEY;
                // this col number will be re-used next time through
            } else {
                $col = $cnt;
                $cnt++;
            }
            $sort_opts['key'][] = $col;

            // now the sort direction
            switch ($opt) {
                case 'a':
                case 'asc':
                    $dir = MSORT_ASC;
                    break;
                case 'd':
                case 'desc':
                    $dir = MSORT_DESC;
                    break;
                default:
                    // sort descending by default; text ascending
                    // watch for other sort options beginning with c or m ....!
                    if ($key[0] == 'c' || $key[0] == 'm') {
                        $dir = MSORT_DESC;
                    } else {
                        $dir = MSORT_ASC;
                    }
            }
            $sort_opts['dir'][] = $dir;

            // set the sort array's data type
            $is_ns = false;
            switch ($key) {
                case 'mdate':
                case 'cdate':
                    $type = MSORT_NUMERIC;
                    break;
                default:
                    if ($case) {
                        // case sensitive: a-z then A-Z
                        $type = ($natsort) ? MSORT_NAT : MSORT_STRING;
                    } else {
                        // case-insensitive
                        $type = ($natsort) ? MSORT_NAT_CASE : MSORT_STRING_CASE;
                    }
            }
            $sort_opts['type'][] = $type;

            // now establish grouping options
            switch ($key) {
                // name strings and full dates cannot be meaningfully grouped (no duplicates!)
                case 'mdate':
                case 'cdate':
                case 'name':
                case 'id':
                case 'page':
                    $group_by = MGROUP_NONE;
                    break;
                case 'ns':
                    $group_by = MGROUP_NAMESPACE;
                    break;
                default:
                    $group_by = MGROUP_HEADING;
            }
            if ($group_by != MGROUP_NONE) {
                $group_opts['key'][$order] = $col;
                $group_opts['type'][$order] = $group_by;
                $group_opts['dformat'][$order] = $wformat[$col];
                $order++;
            }
        }
        return array($sort_array, $sort_opts, $group_opts);
    }

    // returns first $count letters from $text
    private function _first($text, $count) {
        if ($count > 0) {
            return utf8_substr($text, 0, $count);
        }
    }

    /**
     * Parse the c|m-year-month-day option; used for sorting/grouping
     *
     * @param string  $key
     * @return string
     */
    private function _date_format($key) {
        if (strpos($key, 'year') !== false) $dkey[] = '%Y';
        if (strpos($key, 'month') !== false) $dkey[] = '%m';
        if (strpos($key, 'day') !== false) $dkey[] = '%d';
        $dformat = implode('-', $dkey);
        return $dformat;
    }

    /**
     * provide month and day format in real words if required
     * used for display only ($dformat is used for sorting/grouping)
     *
     * @param string $dformat
     * @return string
     */
    private function _date_format_words($dformat) {
        $wformat = '';
        switch ($dformat) {
            case '%m':
                $wformat = "%B";
                break;
            case '%d':
                $wformat = "%#d%A ";
                break;
            case '%Y-%m':
                $wformat = "%B %Y";
                break;
            case '%m-%d':
                $wformat= "%B %#d, %A ";
                break;
            case '%Y-%m-%d':
                $wformat = "%A, %B %#d, %Y";
                break;
        }
        return $wformat;
    }

    /**
     * A heavily customised version of _ft_pageLookup in inc/fulltext.php
     * no sorting!
     */
    private function _page_lookup($query, $pageonly, $incl_ns, $excl_ns, $nostart = true, $maxns = 0) {
        global $conf;

        $queries = trim($query);
        $pages = file($conf['indexdir'] . '/page.idx');

        // first deal with excluded namespaces, then included
        $pages = $this->_filter_ns($pages, $excl_ns, true);

        // now include ONLY the selected namespaces if provided
        $pages = $this->_filter_ns($pages, $incl_ns, false);

        $cnt = count($pages);
        for ($i = 0; $i < $cnt; $i++) {
            $page = $pages[$i];
            if ( ! page_exists($page) || isHiddenPage($page)) {
                unset($pages[$i]);
                continue;
            }
            if ($pageonly) $page = noNS($page);
            /*
             * This is the actual "search" expression!
             * Note: preg_grep cannot be used because the pageonly option above
             *       (need to allow for "^" syntax)
             * The @ prevents problems with invalid queries!
             */
            if (@preg_match('/' . $query . '/i', $page) == 0) {
                unset($pages[$i]);
            }
        }
        if ( ! count($pages)) return array();

        $pages = array_map('trim',$pages);

        // check ACL permissions and remove any 'start' pages if req'd
        $start = $conf['start'];
        $pos = strlen($start);
        foreach($pages as $idx => $name) {
            if ($nostart && substr($name, -$pos) == $start) {
                unset($pages[$idx]);
            } elseif(auth_quickaclcheck(trim($pages[$idx])) < AUTH_READ){
                unset($pages[$idx]);
            } elseif ($maxns > 0 && (substr_count($name,':') + 1) > $maxns) {
                unset($pages[$idx]);    //skip this page
            }
        }
        return $pages;
    }

    private function _filter_ns($pages, $ns_qry, $exclude) {
        $invert = ($exclude) ? PREG_GREP_INVERT : 0;
        foreach ($ns_qry as $ns) {
            $regexes[] = '.*' . $ns . ':.*';
        }
        if ( ! empty($regexes)) {
            $regex = '/(' . implode('|', $regexes) . ')/';
            return array_values(preg_grep($regex, $pages, $invert));
        } else {
            return $pages;
        }
    }
}
?>
blob
mark :88
data 3288
div.dokuwiki div.pagequery {
    position:relative;
    margin:0 0 1em 0;
    padding:4px;
    border-width:1px;
    -moz-border-radius:8px;
    -webkit-border-radius:8px;
}
div.dokuwiki .notable {
    padding:12px 14px 24px !important;
}
div.dokuwiki div.pagequery table {
    border-collapse:collapse;
    width:100%;
    margin:0;
}
div.dokuwiki div.pagequery,
div.dokuwiki div.pagequery td {
	border-style:solid;
	border-color:#D7D5D4;
}
div.dokuwiki div.pagequery td {
	padding:8px 10px 20px;
	background-color:white;
    border-width:0 1px 0 0;
}
div.dokuwiki div.pagequery.noborder,
div.dokuwiki div.pagequery td.noborder,
div.dokuwiki div.pagequery td:nth-last-child(1),
div.dokuwiki div.pagequery li.noborder {
    border-width:0;
}

div.dokuwiki div.pagequery h1,
div.dokuwiki div.pagequery h2,
div.dokuwiki div.pagequery h3,
div.dokuwiki div.pagequery h4,
div.dokuwiki div.pagequery h5,
div.dokuwiki div.pagequery h6 {
    padding:0.06em 0 0.03em 0;
    margin:0;
    margin-bottom:2px;
    color:#A0A0A0;
}
div.dokuwiki div.pagequery h3,
div.dokuwiki div.pagequery h4,
div.dokuwiki div.pagequery h5,
div.dokuwiki div.pagequery h6 {
    font-weight:normal;
}
div.dokuwiki div.pagequery h1 {
    font-size:134%;
    padding:0px 0px 3px 7px;
    background:#EDEDED;
    -moz-border-radius:6px;
    -webkit-border-radius:6px;
}
div.dokuwiki div.pagequery h2 {font-size:125%; font-weight:bold;}
div.dokuwiki div.pagequery h3 {font-size:114%;}
div.dokuwiki div.pagequery h4 {font-size:108%;}
div.dokuwiki div.pagequery h5 {font-size:100%;}
div.dokuwiki div.pagequery h6 {font-size:95%;}


div.dokuwiki div.pagequery ul {
    list-style:none;
    margin:0 0 8px 0;
	text-align:left;
}
div.dokuwiki div.pagequery ul.nogroup {
    margin:0 0 5px 3px;
}
div.dokuwiki div.pagequery li {
	padding-left:10px;
	text-indent:-10px;
    line-height:135%;
    border-top:1px dotted #D7D5D4;
}
div.dokuwiki div.pagequery li span,
div.dokuwiki div.pagequery .plain {
    font-size:80%;
    font-style:italic !important;
    color:#A0A0A0;
}
div.dokuwiki div.pagequery li span {
    margin-left:0.7em;
}
div.dokuwiki div.pagequery .plain {
    margin:0.1em 0.5em 0.2em;
    padding:5px;
}
div.dokuwiki div.pagequery li:nth-child(1) {
    border:0;
}
div.dokuwiki div.pagequery a:hover {
    text-decoration:none;
    color:#202020 !important;
}
div.dokuwiki div.pagequery a.top {
    position:absolute;
    bottom:0.4em;
    right:0.5em;
    font-style:italic;
    color:#A0A0A0;
}
/* credit: blockquote:plugin */
div.dokuwiki div.pagequery .quoted {
    font-size:80%;
	margin:5px 15px 10px 15px !important;
	border:1px dotted __border__ !important;
	background:#FAFACE url(images/blockquote.gif) no-repeat 5px 5px !important;
	padding:10px 15px 15px 18px !important;
    -moz-border-radius:6px;
    -webkit-border-radius:6px;
}
div.dokuwiki div.pagequery .quoted a,
div.dokuwiki div.pagequery .plain a {
    margin-left:0.5em;
}
div.dokuwiki div.pagequery p.noresults {
    color:#899BB2 !important;
    font-size:1.2em;
    margin-left:1.2em;
}
div.dokuwiki div.pagequery p.noresults span {
    font-size:0.8em;
    line-height:1.2em;
    font-style:italic;
    padding:3px 6px;
    margin-right:0.3em;
    background-color:#EDEDED;
    -moz-border-radius:3px;
    -webkit-border-radius:3px;
}

blob
mark :89
data 33464
<?php
/**
 * PageQuery Plugin: search for and list pages, sorted/grouped by name, date, creator, etc
 *
 * @license    GPL 2 (http://www.gnu.org/licenses/gpl.html)
 * @author	   Symon Bent <hendrybadao@gmail.com>
 */

// must be run within Dokuwiki
if(!defined('DOKU_INC')) die();

if (!defined('DOKU_LF')) define('DOKU_LF', "\n");
if (!defined('DOKU_TAB')) define('DOKU_TAB', "\t");
if (!defined('DOKU_PLUGIN')) define('DOKU_PLUGIN',DOKU_INC.'lib/plugins/');

require_once(DOKU_PLUGIN . 'syntax.php');
require_once(DOKU_INC . 'inc/fulltext.php');
require_once(DOKU_PLUGIN . 'pagequery/inc/msort.php');

define ('ID_KEY', 0);
define ('NAME_KEY', 1);
define ('ABST_KEY', 2);
define ('START_KEY', 3);
define ('MAX_COLS', 6);

class syntax_plugin_pagequery extends DokuWiki_Syntax_Plugin {

	function getType() {
		return 'substition';
	}

	function getPType() {
		return 'block';
	}

	function getSort() {
		return 98;
	}

	function connectTo($mode) {
		$this->Lexer->addSpecialPattern('\{\{pagequery>.*?\}\}', $mode, 'plugin_pagequery');
	}

    /**
     * Parses all the pagequery options:
     * Insert the pagequery markup wherever you want your list to appear. E.g:
     *
     *   {{pagequery>}}
     *
     *   {{pagequery>[query];fulltext;sort=key:direction,key2:direction;group;limit=??;cols=?;inwords;proper}}
     *
     * Parameters as follows:
     * 1. query:    any expression directly after the >; can use all Dokuwiki search options (see manual)
     * 2. fulltext: use a full-text search, instead of page_id only [default]
     * 3. sort:     keys to sort by, in order of sorting. Each key can be followed by prefered sorting order
     *              available keys:
     *                  a, ab, abc          by 1st letter, 2 letters, or 3 letters
     *                  name                by page name (no namespace) or 1st heading [not grouped]
     *                  page|id             by full page id, including namespace [not grouped]
     *                  ns                  by namespace (without page name)
     *                  mdate, cdate        by modified|created dates (full) [not grouped]
     *                  m[year][month][day] by modified [year][month][day]; any combination accepted
     *                  c[year][month][day] by created [year][month][day]; any combination accepted
     *                  creator             by page author
     *              date sort default to descending, string sorts to ascending
     * 4. group:    show group headers for each change in sort keys
     *              Note: keys with no duplicate cannot be grouped (i.e. name, page|id, mdate, cdate)
     * 5. limit:    maximum number of results to return
     * 6. inwords:  use real month and day names instead of numeric dates
     * 7. cols:     number of columns in displayed list (max = 6)
     * 8. proper:   display page names and namespace in Proper Case (i.e. no _'s and Capitalised)
     *              header/hdr = group headers only, name = page name only, both = both!
     * 9. border:   turn on borders. 'inside' = between columns; 'outside' => border around table;
     *              'both' => in and out; 'none' => neither
     *10. fullregex:only useful on page name searches; allows a raw regex mode on the full page id
     *11. nostart:  ignore any 'start' pages in namespace (based on "config:start")
     *12. maxns:    maximum namespace level to be displayed; e.g. maxns=3 => one:two:three
     *13. title:    show 1st page heading instead of page name
     *14. snippet:  should an excerpt of the wikipage be shown:
     *              use :tooltip to show as a pop-up only
     *              use :<inline|plain|quoted>, <count>, <extent> to show 1st <count> items in list with an abstract
     *                  extent always choice of chars, words, lines, or find (c? w? l? ~????)
     *15. natsort:  use natural sorting order (good for words beginning with numbers)
     *16. case:     respect case when sorting, i.e. a != A when sorting.  a-z then A-Z (opp. to PHP term, easier on average users)
     *17. underline:show a faint underline between each link for clarity
     *
     * All options are optional, and the list will default to a boring long 1-column list...
     */
	function handle($match, $state, $pos, &$handler) {

		$match = substr($match, 12, -2); // strip markup "{{pagequery>"
		$options = explode(';', $match);
        $query = $options[0];

        // establish some basic option defaults
        $sort = array();
        $fulltext = false;
        $group = false;
        $limit = 0;
        $maxns = 0;
        $cols = 1;
        $proper = 'none';
        $border = 'none';
        $snippet = array('none');
        $title = false;
        $fullregex = false;
        $case = false;
        $natsort = false;
        $underline = false;

        foreach ($options as $option) {
            list($key, $value) = explode('=', $option);
            switch ($key) {
                case 'fulltext':
                    $fulltext = true;
                    break;
                case 'sort':
                    $values = explode(',', $value);
                    foreach ($values as $value) {
                        list($key, $dir) = explode(':', $value);
                        $sort[] = array($key, $dir);
                    }
                    break;
                case 'group':
                    $group = true;
                    break;
                case 'limit':
                    $limit = $value;
                    break;
                case 'maxns':
                    $maxns = $value;
                    break;
                case 'inwords':
                    $inwords = true;
                    break;
                case 'proper':
                    switch ($value) {
                        case 'hdr':
                        case 'header':
                        case 'group':
                            $proper = 'header';
                            break;
                        case 'name':
                        case 'page':
                            $proper = 'name';
                            break;
                        default:
                            $proper = 'both';
                    }
                    break;
                case 'cols':
                    $cols = ($value > MAX_COLS) ? MAX_COLS : $value;
                    break;
                case 'border':
                    switch ($value) {
                        case 'none':
                        case 'inside':
                        case 'outside':
                        case 'both':
                            $border = $value;
                            break;
                        default:
                            $border = 'both';
                    }
                    break;
				case 'fullregex':
					$fullregex = true;
					break;
                case 'nostart':
                    $nostart = true;
                    break;
                case 'title':
                    $title = true;
                    break;
                case 'abstract':    // old syntax, to be deprecated (2011-03-15)
                case 'snippet':
                    $opts = explode(',', $value);
                    $type = ( ! empty($opts[0])) ? $opts[0] : 'tooltip';
                    $valid = array('none', 'tooltip', 'inline', 'plain', 'quoted');
                    if ( ! in_array($type, $valid)) $type = 'tooltip';  // always valid!
                    $count = ( ! empty($opts[1])) ? $opts[1] : 0;
                    $extent = ( ! empty($opts[2])) ? $opts[2] : '';
                    $snippet = array($type, $count, $extent);
                    break;
                case 'case':
                    $case = true;
                    break;
                case 'natsort':
                    $natsort = true;
                    break;
                case 'underline':
                    $underline = true;
                    break;
            }
        }
		return array($query, $fulltext, $sort, $group, $limit, $maxns, $proper,
                      $cols, $inwords, $border, $fullregex, $nostart, $title,
                      $snippet, $case, $natsort, $underline);
	}

    function render($mode, &$renderer, $data) {
        $sortkeys = array();
        $incl_ns = array();
        $excl_ns = array();

        list($query, $fulltext, $sort, $group, $limit, $maxns, $proper,
              $cols, $inwords, $border, $fullregex, $nostart, $title,
              $snippet, $case, $natsort, $underline) = $data;

        if ($mode == 'xhtml') {
            // first get a raw list of matching results

            if ($fulltext) {
                // full text (Dokuwiki style) searching
                $results = array_keys(ft_pageSearch($query, $highlight));
            } else {
                // by page id only (
                if ($fullregex) {
                    // allow for raw regex mode, for power users, this searches the full page id
                    $pageonly = false;
                } else {
                    list($query, $incl_ns, $excl_ns) = $this->_parse_ns_query($query);
                    $pageonly = true;
                }
                if ($query == '*') $query = '.*';   // a lazy man's option!
                $results = $this->_page_lookup($query, $pageonly, $incl_ns, $excl_ns, $nostart, $maxns);
            }

            if ( ! empty($results)) {
                // this section is where the essential pagequery functionality happens...

                // prepare the necessary sorting arrays, as per users options
                $get_abstract = ($snippet[0] != 'none');
                list($sort_array, $sort_opts, $group_opts) =
                    $this->_build_sorting_array($results, $sort, $title, $proper, $inwords, $case, $natsort, $get_abstract);

                // now do the sorting (inc/msort.php)
                msort($sort_array, $sort_opts);
                // limit the result list length if required; this can only be done after sorting!
                $sort_array = ($limit > 0) ? array_slice($sort_array, 0, $limit) : $sort_array;

                // and finally the grouping
                if ($group) {
                    $keys = array(NAME_KEY, ID_KEY, ABST_KEY);
                    $sorted_results = mgroup($sort_array, $keys, $group_opts);
                } else {
                    foreach ($sort_array as $row) {
                        $sorted_results[] = array(0, $row[NAME_KEY], $row[ID_KEY], $row[ABST_KEY]);
                    }
                }
                $renderer->doc .= $this->_render_list($sorted_results, $cols, $proper, $snippet, $border, $underline);
            } else {
                $renderer->doc .= $this->_render_no_list($query);
            }
            return true;
        } else {
            return false;
        }
    }

    private function _adjusted_height($sorted_results, $ratios) {
        // ratio of different heading heights (%), to ensure more even use of columns (h1 -> h6)
        foreach ($sorted_results as $row) {
            $adjusted_height += $ratios[$row[0]];
        }
        return $adjusted_height;
    }

    /**
     * Render a simple "no results" message
     *
     * @param string $query => original query
     * @return string
     */
    private function _render_no_list($query) {
        $render = '<div id="pagequery" class="noborder">' . DOKU_LF;
        $render .= '<p class="noresults"><span>pagequery</span>' . $this->getLang("no_results") .
                                  '&nbsp; <strong>' . $query . '</strong></p>' . DOKU_LF;
        $render .= '</div>' . DOKU_LF;
        return $render;
    }
    /**
     * Render the final pagequery results list as HTML, indented and in columns as required
     *
     * @param array  $sorted_results
     * @param int    $cols
     * @param bool   $proper
     * @param string $snippet
     * @param string $border
     * @return string => HTML rendered list
     */
    private function _render_list($sorted_results, $cols, $proper, $snippet, $border, $underline) {
        $ratios = array(.80, 1.3, 1.17, 1.1, 1.03, .96, .90);   // link, h1, h2, h3, h4, h5, h6
        $render = '';
        $prev_was_heading = false;
        $can_start_col = true;
        $cont_level = 1;
        $col = 0;
        $col_height = $this->_adjusted_height($sorted_results, $ratios) / $cols;
        $cur_height = 0;
        $width = floor(100 / $cols);
        $snippet_cnt = 0;    // needed by the snippet section for tracking
        $jump_txt= $this->getLang('jump_section');
        $is_first = true;

        // basic result page markup (always needed)
        $outer_border = ($border == 'outside' || $border == 'both') ? '' : ' noborder';
        $no_table = ($cols == 1) ? ' notable' : '';
        $top_id = 'top-' . mt_rand();   // fixed anchor point to jump back to at top of the table
        $render .= '<div class="pagequery' . $outer_border . $no_table . '" id="' . $top_id . '">' . DOKU_LF;
        if ($cols > 1) $render .= '<table><tbody><tr>' . DOKU_LF;

        $inner_border = ($border == 'inside' || $border == 'both') ? '' : ' class="noborder" ';

        // now render the pagequery list
        foreach ($sorted_results as $line) {
            list($level, $name, $id, $abstract) = $line;
            $is_heading = ($level > 0);

            // is it time to start a new column?
            if ($can_start_col === false && $col < $cols && $cur_height >= $col_height) {
                $can_start_col = true;
                $col++;
            }

            // how should headings be displayed?
            if ($is_heading) {
                $heading = $name;
                if ($proper == 'header' || $proper == 'both') $heading = $this->_proper($heading);
            }

            // no need for indent if there is no grouping
            if ($group === false) {
                $indent_style = ' class="nogroup"';
            } else {
                $indent = ($is_heading) ? $level - 1 : $cont_level - 1;
                $indent_style = ' style="margin-left:' . $indent * 10 . 'px"';
            }

            // Begin new column if: 1) we are at the start, 2) last item was not a heading or 3) if there is no grouping
            if ($can_start_col && ! $prev_was_heading) {
                $jump_tip = sprintf($jump_txt, $heading);
                // close the previous column if necessary; also adds a 'jump to anchor'
                $col_close = ( ! $is_heading) ? '<a title="'. $jump_tip . '" href="#' .
                                $top_id . '">' . "<h$cont_level>... </h$cont_level></a>" : '';
                $col_close = ( ! $is_first) ? $col_close . '</ul></td>' . DOKU_LF : '';
                $col_open = ( ! $is_first && ! $is_heading) ? "<h$cont_level$indent_style>" . "$heading...</h$cont_level>" : '';
                $td = ($cols > 1) ? '<td' . $inner_border . ' valign="top" width="' . $width . '%">' : '';
                $render .= $col_close . $td . $col_open . DOKU_LF;
                $can_start_col = false;
                $prev_was_heading = true;    // needed to correctly style page link lists <ul>...
                $cur_height = 0;
            }

            // finally display the appropriate heading or page link(s)
            if ($is_heading) {
                // close previous sub list if necessary
                if ( ! $prev_was_heading) {
                    $render .= '</ul>' . DOKU_LF;
                }
                $render .= "<h$level$indent_style>$heading</h$level>" . DOKU_LF;
                $prev_was_heading = true;
                $cont_level = $level + 1;
            } else {
                // open a new sub list if necessary
                if ($prev_was_heading || $is_first) {
                    $render .= "<ul$indent_style>";
                }
                // deal with normal page links
                $link = $this->_html_wikilink($id, $name, $snippet, $snippet_cnt, $abstract, $underline);
                $snippet_cnt++;
                $render .= $link;
                $prev_was_heading = false;
            }
            $cur_height += $ratios[$level];
            $is_first = false;
        }
        $render .= '</ul>' . DOKU_LF;
        if ($cols > 1) $render .= '</td></tr></tbody></table>' . DOKU_LF;
        $render .= '<a class="top" href="#' . $top_id . '">' . $this->getLang('link_to_top') . '</a>' . DOKU_LF;
        $render .= '</div>' . DOKU_LF;

        return $render;
    }

    /**
     * Renders the page link, plus tooltip, abstract, casing, etc...
     * @param string $id
     * @param bool  $proper
     * @param bool  $title
     * @param mixed $snippet
     * @param int   $snipet_cnt
     * @param bool  $underline
     */
    private function _html_wikilink($id, $name, $snippet_opt, $snippet_cnt, $abstract, $underline) {

        $id = (strpos($id, ':') === false) ? ':' . $id : $id;   // : needed for root pages (root level)

        list($type, $max, $extent) = $snippet_opt;
        $after= '';
        $inline = '';

        if ($type == 'none') {
            // Plain old wikilink
            $link = html_wikilink($id, $name);
            break;
        } else {
            $short = $this->_shorten($abstract, $extent);
            $short = htmlentities($short, ENT_QUOTES, 'UTF-8');
            $abstract = htmlentities($abstract, ENT_QUOTES, 'UTF-8');
            $link = html_wikilink($id, $name);
            $no_snippet = ($max > 0 && $snippet_cnt >= $max);
            if ($type == 'tooltip' || $no_snippet) {
                $link = $this->_add_tooltip($link, $abstract);
            } elseif ($type == 'quoted' || $type == 'plain') {
                $more = html_wikilink($id, 'more');
                $after = trim($short);
                $after= str_replace("\n\n", "\n", $after);
                $after= str_replace("\n", '<br/>', $after);
                $after= '<div class="' . $type . '">' . $after . $more . '</div>' . DOKU_LF;
            } elseif ($type == 'inline') {
                $inline .= '<span>' . $short . '</span>';
            }
        }
        $noborder = ($underline) ? '' : ' class="noborder"';
        return "<li$noborder>" . $link . $inline . '</li>' . DOKU_LF . $after;
    }

    /**
     * Swap normal link title (popup) for a more useful preview
     *
     * @param string $id    page id
     * @param string $name  display name
     * @return complete href link
     */
    private function _add_tooltip($link, $tooltip) {
        $tooltip = str_replace("\n", '  ', $tooltip);
        $link = preg_replace('/title=\".+?\"/', 'title="' . $tooltip . '"', $link, 1);
        return $link;
    }

    /**
     * return the first part of the $text according to the $amount given
     * @param type $text
     * @param type $amount  c? = ? chars, w? = ? words, l? = ? lines, ~? = search up to text/char/symbol
     */
    private function _shorten($text, $extent, $more = '... ') {
        $elem = $extent[0];
        $cnt = substr($extent, 1);
        switch ($elem) {
            case 'c':
                $result = substr($text, 0, $cnt);
                if ($cnt > 0 && strlen($result) < strlen($text)) $result .= $more;
                break;
            case 'w':
                $words = str_word_count($text, 1, '.');
                $result = implode(' ', array_slice($words, 0, $cnt));
                echo $cnt;
                if ($cnt > 0 && $cnt <= count($words) && $words[$cnt - 1] != '.') $result .= $more;
                break;
            case 'l':
                $lines = explode("\n", $text);
                $lines = array_filter($lines);  // remove blank lines
                $result = implode("\n", array_slice($lines, 0, $cnt));
                if ($cnt > 0 && $cnt < count($lines)) $result .= $more;
                break;
            case "~":
                $result = strstr($text, $cnt, true);
                break;
            default:
                $result = $text;
        }
        return $result;
    }

    private function _proper($id) {
         $id = str_replace(':', ': ', $id); // make a little whitespace before words so ucwords can work!
         $id = str_replace('_', ' ', $id);
         $id = ucwords($id);
         $id = str_replace(': ', ':', $id);
         return $id;
    }

    /**
     * Parse out the namespace, and convert to a regex for array search
     *
     * @param  string $query user page query
     * @return string        processed query with regex markup as needed for namespace recognition
     */
    private function _parse_ns_query($query) {
        $incl_ns = array();
        $excl_ns = array();
        $page_qry = '';
        $tokens = explode(' ', $query);
        if (count($tokens) == 1) {
            $page_qry = $query;
        } else {
            foreach ($tokens as $token) {
                if (preg_match('/^(?:\^|-ns:)(.+)$/u', $token, $matches)) {
                    $excl_ns[] = $matches[1];
                } elseif (preg_match('/^(?:@|ns:)(.+)$/u', $token, $matches)) {
                    $incl_ns[] = $matches[1];
                } else {
                    $page_qry .= ' ' . $token;
                }
            }
        }
        $page_qry = trim($page_qry);
        return array($page_qry, $incl_ns, $excl_ns);
    }

    /**
     * Builds the sorting array: array of arrays (0 = id, 1 = name, 2 =..., 3 = ... , etc)
     *
     * @param array     $ids        array of page ids to be sorted
     * @param array     $sortkeys   list of array keys to sort by
     * @param bool      $title      use page heading instead of name for sorting
     * @param bool      $proper     use proper case where possible
     * @param bool      $inwords    show dates in words where possible
     * @param bool      $case       honour case when sorting
     * @param bool      $natsort    natural sorting, the human way
     *
     * @return array    $sort_array array of array(one value for each key to be sorted)
     *                   $sort_opts  sorting options for the msort function
     *                   $group_opts grouping options for the mgroup function
     */
    private function _build_sorting_array($ids, $sortkeys, $title, $proper, $inwords, $case, $natsort, $get_abstract) {
        global $conf;

        $sort_opts = array();
        $group_opts = array();
        $abstracts = array();

        $dformat = array();
        $wformat = array();

        $row = 0;
        $end_col = START_KEY + count($sortkeys);

        foreach ($ids as $id) {
            $meta = p_get_metadata ($id, false, true);

            if ( ! isset($meta['date']['modified'])) {
                $meta['date']['modified'] = $meta['date']['created'];
            }
            // use page heading instead of page name
            if ($title && isset($meta['title'])) {
                $name = $meta['title'];
            } else {
                $name = noNS($id);
            }
            if ($proper == 'name' || $proper == 'both') {
                $name = $this->_proper($name);
            }
            // first column is the basic page id
            $sort_array[$row][ID_KEY] = $id;
            // second column is the display 'name' (used when sorting by 'name')
            // this also avoids rebuilding the display name when building links later (DRY)
            $sort_array[$row][NAME_KEY] = $name;
            // cache the page abstract if needed; this saves a lot of time later
            // and avoids repeated slow metadata retrievals (v. slow!)
            $sort_array[$row][ABST_KEY] = ($get_abstract) ? $meta['description']['abstract'] : '';

            $col = START_KEY;

            foreach ($sortkeys as $sortkey) {
                $key = $sortkey[0];
                switch ($key) {
                    case 'a':
                        $value = $this->_first($name, 1);
                        break;
                    case 'ab':
                        $value = $this->_first($name, 2);
                        break;
                    case 'abc':
                        $value = $this->_first($name, 3);
                        break;
                    case 'name':
                        // a name column already exists by default (col 1)
                        continue;
                    case 'id':
                    case 'page':
                        $value = $id;
                        break;
                    case 'ns':
                        $value = getNS($id);
                        if (empty($value)) $value = '[' . $conf['start'] . ']';
                        break;
                    case 'creator':
                        $value = $meta['creator'];
                        break;
                    case 'mdate':
                        $value = $meta['date']['modified'];
                        break;
                    case 'cdate':
                        $value = $meta['date']['created'];
                        break;
                    default:
                        // date sorting types (groupable)
                        $dtype = $key[0];
                        if ($dtype == 'c' || $dtype == 'm') {
                            // we only set real date once per id (needed for grouping)
                            // not per sort column--the date should remain same across all columns
                            // this is always the last column!
                            if ($col == START_KEY) {
                                if ($dtype == 'c') {
                                    $date = $meta['date']['created'];
                                } else {
                                    $date = $meta['date']['modified'];
                                }
                                $sort_array[$row][$end_col] = $date;
                            } else {
                                $date = $sort_array[$row][$end_col] ;
                            }
                            // only set date formats once per sort column/key (not per id!)
                            if ($row == 0) {
                                $dformat[$col] = $this->_date_format($key);
                                // collect date in word format for potential use in grouping
                                if ($inwords) {
                                    $wformat[$col] = $this->_date_format_words($dformat[$col]);
                                } else {
                                    $wformat[$col] = '';
                                }
                            }
                            // create a string date used for sorting only
                            // (we cannot just use the real date otherwise it would not group correctly)
                            $value = strftime($dformat[$col], $date);
                        }
                }
                $sort_array[$row][$col] = $value;
                $col++;
            }
            $row++;
        }

        $cnt = START_KEY;
        $order = 0;
        foreach ($sortkeys as $sortkey) {
            list($key, $opt) = $sortkey;

            if ($key == 'name') {
                $col = NAME_KEY;
                // this col number will be re-used next time through
            } else {
                $col = $cnt;
                $cnt++;
            }
            $sort_opts['key'][] = $col;

            // now the sort direction
            switch ($opt) {
                case 'a':
                case 'asc':
                    $dir = MSORT_ASC;
                    break;
                case 'd':
                case 'desc':
                    $dir = MSORT_DESC;
                    break;
                default:
                    // sort descending by default; text ascending
                    // watch for other sort options beginning with c or m ....!
                    if ($key[0] == 'c' || $key[0] == 'm') {
                        $dir = MSORT_DESC;
                    } else {
                        $dir = MSORT_ASC;
                    }
            }
            $sort_opts['dir'][] = $dir;

            // set the sort array's data type
            $is_ns = false;
            switch ($key) {
                case 'mdate':
                case 'cdate':
                    $type = MSORT_NUMERIC;
                    break;
                default:
                    if ($case) {
                        // case sensitive: a-z then A-Z
                        $type = ($natsort) ? MSORT_NAT : MSORT_STRING;
                    } else {
                        // case-insensitive
                        $type = ($natsort) ? MSORT_NAT_CASE : MSORT_STRING_CASE;
                    }
            }
            $sort_opts['type'][] = $type;

            // now establish grouping options
            switch ($key) {
                // name strings and full dates cannot be meaningfully grouped (no duplicates!)
                case 'mdate':
                case 'cdate':
                case 'name':
                case 'id':
                case 'page':
                    $group_by = MGROUP_NONE;
                    break;
                case 'ns':
                    $group_by = MGROUP_NAMESPACE;
                    break;
                default:
                    $group_by = MGROUP_HEADING;
            }
            if ($group_by != MGROUP_NONE) {
                $group_opts['key'][$order] = $col;
                $group_opts['type'][$order] = $group_by;
                $group_opts['dformat'][$order] = $wformat[$col];
                $order++;
            }
        }
        return array($sort_array, $sort_opts, $group_opts, $abstracts);
    }

    // returns first $count letters from $text
    private function _first($text, $count) {
        if ($count > 0) {
            return utf8_substr($text, 0, $count);
        }
    }

    /**
     * Parse the c|m-year-month-day option; used for sorting/grouping
     *
     * @param string  $key
     * @return string
     */
    private function _date_format($key) {
        if (strpos($key, 'year') !== false) $dkey[] = '%Y';
        if (strpos($key, 'month') !== false) $dkey[] = '%m';
        if (strpos($key, 'day') !== false) $dkey[] = '%d';
        $dformat = implode('-', $dkey);
        return $dformat;
    }

    /**
     * provide month and day format in real words if required
     * used for display only ($dformat is used for sorting/grouping)
     *
     * @param string $dformat
     * @return string
     */
    private function _date_format_words($dformat) {
        $wformat = '';
        switch ($dformat) {
            case '%m':
                $wformat = "%B";
                break;
            case '%d':
                $wformat = "%#d%A ";
                break;
            case '%Y-%m':
                $wformat = "%B %Y";
                break;
            case '%m-%d':
                $wformat= "%B %#d, %A ";
                break;
            case '%Y-%m-%d':
                $wformat = "%A, %B %#d, %Y";
                break;
        }
        return $wformat;
    }

    /**
     * A heavily customised version of _ft_pageLookup in inc/fulltext.php
     * no sorting!
     */
    private function _page_lookup($query, $pageonly, $incl_ns, $excl_ns, $nostart = true, $maxns = 0) {
        global $conf;

        $queries = trim($query);
        $pages = file($conf['indexdir'] . '/page.idx');

        // first deal with excluded namespaces, then included
        $pages = $this->_filter_ns($pages, $excl_ns, true);

        // now include ONLY the selected namespaces if provided
        $pages = $this->_filter_ns($pages, $incl_ns, false);

        $cnt = count($pages);
        for ($i = 0; $i < $cnt; $i++) {
            $page = $pages[$i];
            if ( ! page_exists($page) || isHiddenPage($page)) {
                unset($pages[$i]);
                continue;
            }
            if ($pageonly) $page = noNS($page);
            /*
             * This is the actual "search" expression!
             * Note: preg_grep cannot be used because of the pageonly option above
             *       (needs to allow for "^" syntax)
             * The @ prevents problems with invalid queries!
             */
            if (@preg_match('/' . $query . '/i', $page) == 0) {
                unset($pages[$i]);
            }
        }
        if ( ! count($pages)) return array();

        $pages = array_map('trim',$pages);

        // check ACL permissions and remove any 'start' pages if req'd
        $start = $conf['start'];
        $pos = strlen($start);
        foreach($pages as $idx => $name) {
            if ($nostart && substr($name, -$pos) == $start) {
                unset($pages[$idx]);
            } elseif(auth_quickaclcheck($pages[$idx]) < AUTH_READ) {
                unset($pages[$idx]);
            } elseif ($maxns > 0 && (substr_count($name,':') + 1) > $maxns) {
                unset($pages[$idx]);
            }
        }
        return $pages;
    }

    private function _filter_ns($pages, $ns_qry, $exclude) {
        $invert = ($exclude) ? PREG_GREP_INVERT : 0;
        foreach ($ns_qry as $ns) {
            $regexes[] = '.*' . $ns . ':.*';
        }
        if ( ! empty($regexes)) {
            $regex = '/(' . implode('|', $regexes) . ')/';
            return array_values(preg_grep($regex, $pages, $invert));
        } else {
            return $pages;
        }
    }
}
?>
blob
mark :90
data 496
base    pagequery
author  Symon Bent
email   hendrybadao@gmail.com
date    2011-04-14
name    PageQuery Plugin
desc    Search for (fulltext) and list wiki pages, sorted and optionally grouped by name, date, creator, abc, etc. in columns. Insert the pagequery markup wherever you want your list to appear.  E.g.{{pagequery>[query;fulltext;sort=key:direction,key2:direction;group;limit=??;cols=?;inwords;proper]}} [..] = optional
url     http://wiki.splitbrain.org/plugin:pagequery
version 0.7.2
blob
mark :92
data 484
<?php
/**
 * English language file
 *
 * @license    GPL 2 (http://www.gnu.org/licenses/gpl.html)
 * @author     Symon Bent <symonbent@gmail.com>
 */

// custom language strings for the pagequery plugin
$lang['no_results']   = 'No results for the search query: ';
$lang['jump_section'] = 'Continue with the  %1$s  section at the top...'; // '%1$s' will be replaced by the relevant heading
$lang['jump_to_top']  = 'Back to top of this page list';
$lang['link_to_top']  = 'Top ';
blob
mark :93
data 34229
<?php
/**
 * PageQuery Plugin: search for and list pages, sorted/grouped by name, date, creator, etc
 *
 * @license    GPL 2 (http://www.gnu.org/licenses/gpl.html)
 * @author	   Symon Bent <hendrybadao@gmail.com>
 */

// must be run within Dokuwiki
if(!defined('DOKU_INC')) die();

if (!defined('DOKU_LF')) define('DOKU_LF', "\n");
if (!defined('DOKU_TAB')) define('DOKU_TAB', "\t");
if (!defined('DOKU_PLUGIN')) define('DOKU_PLUGIN',DOKU_INC.'lib/plugins/');

require_once(DOKU_PLUGIN . 'syntax.php');
require_once(DOKU_INC . 'inc/fulltext.php');
require_once(DOKU_PLUGIN . 'pagequery/inc/msort.php');

define ('ID_KEY', 0);
define ('NAME_KEY', 1);
define ('ABST_KEY', 2);
define ('START_KEY', 3);
define ('MAX_COLS', 6);

class syntax_plugin_pagequery extends DokuWiki_Syntax_Plugin {

	function getType() {
		return 'substition';
	}

	function getPType() {
		return 'block';
	}

	function getSort() {
		return 98;
	}

	function connectTo($mode) {
		$this->Lexer->addSpecialPattern('\{\{pagequery>.*?\}\}', $mode, 'plugin_pagequery');
	}

    /**
     * Parses all the pagequery options:
     * Insert the pagequery markup wherever you want your list to appear. E.g:
     *
     *   {{pagequery>}}
     *
     *   {{pagequery>[query];fulltext;sort=key:direction,key2:direction;group;limit=??;cols=?;inwords;proper}}
     *
     * Parameters as follows:
     * 1. query:    any expression directly after the >; can use all Dokuwiki search options (see manual)
     * 2. fulltext: use a full-text search, instead of page_id only [default]
     * 3. sort:     keys to sort by, in order of sorting. Each key can be followed by prefered sorting order
     *              available keys:
     *                  a, ab, abc          by 1st letter, 2 letters, or 3 letters
     *                  name                by page name (no namespace) or 1st heading [not grouped]
     *                  page|id             by full page id, including namespace [not grouped]
     *                  ns                  by namespace (without page name)
     *                  mdate, cdate        by modified|created dates (full) [not grouped]
     *                  m[year][month][day] by modified [year][month][day]; any combination accepted
     *                  c[year][month][day] by created [year][month][day]; any combination accepted
     *                  creator             by page author
     *              date sort default to descending, string sorts to ascending
     * 4. group:    show group headers for each change in sort keys
     *              Note: keys with no duplicate cannot be grouped (i.e. name, page|id, mdate, cdate)
     * 5. limit:    maximum number of results to return
     * 6. inwords:  use real month and day names instead of numeric dates
     * 7. cols:     number of columns in displayed list (max = 6)
     * 8. proper:   display page names and namespace in Proper Case (i.e. no _'s and Capitalised)
     *              header/hdr = group headers only, name = page name only, both = both!
     * 9. border:   turn on borders. 'inside' = between columns; 'outside' => border around table;
     *              'both' => in and out; 'none' => neither
     *10. fullregex:only useful on page name searches; allows a raw regex mode on the full page id
     *11. nostart:  ignore any 'start' pages in namespace (based on "config:start")
     *12. maxns:    maximum namespace level to be displayed; e.g. maxns=3 => one:two:three
     *13. title:    show 1st page heading instead of page name
     *14. snippet:  should an excerpt of the wikipage be shown:
     *              use :tooltip to show as a pop-up only
     *              use :<inline|plain|quoted>, <count>, <extent> to show 1st <count> items in list with an abstract
     *                  extent always choice of chars, words, lines, or find (c? w? l? ~????)
     *15. natsort:  use natural sorting order (good for words beginning with numbers)
     *16. case:     respect case when sorting, i.e. a != A when sorting.  a-z then A-Z (opp. to PHP term, easier on average users)
     *17. underline:show a faint underline between each link for clarity
     *
     * All options are optional, and the list will default to a boring long 1-column list...
     */
	function handle($match, $state, $pos, &$handler) {

		$match = substr($match, 12, -2); // strip markup "{{pagequery>"
        de&&bug($match);
		$options = explode(';', $match);
        $query = $options[0];

        // establish some basic option defaults
        $sort = array();
        $fulltext = false;
        $group = false;
        $limit = 0;
        $maxns = 0;
        $cols = 1;
        $proper = 'none';
        $border = 'none';
        $snippet = array('none');
        $title = false;
        $fullregex = false;
        $case = false;
        $natsort = false;
        $underline = false;

        foreach ($options as $option) {
            list($key, $value) = explode('=', $option);
            switch ($key) {
                case 'fulltext':
                    $fulltext = true;
                    break;
                case 'sort':
                    $values = explode(',', $value);
                    foreach ($values as $value) {
                        list($key, $dir) = explode(':', $value);
                        $sort[] = array($key, $dir);
                    }
                    break;
                case 'group':
                    $group = true;
                    break;
                case 'limit':
                    $limit = $value;
                    break;
                case 'maxns':
                    $maxns = $value;
                    break;
                case 'inwords':
                    $inwords = true;
                    break;
                case 'proper':
                    switch ($value) {
                        case 'hdr':
                        case 'header':
                        case 'group':
                            $proper = 'header';
                            break;
                        case 'name':
                        case 'page':
                            $proper = 'name';
                            break;
                        default:
                            $proper = 'both';
                    }
                    break;
                case 'cols':
                    $cols = ($value > MAX_COLS) ? MAX_COLS : $value;
                    break;
                case 'border':
                    switch ($value) {
                        case 'none':
                        case 'inside':
                        case 'outside':
                        case 'both':
                            $border = $value;
                            break;
                        default:
                            $border = 'both';
                    }
                    break;
				case 'fullregex':
					$fullregex = true;
					break;
                case 'nostart':
                    $nostart = true;
                    break;
                case 'title':
                    $title = true;
                    break;
                case 'abstract':    // old syntax, to be deprecated (2011-03-15)
                case 'snippet':
                    $opts = explode(',', $value);
                    $type = ( ! empty($opts[0])) ? $opts[0] : 'tooltip';
                    $valid = array('none', 'tooltip', 'inline', 'plain', 'quoted');
                    if ( ! in_array($type, $valid)) $type = 'tooltip';  // always valid!
                    $count = ( ! empty($opts[1])) ? $opts[1] : 0;
                    $extent = ( ! empty($opts[2])) ? $opts[2] : '';
                    $snippet = array($type, $count, $extent);
                    break;
                case 'case':
                    $case = true;
                    break;
                case 'natsort':
                    $natsort = true;
                    break;
                case 'underline':
                    $underline = true;
                    break;
            }
        }
		return array($query, $fulltext, $sort, $group, $limit, $maxns, $proper,
                      $cols, $inwords, $border, $fullregex, $nostart, $title,
                      $snippet, $case, $natsort, $underline);
	}

    function render($mode, &$renderer, $data) {
        $sortkeys = array();
        $incl_ns = array();
        $excl_ns = array();

        list($query, $fulltext, $sort, $group, $limit, $maxns, $proper,
              $cols, $inwords, $border, $fullregex, $nostart, $title,
              $snippet, $case, $natsort, $underline) = $data;

        if ($mode == 'xhtml') {
            // first get a raw list of matching results

            if ($fulltext) {
                // full text (Dokuwiki style) searching
                $results = array_keys(ft_pageSearch($query, $highlight));
            } else {
                // by page id only (
                if ($fullregex) {
                    // allow for raw regex mode, for power users, this searches the full page id
                    $pageonly = false;
                } else {
                    list($query, $incl_ns, $excl_ns) = $this->_parse_ns_query($query);
                    $pageonly = true;
                }
                if ($query == '*') $query = '.*';   // a lazy man's option!
                $results = $this->_page_lookup($query, $pageonly, $incl_ns, $excl_ns, $nostart, $maxns);
            }

            if ( ! empty($results)) {
                // this section is where the essential pagequery functionality happens...

                // prepare the necessary sorting arrays, as per users options
                $get_abstract = ($snippet[0] != 'none');
                list($sort_array, $sort_opts, $group_opts) =
                    $this->_build_sorting_array($results, $sort, $title, $proper, $inwords, $case, $natsort, $get_abstract);

                // now do the sorting (inc/msort.php)
                msort($sort_array, $sort_opts);
                // limit the result list length if required; this can only be done after sorting!
                $sort_array = ($limit > 0) ? array_slice($sort_array, 0, $limit) : $sort_array;

                // and finally the grouping
                if ($group) {
                    $keys = array(NAME_KEY, ID_KEY, ABST_KEY);
                    $sorted_results = mgroup($sort_array, $keys, $group_opts);
                } else {
                    foreach ($sort_array as $row) {
                        $sorted_results[] = array(0, $row[NAME_KEY], $row[ID_KEY], $row[ABST_KEY]);
                    }
                }
                $renderer->doc .= $this->_render_list($sorted_results, $cols, $proper, $snippet, $border, $underline);
            } else {
                $renderer->doc .= $this->_render_no_list($query);
            }
            return true;
        } else {
            return false;
        }
    }

    private function _adjusted_height($sorted_results, $ratios) {
        // ratio of different heading heights (%), to ensure more even use of columns (h1 -> h6)
        foreach ($sorted_results as $row) {
            $adjusted_height += $ratios[$row[0]];
        }
        return $adjusted_height;
    }

    /**
     * Render a simple "no results" message
     *
     * @param string $query => original query
     * @return string
     */
    private function _render_no_list($query) {
        $render = '<div id="pagequery" class="noborder">' . DOKU_LF;
        $render .= '<p class="noresults"><span>pagequery</span>' . $this->getLang("no_results") .
                                  '&nbsp; <strong>' . $query . '</strong></p>' . DOKU_LF;
        $render .= '</div>' . DOKU_LF;
        return $render;
    }
    /**
     * Render the final pagequery results list as HTML, indented and in columns as required
     *
     * @param array  $sorted_results
     * @param int    $cols
     * @param bool   $proper
     * @param string $snippet
     * @param string $border
     * @return string => HTML rendered list
     */
    private function _render_list($sorted_results, $cols, $proper, $snippet, $border, $underline) {
        $ratios = array(.80, 1.3, 1.17, 1.1, 1.03, .96, .90);   // height ratios: link, h1, h2, h3, h4, h5, h6
        $render = '';
        $prev_was_heading = false;
        $can_start_col = true;
        $cont_level = 1;
        $col = 0;
        $col_height = $this->_adjusted_height($sorted_results, $ratios) / $cols;
        $cur_height = 0;
        $width = floor(100 / $cols);
        $snippet_cnt = 0;    // needed by the snippet section for tracking
        $jump_txt= $this->getLang('jump_section');
        $is_first = true;

        // basic result page markup (always needed)
        $outer_border = ($border == 'outside' || $border == 'both') ? '' : ' noborder';
        $no_table = ($cols == 1) ? ' notable' : '';
        $top_id = 'top-' . mt_rand();   // fixed anchor point to jump back to at top of the table
        $render .= '<div class="pagequery' . $outer_border . $no_table . '" id="' . $top_id . '">' . DOKU_LF;
        if ($cols > 1) $render .= '<table><tbody><tr>' . DOKU_LF;

        $inner_border = ($border == 'inside' || $border == 'both') ? '' : ' class="noborder" ';

        // now render the pagequery list
        foreach ($sorted_results as $line) {
            list($level, $name, $id, $abstract) = $line;
            $is_heading = ($level > 0);

            // is it time to start a new column?
            if ($can_start_col === false && $col < $cols && $cur_height >= $col_height) {
                $can_start_col = true;
                $col++;
            }

            // how should headings be displayed?
            if ($is_heading) {
                $heading = $name;
                if ($proper == 'header' || $proper == 'both') $heading = $this->_proper($heading);
            }

            // no need for indent if there is no grouping
            if ($group === false) {
                $indent_style = ' class="nogroup"';
            } else {
                $indent = ($is_heading) ? $level - 1 : $cont_level - 1;
                $indent_style = ' style="margin-left:' . $indent * 10 . 'px"';
            }

            // Begin new column if: 1) we are at the start, 2) last item was not a heading or 3) if there is no grouping
            if ($can_start_col && ! $prev_was_heading) {
                $jump_tip = sprintf($jump_txt, $heading);
                // close the previous column if necessary; also adds a 'jump to anchor'
                $col_close = ( ! $is_heading) ? '<a title="'. $jump_tip . '" href="#' .
                                $top_id . '">' . "<h$cont_level>... </h$cont_level></a>" : '';
                $col_close = ( ! $is_first) ? $col_close . '</ul></td>' . DOKU_LF : '';
                $col_open = ( ! $is_first && ! $is_heading) ? "<h$cont_level$indent_style>" . "$heading...</h$cont_level>" : '';
                $td = ($cols > 1) ? '<td' . $inner_border . ' valign="top" width="' . $width . '%">' : '';
                $render .= $col_close . $td . $col_open . DOKU_LF;
                $can_start_col = false;
                $prev_was_heading = true;    // needed to correctly style page link lists <ul>...
                $cur_height = 0;
            }
            // finally display the appropriate heading or page link(s)
            if ($is_heading) {
                // close previous sub list if necessary
                if ( ! $prev_was_heading) {
                    $render .= '</ul>' . DOKU_LF;
                }
                $render .= "<h$level$indent_style>$heading</h$level>" . DOKU_LF;
                $prev_was_heading = true;
                $cont_level = $level + 1;
            } else {
                // open a new sub list if necessary
                if ($prev_was_heading || $is_first) {
                    $render .= "<ul$indent_style>";
                }
                // deal with normal page links
                $link = $this->_html_wikilink($id, $name, $snippet, $snippet_cnt, $abstract, $underline);
                $snippet_cnt++;
                $render .= $link;
                $prev_was_heading = false;
            }
            $cur_height += $ratios[$level];
            $is_first = false;
        }
        $render .= '</ul>' . DOKU_LF;
        if ($cols > 1) $render .= '</td></tr></tbody></table>' . DOKU_LF;
        $render .= '<a class="top" href="#' . $top_id . '">' . $this->getLang('link_to_top') . '</a>' . DOKU_LF;
        $render .= '</div>' . DOKU_LF;

        return $render;
    }

    /**
     * Renders the page link, plus tooltip, abstract, casing, etc...
     * @param string $id
     * @param bool  $proper
     * @param bool  $title
     * @param mixed $snippet
     * @param int   $snipet_cnt
     * @param bool  $underline
     */
    private function _html_wikilink($id, $name, $snippet_opt, $snippet_cnt, $abstract, $underline) {

        $id = (strpos($id, ':') === false) ? ':' . $id : $id;   // : needed for root pages (root level)

        list($type, $max, $extent) = $snippet_opt;
        $after= '';
        $inline = '';

        if ($type == 'none') {
            // Plain old wikilink
            $link = html_wikilink($id, $name);
        } else {
            $short = $this->_shorten($abstract, $extent);   // shorten BEFORE replacing html entities!
            $short = htmlentities($short, ENT_QUOTES, 'UTF-8');
            $abstract = htmlentities($abstract, ENT_QUOTES, 'UTF-8');
            $link = html_wikilink($id, $name);
            $no_snippet = ($max > 0 && $snippet_cnt >= $max);
            if ($type == 'tooltip' || $no_snippet) {
                $link = $this->_add_tooltip($link, $abstract);
            } elseif ($type == 'quoted' || $type == 'plain') {
                $more = html_wikilink($id, 'more');
                $after = trim($short);
                $after= str_replace("\n\n", "\n", $after);
                $after= str_replace("\n", '<br/>', $after);
                $after= '<div class="' . $type . '">' . $after . $more . '</div>' . DOKU_LF;
            } elseif ($type == 'inline') {
                $inline .= '<span>' . $short . '</span>';
            }
        }
        $noborder = ($underline) ? '' : ' class="noborder"';
        return "<li$noborder>" . $link . $inline . '</li>' . DOKU_LF . $after;
    }

    /**
     * Swap normal link title (popup) for a more useful preview
     *
     * @param string $id    page id
     * @param string $name  display name
     * @return complete href link
     */
    private function _add_tooltip($link, $tooltip) {
        $tooltip = str_replace("\n", '  ', $tooltip);
        $link = preg_replace('/title=\".+?\"/', 'title="' . $tooltip . '"', $link, 1);
        return $link;
    }

    /**
     * return the first part of the $text according to the $amount given
     * @param type $text
     * @param type $amount  c? = ? chars, w? = ? words, l? = ? lines, ~? = search up to text/char/symbol
     */
    private function _shorten($text, $extent, $more = '... ') {
        $elem = $extent[0];
        $cnt = substr($extent, 1);
        switch ($elem) {
            case 'c':
                $result = substr($text, 0, $cnt);
                if ($cnt > 0 && strlen($result) < strlen($text)) $result .= $more;
                break;
            case 'w':
                $words = str_word_count($text, 1, '.');
                $result = implode(' ', array_slice($words, 0, $cnt));
                if ($cnt > 0 && $cnt <= count($words) && $words[$cnt - 1] != '.') $result .= $more;
                break;
            case 'l':
                $lines = explode("\n", $text);
                $lines = array_filter($lines);  // remove blank lines
                $result = implode("\n", array_slice($lines, 0, $cnt));
                if ($cnt > 0 && $cnt < count($lines)) $result .= $more;
                break;
            case "~":
                $result = strstr($text, $cnt, true);
                break;
            default:
                $result = $text;
        }
        return $result;
    }

    /**
     * Changes a wiki page id into proper case (allowing for :'s etc...)
     * @param string    $id    page id
     * @return string
     */
    private function _proper($id) {
         $id = str_replace(':', ': ', $id); // make a little whitespace before words so ucwords can work!
         $id = str_replace('_', ' ', $id);
         $id = ucwords($id);
         $id = str_replace(': ', ':', $id);
         return $id;
    }

    /**
     * Parse out the namespace, and convert to a regex for array search
     *
     * @param  string $query user page query
     * @return string        processed query with necessary regex markup for namespace recognition
     */
    private function _parse_ns_query($query) {
        global $INFO;

        $cur_ns = $INFO['namespace'];
        $incl_ns = array();
        $excl_ns = array();
        $page_qry = '';
        $tokens = explode(' ', $query);
        if (count($tokens) == 1) {
            $page_qry = $query;
        } else {
            foreach ($tokens as $token) {
                if (preg_match('/^(?:\^|-ns:)(.+)$/u', $token, $matches)) {
                    $excl_ns[] = resolve_id($cur_ns, $matches[1]);  // also resolve relative and parent ns
                } elseif (preg_match('/^(?:@|ns:)(.+)$/u', $token, $matches)) {
                    $incl_ns[] = resolve_id($cur_ns, $matches[1]);
                } else {
                    $page_qry .= ' ' . $token;
                }
            }
        }
        $page_qry = trim($page_qry);
        return array($page_qry, $incl_ns, $excl_ns);
    }

    /**
     * Builds the sorting array: array of arrays (0 = id, 1 = name, 2 = abstract, 3 = ... , etc)
     *
     * @param array     $ids        array of page ids to be sorted
     * @param array     $sortkeys   list of array keys to sort by
     * @param bool      $title      use page heading instead of name for sorting
     * @param bool      $proper     use proper case where possible
     * @param bool      $inwords    show dates in words where possible
     * @param bool      $case       honour case when sorting
     * @param bool      $natsort    natural sorting, the human way
     *
     * @return array    $sort_array array of array(one value for each key to be sorted)
     *                   $sort_opts  sorting options for the msort function
     *                   $group_opts grouping options for the mgroup function
     */
    private function _build_sorting_array($ids, $sortkeys, $title, $proper, $inwords, $case, $natsort, $get_abstract) {
        global $conf;

        $sort_opts = array();
        $group_opts = array();
        $abstracts = array();

        $dformat = array();
        $wformat = array();

        $row = 0;
        $end_col = START_KEY + count($sortkeys);

        foreach ($ids as $id) {
            // getting metadata is time-consuming, hence ONCE per displayed row
            $meta = p_get_metadata ($id, false, true);

            if ( ! isset($meta['date']['modified'])) {
                $meta['date']['modified'] = $meta['date']['created'];
            }
            // use page heading instead of page name
            if ($title && isset($meta['title'])) {
                $name = $meta['title'];
            } else {
                $name = noNS($id);
            }
            if ($proper == 'name' || $proper == 'both') {
                $name = $this->_proper($name);
            }
            // first column is the basic page id
            $sort_array[$row][ID_KEY] = $id;
            // second column is the display 'name' (used when sorting by 'name')
            // this also avoids rebuilding the display name when building links later (DRY)
            $sort_array[$row][NAME_KEY] = $name;
            // third column: cache the page abstract if needed; this saves a lot of time later
            // and avoids repeated slow metadata retrievals (v. slow!)
            $sort_array[$row][ABST_KEY] = ($get_abstract) ? $meta['description']['abstract'] : '';

            $col = START_KEY;

            foreach ($sortkeys as $sortkey) {
                $key = $sortkey[0];
                switch ($key) {
                    case 'a':
                        $value = $this->_first($name, 1);
                        break;
                    case 'ab':
                        $value = $this->_first($name, 2);
                        break;
                    case 'abc':
                        $value = $this->_first($name, 3);
                        break;
                    case 'name':
                        // a name column already exists by default (col 1)
                        continue;
                    case 'id':
                    case 'page':
                        $value = $id;
                        break;
                    case 'ns':
                        $value = getNS($id);
                        if (empty($value)) $value = '[' . $conf['start'] . ']';
                        break;
                    case 'creator':
                        $value = $meta['creator'];
                        break;
                    case 'mdate':
                        $value = $meta['date']['modified'];
                        break;
                    case 'cdate':
                        $value = $meta['date']['created'];
                        break;
                    default:
                        // date sorting types (groupable)
                        $dtype = $key[0];
                        if ($dtype == 'c' || $dtype == 'm') {
                            // we only set real date once per id (needed for grouping)
                            // not per sort column--the date should remain same across all columns
                            // this is always the last column!
                            if ($col == START_KEY) {
                                if ($dtype == 'c') {
                                    $date = $meta['date']['created'];
                                } else {
                                    $date = $meta['date']['modified'];
                                }
                                $sort_array[$row][$end_col] = $date;
                            } else {
                                $date = $sort_array[$row][$end_col] ;
                            }
                            // only set date formats once per sort column/key (not per id!)
                            if ($row == 0) {
                                $dformat[$col] = $this->_date_format($key);
                                // collect date in word format for potential use in grouping
                                if ($inwords) {
                                    $wformat[$col] = $this->_date_format_words($dformat[$col]);
                                } else {
                                    $wformat[$col] = '';
                                }
                            }
                            // create a string date used for sorting only
                            // (we cannot just use the real date otherwise it would not group correctly)
                            $value = strftime($dformat[$col], $date);
                        }
                }
                $sort_array[$row][$col] = $value;
                $col++;
            }
            $row++;
        }

        $cnt = START_KEY;
        $order = 0;
        foreach ($sortkeys as $sortkey) {
            list($key, $opt) = $sortkey;

            if ($key == 'name') {
                $col = NAME_KEY;
                // this col number will be re-used next time through
            } else {
                $col = $cnt;
                $cnt++;
            }
            $sort_opts['key'][] = $col;

            // now the sort direction
            switch ($opt) {
                case 'a':
                case 'asc':
                    $dir = MSORT_ASC;
                    break;
                case 'd':
                case 'desc':
                    $dir = MSORT_DESC;
                    break;
                default:
                    // sort descending by default; text ascending
                    // watch for other sort options beginning with c or m ....!
                    if ($key[0] == 'c' || $key[0] == 'm') {
                        $dir = MSORT_DESC;
                    } else {
                        $dir = MSORT_ASC;
                    }
            }
            $sort_opts['dir'][] = $dir;

            // set the sort array's data type
            $is_ns = false;
            switch ($key) {
                case 'mdate':
                case 'cdate':
                    $type = MSORT_NUMERIC;
                    break;
                default:
                    if ($case) {
                        // case sensitive: a-z then A-Z
                        $type = ($natsort) ? MSORT_NAT : MSORT_STRING;
                    } else {
                        // case-insensitive
                        $type = ($natsort) ? MSORT_NAT_CASE : MSORT_STRING_CASE;
                    }
            }
            $sort_opts['type'][] = $type;

            // now establish grouping options
            switch ($key) {
                // name strings and full dates cannot be meaningfully grouped (no duplicates!)
                case 'mdate':
                case 'cdate':
                case 'name':
                case 'id':
                case 'page':
                    $group_by = MGROUP_NONE;
                    break;
                case 'ns':
                    $group_by = MGROUP_NAMESPACE;
                    break;
                default:
                    $group_by = MGROUP_HEADING;
            }
            if ($group_by != MGROUP_NONE) {
                $group_opts['key'][$order] = $col;
                $group_opts['type'][$order] = $group_by;
                $group_opts['dformat'][$order] = $wformat[$col];
                $order++;
            }
        }
        return array($sort_array, $sort_opts, $group_opts, $abstracts);
    }

    // returns first $count letters from $text
    private function _first($text, $count) {
        if ($count > 0) {
            return utf8_substr($text, 0, $count);
        }
    }

    /**
     * Parse the c|m-year-month-day option; used for sorting/grouping
     *
     * @param string  $key
     * @return string
     */
    private function _date_format($key) {
        if (strpos($key, 'year') !== false) $dkey[] = '%Y';
        if (strpos($key, 'month') !== false) $dkey[] = '%m';
        if (strpos($key, 'day') !== false) $dkey[] = '%d';
        $dformat = implode('-', $dkey);
        return $dformat;
    }

    /**
     * Provide month and day format in real words if required
     * used for display only ($dformat is used for sorting/grouping)
     *
     * @param string $dformat
     * @return string
     */
    private function _date_format_words($dformat) {
        $wformat = '';
        switch ($dformat) {
            case '%m':
                $wformat = "%B";
                break;
            case '%d':
                $wformat = "%#d%A ";
                break;
            case '%Y-%m':
                $wformat = "%B %Y";
                break;
            case '%m-%d':
                $wformat= "%B %#d, %A ";
                break;
            case '%Y-%m-%d':
                $wformat = "%A, %B %#d, %Y";
                break;
        }
        return $wformat;
    }

    /**
     * A heavily customised version of _ft_pageLookup in inc/fulltext.php
     * no sorting!
     */
    private function _page_lookup($query, $pageonly, $incl_ns, $excl_ns, $nostart = true, $maxns = 0) {
        global $conf;

        $queries = trim($query);
        $pages = file($conf['indexdir'] . '/page.idx');

        // first deal with excluded namespaces, then included
        $pages = $this->_filter_ns($pages, $excl_ns, true);

        // now include ONLY the selected namespaces if provided
        $pages = $this->_filter_ns($pages, $incl_ns, false);

        $cnt = count($pages);
        for ($i = 0; $i < $cnt; $i++) {
            $page = $pages[$i];
            if ( ! page_exists($page) || isHiddenPage($page)) {
                unset($pages[$i]);
                continue;
            }
            if ($pageonly) $page = noNS($page);
            /*
             * This is the actual "search" expression!
             * Note: preg_grep cannot be used because of the pageonly option above
             *       (needs to allow for "^" syntax)
             * The @ prevents problems with invalid queries!
             */
            if (@preg_match('/' . $query . '/i', $page) == 0) {
                unset($pages[$i]);
            }
        }
        if ( ! count($pages)) return array();

        $pages = array_map('trim',$pages);

        // check ACL permissions and remove any 'start' pages if req'd
        $start = $conf['start'];
        $pos = strlen($start);
        foreach($pages as $idx => $name) {
            if ($nostart && substr($name, -$pos) == $start) {
                unset($pages[$idx]);
            // TODO: this function is one of slowest in the plugin; solutions?
            } elseif(auth_quickaclcheck($pages[$idx]) < AUTH_READ) {
                unset($pages[$idx]);
            } elseif ($maxns > 0 && (substr_count($name,':') + 1) > $maxns) {
                unset($pages[$idx]);
            }
        }
        return $pages;
    }
    /**
     * Include/Exclude specific namespaces from a list of pages
     * @param type $pages   a list of wiki page ids
     * @param type $ns_qry  namespace(s) to include/exclude
     * @param type $exclude true = exclude
     * @return array
     */
    private function _filter_ns($pages, $ns_qry, $exclude) {
        $invert = ($exclude) ? PREG_GREP_INVERT : 0;
        foreach ($ns_qry as $ns) {
            $regexes[] = '.*' . $ns . ':.*';
        }
        if ( ! empty($regexes)) {
            $regex = '/(' . implode('|', $regexes) . ')/';
            return array_values(preg_grep($regex, $pages, $invert));
        } else {
            return $pages;
        }
    }
}
?>
blob
mark :95
data 35049
<?php
/**
 * PageQuery Plugin: search for and list pages, sorted/grouped by name, date, creator, etc
 *
 * @license    GPL 2 (http://www.gnu.org/licenses/gpl.html)
 * @author	   Symon Bent <hendrybadao@gmail.com>
 */

// must be run within Dokuwiki
if(!defined('DOKU_INC')) die();

if (!defined('DOKU_LF')) define('DOKU_LF', "\n");
if (!defined('DOKU_TAB')) define('DOKU_TAB', "\t");
if (!defined('DOKU_PLUGIN')) define('DOKU_PLUGIN',DOKU_INC.'lib/plugins/');

require_once(DOKU_PLUGIN . 'syntax.php');
require_once(DOKU_INC . 'inc/fulltext.php');
require_once(DOKU_PLUGIN . 'pagequery/inc/msort.php');

define ('ID_KEY', 0);
define ('NAME_KEY', 1);
define ('ABST_KEY', 2);
define ('START_KEY', 3);
define ('MAX_COLS', 6);

class syntax_plugin_pagequery extends DokuWiki_Syntax_Plugin {

	function getType() {
		return 'substition';
	}

	function getPType() {
		return 'block';
	}

	function getSort() {
		return 98;
	}

	function connectTo($mode) {
		$this->Lexer->addSpecialPattern('\{\{pagequery>.*?\}\}', $mode, 'plugin_pagequery');
	}

    /**
     * Parses all the pagequery options:
     * Insert the pagequery markup wherever you want your list to appear. E.g:
     *
     *   {{pagequery>}}
     *
     *   {{pagequery>[query];fulltext;sort=key:direction,key2:direction;group;limit=??;cols=?;inwords;proper}}
     *
     * Parameters as follows:
     * 1. query:    any expression directly after the >; can use all Dokuwiki search options (see manual)
     * 2. fulltext: use a full-text search, instead of page_id only [default]
     * 3. sort:     keys to sort by, in order of sorting. Each key can be followed by prefered sorting order
     *              available keys:
     *                  a, ab, abc          by 1st letter, 2 letters, or 3 letters
     *                  name                by page name (no namespace) or 1st heading [not grouped]
     *                  page|id             by full page id, including namespace [not grouped]
     *                  ns                  by namespace (without page name)
     *                  mdate, cdate        by modified|created dates (full) [not grouped]
     *                  m[year][month][day] by modified [year][month][day]; any combination accepted
     *                  c[year][month][day] by created [year][month][day]; any combination accepted
     *                  creator             by page author
     *              date sort default to descending, string sorts to ascending
     * 4. group:    show group headers for each change in sort keys
     *              Note: keys with no duplicate cannot be grouped (i.e. name, page|id, mdate, cdate)
     * 5. limit:    maximum number of results to return
     * 6. inwords:  use real month and day names instead of numeric dates
     * 7. cols:     number of columns in displayed list (max = 6)
     * 8. proper:   display page names and namespace in Proper Case (i.e. no _'s and Capitalised)
     *              header/hdr = group headers only, name = page name only, both = both!
     * 9. border:   turn on borders. 'inside' = between columns; 'outside' => border around table;
     *              'both' => in and out; 'none' => neither
     *10. fullregex:only useful on page name searches; allows a raw regex mode on the full page id
     *11. nostart:  ignore any 'start' pages in namespace (based on "config:start")
     *12. maxns:    maximum namespace level to be displayed; e.g. maxns=3 => one:two:three
     *13. title:    show 1st page heading instead of page name
     *14. snippet:  should an excerpt of the wikipage be shown:
     *              use :tooltip to show as a pop-up only
     *              use :<inline|plain|quoted>, <count>, <extent> to show 1st <count> items in list with an abstract
     *                  extent always choice of chars, words, lines, or find (c? w? l? ~????)
     *15. natsort:  use natural sorting order (good for words beginning with numbers)
     *16. case:     respect case when sorting, i.e. a != A when sorting.  a-z then A-Z (opp. to PHP term, easier on average users)
     *17. underline:show a faint underline between each link for clarity
     *
     * All options are optional, and the list will default to a boring long 1-column list...
     */
	function handle($match, $state, $pos, &$handler) {

		$match = substr($match, 12, -2); // strip markup "{{pagequery>"
		$options = explode(';', $match);
        $query = $options[0];

        // establish some basic option defaults
        $sort = array();
        $fulltext = false;
        $group = false;
        $limit = 0;
        $maxns = 0;
        $cols = 1;
        $proper = 'none';
        $border = 'none';
        $snippet = array('none');
        $title = false;
        $fullregex = false;
        $case = false;
        $natsort = false;
        $underline = false;

        foreach ($options as $option) {
            list($key, $value) = explode('=', $option);
            switch ($key) {
                case 'fulltext':
                    $fulltext = true;
                    break;
                case 'sort':
                    $values = explode(',', $value);
                    foreach ($values as $value) {
                        list($key, $dir) = explode(':', $value);
                        $sort[] = array($key, $dir);
                    }
                    break;
                case 'group':
                    $group = true;
                    break;
                case 'limit':
                    $limit = $value;
                    break;
                case 'maxns':
                    $maxns = $value;
                    break;
                case 'inwords':
                    $inwords = true;
                    break;
                case 'proper':
                    switch ($value) {
                        case 'hdr':
                        case 'header':
                        case 'group':
                            $proper = 'header';
                            break;
                        case 'name':
                        case 'page':
                            $proper = 'name';
                            break;
                        default:
                            $proper = 'both';
                    }
                    break;
                case 'cols':
                    $cols = ($value > MAX_COLS) ? MAX_COLS : $value;
                    break;
                case 'border':
                    switch ($value) {
                        case 'none':
                        case 'inside':
                        case 'outside':
                        case 'both':
                            $border = $value;
                            break;
                        default:
                            $border = 'both';
                    }
                    break;
				case 'fullregex':
					$fullregex = true;
					break;
                case 'nostart':
                    $nostart = true;
                    break;
                case 'title':
                    $title = true;
                    break;
                case 'abstract':    // old syntax, to be deprecated (2011-03-15)
                case 'snippet':
                    $opts = explode(',', $value);
                    $type = ( ! empty($opts[0])) ? $opts[0] : 'tooltip';
                    $valid = array('none', 'tooltip', 'inline', 'plain', 'quoted');
                    if ( ! in_array($type, $valid)) $type = 'tooltip';  // always valid!
                    $count = ( ! empty($opts[1])) ? $opts[1] : 0;
                    $extent = ( ! empty($opts[2])) ? $opts[2] : '';
                    $snippet = array($type, $count, $extent);
                    break;
                case 'case':
                    $case = true;
                    break;
                case 'natsort':
                    $natsort = true;
                    break;
                case 'underline':
                    $underline = true;
                    break;
            }
        }
		return array($query, $fulltext, $sort, $group, $limit, $maxns, $proper,
                      $cols, $inwords, $border, $fullregex, $nostart, $title,
                      $snippet, $case, $natsort, $underline);
	}

    function render($mode, &$renderer, $data) {
        $sortkeys = array();
        $incl_ns = array();
        $excl_ns = array();

        list($query, $fulltext, $sort, $group, $limit, $maxns, $proper,
              $cols, $inwords, $border, $fullregex, $nostart, $title,
              $snippet, $case, $natsort, $underline) = $data;

        if ($mode == 'xhtml') {
            // first get a raw list of matching results

            if ($fulltext) {
                // full text (Dokuwiki style) searching
                $results = array_keys(ft_pageSearch($query, $highlight));
            } else {
                // by page id only (
                if ($fullregex) {
                    // allow for raw regex mode, for power users, this searches the full page id
                    $pageonly = false;
                } else {
                    list($query, $incl_ns, $excl_ns) = $this->_parse_ns_query($query);
                    $pageonly = true;
                }
                if ($query == '*') $query = '.*';   // a lazy man's option!
                $results = $this->_page_lookup($query, $pageonly, $incl_ns, $excl_ns, $nostart, $maxns);
            }

            if ( ! empty($results)) {
                // this section is where the essential pagequery functionality happens...

                // prepare the necessary sorting arrays, as per users options
                $get_abstract = ($snippet[0] != 'none');
                list($sort_array, $sort_opts, $group_opts) =
                    $this->_build_sorting_array($results, $sort, $title, $proper, $inwords, $case, $natsort, $get_abstract);

                // now do the sorting (inc/msort.php)
                msort($sort_array, $sort_opts);
                // limit the result list length if required; this can only be done after sorting!
                $sort_array = ($limit > 0) ? array_slice($sort_array, 0, $limit) : $sort_array;

                // and finally the grouping
                if ($group) {
                    $keys = array(NAME_KEY, ID_KEY, ABST_KEY);
                    $sorted_results = mgroup($sort_array, $keys, $group_opts);
                } else {
                    foreach ($sort_array as $row) {
                        $sorted_results[] = array(0, $row[NAME_KEY], $row[ID_KEY], $row[ABST_KEY]);
                    }
                }
                $renderer->doc .= $this->_render_list($sorted_results, $cols, $proper, $snippet, $border, $underline);
            } else {
                $renderer->doc .= $this->_render_no_list($query);
            }
            return true;
        } else {
            return false;
        }
    }

    private function _adjusted_height($sorted_results, $ratios) {
        // ratio of different heading heights (%), to ensure more even use of columns (h1 -> h6)
        foreach ($sorted_results as $row) {
            $adjusted_height += $ratios[$row[0]];
        }
        return $adjusted_height;
    }

    /**
     * Render a simple "no results" message
     *
     * @param string $query => original query
     * @return string
     */
    private function _render_no_list($query) {
        $render = '<div id="pagequery" class="noborder">' . DOKU_LF;
        $render .= '<p class="noresults"><span>pagequery</span>' . $this->getLang("no_results") .
                                  '&nbsp; <strong>' . $query . '</strong></p>' . DOKU_LF;
        $render .= '</div>' . DOKU_LF;
        return $render;
    }
    /**
     * Render the final pagequery results list as HTML, indented and in columns as required
     *
     * @param array  $sorted_results
     * @param int    $cols
     * @param bool   $proper
     * @param string $snippet
     * @param string $border
     * @return string => HTML rendered list
     */
    private function _render_list($sorted_results, $cols, $proper, $snippet, $border, $underline) {
        $ratios = array(.80, 1.3, 1.17, 1.1, 1.03, .96, .90);   // height ratios: link, h1, h2, h3, h4, h5, h6
        $render = '';
        $prev_was_heading = false;
        $can_start_col = true;
        $cont_level = 1;
        $col = 0;
        $col_height = $this->_adjusted_height($sorted_results, $ratios) / $cols;
        $cur_height = 0;
        $width = floor(100 / $cols);
        $snippet_cnt = 0;    // needed by the snippet section for tracking
        $jump_txt= $this->getLang('jump_section');
        $is_first = true;

        // basic result page markup (always needed)
        $outer_border = ($border == 'outside' || $border == 'both') ? '' : ' noborder';
        $no_table = ($cols == 1) ? ' notable' : '';
        $top_id = 'top-' . mt_rand();   // fixed anchor point to jump back to at top of the table
        $render .= '<div class="pagequery' . $outer_border . $no_table . '" id="' . $top_id . '">' . DOKU_LF;
        if ($cols > 1) $render .= '<table><tbody><tr>' . DOKU_LF;

        $inner_border = ($border == 'inside' || $border == 'both') ? '' : ' class="noborder" ';

        // now render the pagequery list
        foreach ($sorted_results as $line) {
            list($level, $name, $id, $abstract) = $line;
            $is_heading = ($level > 0);

            // is it time to start a new column?
            if ($can_start_col === false && $col < $cols && $cur_height >= $col_height) {
                $can_start_col = true;
                $col++;
            }

            // how should headings be displayed?
            if ($is_heading) {
                $heading = $name;
                if ($proper == 'header' || $proper == 'both') $heading = $this->_proper($heading);
            }

            // no need for indent if there is no grouping
            if ($group === false) {
                $indent_style = ' class="nogroup"';
            } else {
                $indent = ($is_heading) ? $level - 1 : $cont_level - 1;
                $indent_style = ' style="margin-left:' . $indent * 10 . 'px"';
            }

            // Begin new column if: 1) we are at the start, 2) last item was not a heading or 3) if there is no grouping
            if ($can_start_col && ! $prev_was_heading) {
                $jump_tip = sprintf($jump_txt, $heading);
                // close the previous column if necessary; also adds a 'jump to anchor'
                $col_close = ( ! $is_heading) ? '<a title="'. $jump_tip . '" href="#' .
                                $top_id . '">' . "<h$cont_level>... </h$cont_level></a>" : '';
                $col_close = ( ! $is_first) ? $col_close . '</ul></td>' . DOKU_LF : '';
                $col_open = ( ! $is_first && ! $is_heading) ? "<h$cont_level$indent_style>" . "$heading...</h$cont_level>" : '';
                $td = ($cols > 1) ? '<td' . $inner_border . ' valign="top" width="' . $width . '%">' : '';
                $render .= $col_close . $td . $col_open . DOKU_LF;
                $can_start_col = false;
                $prev_was_heading = true;    // needed to correctly style page link lists <ul>...
                $cur_height = 0;
            }
            // finally display the appropriate heading or page link(s)
            if ($is_heading) {
                // close previous sub list if necessary
                if ( ! $prev_was_heading) {
                    $render .= '</ul>' . DOKU_LF;
                }
                $render .= "<h$level$indent_style>$heading</h$level>" . DOKU_LF;
                $prev_was_heading = true;
                $cont_level = $level + 1;
            } else {
                // open a new sub list if necessary
                if ($prev_was_heading || $is_first) {
                    $render .= "<ul$indent_style>";
                }
                // deal with normal page links
                $link = $this->_html_wikilink($id, $name, $snippet, $snippet_cnt, $abstract, $underline);
                $snippet_cnt++;
                $render .= $link;
                $prev_was_heading = false;
            }
            $cur_height += $ratios[$level];
            $is_first = false;
        }
        $render .= '</ul>' . DOKU_LF;
        if ($cols > 1) $render .= '</td></tr></tbody></table>' . DOKU_LF;
        $render .= '<a class="top" href="#' . $top_id . '">' . $this->getLang('link_to_top') . '</a>' . DOKU_LF;
        $render .= '</div>' . DOKU_LF;

        return $render;
    }

    /**
     * Renders the page link, plus tooltip, abstract, casing, etc...
     * @param string $id
     * @param bool  $proper
     * @param bool  $title
     * @param mixed $snippet
     * @param int   $snipet_cnt
     * @param bool  $underline
     */
    private function _html_wikilink($id, $name, $snippet_opt, $snippet_cnt, $abstract, $underline) {

        $id = (strpos($id, ':') === false) ? ':' . $id : $id;   // : needed for root pages (root level)

        list($type, $max, $extent) = $snippet_opt;
        $after= '';
        $inline = '';

        if ($type == 'none') {
            // Plain old wikilink
            $link = html_wikilink($id, $name);
        } else {
            $short = $this->_shorten($abstract, $extent);   // shorten BEFORE replacing html entities!
            $short = htmlentities($short, ENT_QUOTES, 'UTF-8');
            $abstract = htmlentities($abstract, ENT_QUOTES, 'UTF-8');
            $link = html_wikilink($id, $name);
            $no_snippet = ($max > 0 && $snippet_cnt >= $max);
            if ($type == 'tooltip' || $no_snippet) {
                $link = $this->_add_tooltip($link, $abstract);
            } elseif ($type == 'quoted' || $type == 'plain') {
                $more = html_wikilink($id, 'more');
                $after = trim($short);
                $after= str_replace("\n\n", "\n", $after);
                $after= str_replace("\n", '<br/>', $after);
                $after= '<div class="' . $type . '">' . $after . $more . '</div>' . DOKU_LF;
            } elseif ($type == 'inline') {
                $inline .= '<span>' . $short . '</span>';
            }
        }
        $noborder = ($underline) ? '' : ' class="noborder"';
        return "<li$noborder>" . $link . $inline . '</li>' . DOKU_LF . $after;
    }

    /**
     * Swap normal link title (popup) for a more useful preview
     *
     * @param string $id    page id
     * @param string $name  display name
     * @return complete href link
     */
    private function _add_tooltip($link, $tooltip) {
        $tooltip = str_replace("\n", '  ', $tooltip);
        $link = preg_replace('/title=\".+?\"/', 'title="' . $tooltip . '"', $link, 1);
        return $link;
    }

    /**
     * return the first part of the $text according to the $amount given
     * @param type $text
     * @param type $amount  c? = ? chars, w? = ? words, l? = ? lines, ~? = search up to text/char/symbol
     */
    private function _shorten($text, $extent, $more = '... ') {
        $elem = $extent[0];
        $cnt = substr($extent, 1);
        switch ($elem) {
            case 'c':
                $result = substr($text, 0, $cnt);
                if ($cnt > 0 && strlen($result) < strlen($text)) $result .= $more;
                break;
            case 'w':
                $words = str_word_count($text, 1, '.');
                $result = implode(' ', array_slice($words, 0, $cnt));
                if ($cnt > 0 && $cnt <= count($words) && $words[$cnt - 1] != '.') $result .= $more;
                break;
            case 'l':
                $lines = explode("\n", $text);
                $lines = array_filter($lines);  // remove blank lines
                $result = implode("\n", array_slice($lines, 0, $cnt));
                if ($cnt > 0 && $cnt < count($lines)) $result .= $more;
                break;
            case "~":
                $result = strstr($text, $cnt, true);
                break;
            default:
                $result = $text;
        }
        return $result;
    }

    /**
     * Changes a wiki page id into proper case (allowing for :'s etc...)
     * @param string    $id    page id
     * @return string
     */
    private function _proper($id) {
         $id = str_replace(':', ': ', $id); // make a little whitespace before words so ucwords can work!
         $id = str_replace('_', ' ', $id);
         $id = ucwords($id);
         $id = str_replace(': ', ':', $id);
         return $id;
    }

    /**
     * Parse out the namespace, and convert to a regex for array search
     *
     * @param  string $query user page query
     * @return string        processed query with necessary regex markup for namespace recognition
     */
    private function _parse_ns_query($query) {
        global $INFO;

        $cur_ns = $INFO['namespace'];
        $incl_ns = array();
        $excl_ns = array();
        $page_qry = '';
        $tokens = explode(' ', $query);
        if (count($tokens) == 1) {
            $page_qry = $query;
        } else {
            foreach ($tokens as $token) {
                if (preg_match('/^(?:\^|-ns:)(.+)$/u', $token, $matches)) {
                    $excl_ns[] = resolve_id($cur_ns, $matches[1]);  // also resolve relative and parent ns
                } elseif (preg_match('/^(?:@|ns:)(.+)$/u', $token, $matches)) {
                    $incl_ns[] = resolve_id($cur_ns, $matches[1]);
                } else {
                    $page_qry .= ' ' . $token;
                }
            }
        }
        $page_qry = trim($page_qry);
        return array($page_qry, $incl_ns, $excl_ns);
    }

    /**
     * Builds the sorting array: array of arrays (0 = id, 1 = name, 2 = abstract, 3 = ... , etc)
     *
     * @param array     $ids        array of page ids to be sorted
     * @param array     $sortkeys   list of array keys to sort by
     * @param bool      $title      use page heading instead of name for sorting
     * @param bool      $proper     use proper case where possible
     * @param bool      $inwords    show dates in words where possible
     * @param bool      $case       honour case when sorting
     * @param bool      $natsort    natural sorting, the human way
     *
     * @return array    $sort_array array of array(one value for each key to be sorted)
     *                   $sort_opts  sorting options for the msort function
     *                   $group_opts grouping options for the mgroup function
     */
    private function _build_sorting_array($ids, $sortkeys, $title, $proper, $inwords, $case, $natsort, $get_abstract) {
        global $conf;

        $sort_opts = array();
        $group_opts = array();
        $abstracts = array();

        $dformat = array();
        $wformat = array();

        $row = 0;
        $end_col = START_KEY + count($sortkeys);

        foreach ($ids as $id) {
            // getting metadata is time-consuming, hence ONCE per displayed row
            $meta = p_get_metadata ($id, false, true);

            if ( ! isset($meta['date']['modified'])) {
                $meta['date']['modified'] = $meta['date']['created'];
            }
            // use page heading instead of page name
            if ($title && isset($meta['title'])) {
                $name = $meta['title'];
            } else {
                $name = noNS($id);
            }
            if ($proper == 'name' || $proper == 'both') {
                $name = $this->_proper($name);
            }
            // first column is the basic page id
            $sort_array[$row][ID_KEY] = $id;
            // second column is the display 'name' (used when sorting by 'name')
            // this also avoids rebuilding the display name when building links later (DRY)
            $sort_array[$row][NAME_KEY] = $name;
            // third column: cache the page abstract if needed; this saves a lot of time later
            // and avoids repeated slow metadata retrievals (v. slow!)
            $sort_array[$row][ABST_KEY] = ($get_abstract) ? $meta['description']['abstract'] : '';

            $col = START_KEY;

            foreach ($sortkeys as $sortkey) {
                $key = $sortkey[0];
                switch ($key) {
                    case 'a':
                        $value = $this->_first($name, 1);
                        break;
                    case 'ab':
                        $value = $this->_first($name, 2);
                        break;
                    case 'abc':
                        $value = $this->_first($name, 3);
                        break;
                    case 'name':
                        // a name column already exists by default (col 1)
                        continue;
                    case 'id':
                    case 'page':
                        $value = $id;
                        break;
                    case 'ns':
                        $value = getNS($id);
                        if (empty($value)) $value = '[' . $conf['start'] . ']';
                        break;
                    case 'creator':
                        $value = $meta['creator'];
                        break;
                    case 'mdate':
                        $value = $meta['date']['modified'];
                        break;
                    case 'cdate':
                        $value = $meta['date']['created'];
                        break;
                    default:
                        // date sorting types (groupable)
                        $dtype = $key[0];
                        if ($dtype == 'c' || $dtype == 'm') {
                            // we only set real date once per id (needed for grouping)
                            // not per sort column--the date should remain same across all columns
                            // this is always the last column!
                            if ($col == START_KEY) {
                                if ($dtype == 'c') {
                                    $date = $meta['date']['created'];
                                } else {
                                    $date = $meta['date']['modified'];
                                }
                                $sort_array[$row][$end_col] = $date;
                            } else {
                                $date = $sort_array[$row][$end_col] ;
                            }
                            // only set date formats once per sort column/key (not per id!)
                            if ($row == 0) {
                                $dformat[$col] = $this->_date_format($key);
                                // collect date in word format for potential use in grouping
                                if ($inwords) {
                                    $wformat[$col] = $this->_date_format_words($dformat[$col]);
                                } else {
                                    $wformat[$col] = '';
                                }
                            }
                            // create a string date used for sorting only
                            // (we cannot just use the real date otherwise it would not group correctly)
                            $value = strftime($dformat[$col], $date);
                        }
                }
                $sort_array[$row][$col] = $value;
                $col++;
            }
            $row++;
        }

        $cnt = START_KEY;
        $order = 0;
        foreach ($sortkeys as $sortkey) {
            list($key, $opt) = $sortkey;

            if ($key == 'name') {
                $col = NAME_KEY;
                // this col number will be re-used next time through
            } else {
                $col = $cnt;
                $cnt++;
            }
            $sort_opts['key'][] = $col;

            // now the sort direction
            switch ($opt) {
                case 'a':
                case 'asc':
                    $dir = MSORT_ASC;
                    break;
                case 'd':
                case 'desc':
                    $dir = MSORT_DESC;
                    break;
                default:
                    // sort descending by default; text ascending
                    // watch for other sort options beginning with c or m ....!
                    if ($key[0] == 'c' || $key[0] == 'm') {
                        $dir = MSORT_DESC;
                    } else {
                        $dir = MSORT_ASC;
                    }
            }
            $sort_opts['dir'][] = $dir;

            // set the sort array's data type
            $is_ns = false;
            switch ($key) {
                case 'mdate':
                case 'cdate':
                    $type = MSORT_NUMERIC;
                    break;
                default:
                    if ($case) {
                        // case sensitive: a-z then A-Z
                        $type = ($natsort) ? MSORT_NAT : MSORT_STRING;
                    } else {
                        // case-insensitive
                        $type = ($natsort) ? MSORT_NAT_CASE : MSORT_STRING_CASE;
                    }
            }
            $sort_opts['type'][] = $type;

            // now establish grouping options
            switch ($key) {
                // name strings and full dates cannot be meaningfully grouped (no duplicates!)
                case 'mdate':
                case 'cdate':
                case 'name':
                case 'id':
                case 'page':
                    $group_by = MGROUP_NONE;
                    break;
                case 'ns':
                    $group_by = MGROUP_NAMESPACE;
                    break;
                default:
                    $group_by = MGROUP_HEADING;
            }
            if ($group_by != MGROUP_NONE) {
                $group_opts['key'][$order] = $col;
                $group_opts['type'][$order] = $group_by;
                $group_opts['dformat'][$order] = $wformat[$col];
                $order++;
            }
        }
        return array($sort_array, $sort_opts, $group_opts, $abstracts);
    }

    // returns first $count letters from $text
    private function _first($text, $count) {
        if ($count > 0) {
            return utf8_substr($text, 0, $count);
        }
    }

    /**
     * Parse the c|m-year-month-day option; used for sorting/grouping
     *
     * @param string  $key
     * @return string
     */
    private function _date_format($key) {
        if (strpos($key, 'year') !== false) $dkey[] = '%Y';
        if (strpos($key, 'month') !== false) $dkey[] = '%m';
        if (strpos($key, 'day') !== false) $dkey[] = '%d';
        $dformat = implode('-', $dkey);
        return $dformat;
    }

    /**
     * Provide month and day format in real words if required
     * used for display only ($dformat is used for sorting/grouping)
     *
     * @param string $dformat
     * @return string
     */
    private function _date_format_words($dformat) {
        $wformat = '';
        switch ($dformat) {
            case '%m':
                $wformat = "%B";
                break;
            case '%d':
                $wformat = "%#d%A ";
                break;
            case '%Y-%m':
                $wformat = "%B %Y";
                break;
            case '%m-%d':
                $wformat= "%B %#d, %A ";
                break;
            case '%Y-%m-%d':
                $wformat = "%A, %B %#d, %Y";
                break;
        }
        return $wformat;
    }

    /**
     * A heavily customised version of _ft_pageLookup in inc/fulltext.php
     * no sorting!
     */
    private function _page_lookup($query, $pageonly, $incl_ns, $excl_ns, $nostart = true, $maxns = 0) {
        global $conf;

        $queries = trim($query);
        $pages = file($conf['indexdir'] . '/page.idx');

        // first deal with excluded namespaces, then included
        $pages = $this->_filter_ns($pages, $excl_ns, true);

        // now include ONLY the selected namespaces if provided
        $pages = $this->_filter_ns($pages, $incl_ns, false);

        $cnt = count($pages);
        for ($i = 0; $i < $cnt; $i++) {
            $page = $pages[$i];
            if ( ! page_exists($page) || isHiddenPage($page)) {
                unset($pages[$i]);
                continue;
            }
            if ($pageonly) $page = noNS($page);
            /*
             * This is the actual "search" expression!
             * Note: preg_grep cannot be used because of the pageonly option above
             *       (needs to allow for "^" syntax)
             * The @ prevents problems with invalid queries!
             */
            if (@preg_match('/' . $query . '/i', $page) == 0) {
                unset($pages[$i]);
            }
        }
        if ( ! count($pages)) return array();

        $pages = array_map('trim',$pages);

        // check ACL permissions and remove any 'start' pages if req'd
        $start = $conf['start'];
        $pos = strlen($start);
        foreach($pages as $idx => $name) {
            if ($nostart && substr($name, -$pos) == $start) {
                unset($pages[$idx]);
            // TODO: this function is one of slowest in the plugin; solutions?
            } elseif(auth_quickaclcheck($pages[$idx]) < AUTH_READ) {
                unset($pages[$idx]);
            } elseif ($maxns > 0 && (substr_count($name,':') + 1) > $maxns) {
                unset($pages[$idx]);
            }
        }
        return $pages;
    }
    /**
     * Include/Exclude specific namespaces from a list of pages
     * @param type $pages   a list of wiki page ids
     * @param type $ns_qry  namespace(s) to include/exclude
     * @param type $exclude true = exclude
     * @return array
     */
    private function _filter_ns($pages, $ns_qry, $exclude) {
        $invert = ($exclude) ? PREG_GREP_INVERT : 0;
        foreach ($ns_qry as $ns) {
            $regexes[] = '.*' . $ns . ':.*';
        }
        if ( ! empty($regexes)) {
            $regex = '/(' . implode('|', $regexes) . ')/';
            return array_values(preg_grep($regex, $pages, $invert));
        } else {
            return $pages;
        }
    }
}
?>

blob
mark :97
data 34205
<?php
/**
 * PageQuery Plugin: search for and list pages, sorted/grouped by name, date, creator, etc
 *
 * @license    GPL 2 (http://www.gnu.org/licenses/gpl.html)
 * @author	   Symon Bent <hendrybadao@gmail.com>
 */

// must be run within Dokuwiki
if(!defined('DOKU_INC')) die();

if (!defined('DOKU_LF')) define('DOKU_LF', "\n");
if (!defined('DOKU_TAB')) define('DOKU_TAB', "\t");
if (!defined('DOKU_PLUGIN')) define('DOKU_PLUGIN',DOKU_INC.'lib/plugins/');

require_once(DOKU_PLUGIN . 'syntax.php');
require_once(DOKU_INC . 'inc/fulltext.php');
require_once(DOKU_PLUGIN . 'pagequery/inc/msort.php');

define ('ID_KEY', 0);
define ('NAME_KEY', 1);
define ('ABST_KEY', 2);
define ('START_KEY', 3);
define ('MAX_COLS', 6);

class syntax_plugin_pagequery extends DokuWiki_Syntax_Plugin {

	function getType() {
		return 'substition';
	}

	function getPType() {
		return 'block';
	}

	function getSort() {
		return 98;
	}

	function connectTo($mode) {
		$this->Lexer->addSpecialPattern('\{\{pagequery>.*?\}\}', $mode, 'plugin_pagequery');
	}

    /**
     * Parses all the pagequery options:
     * Insert the pagequery markup wherever you want your list to appear. E.g:
     *
     *   {{pagequery>}}
     *
     *   {{pagequery>[query];fulltext;sort=key:direction,key2:direction;group;limit=??;cols=?;inwords;proper}}
     *
     * Parameters as follows:
     * 1. query:    any expression directly after the >; can use all Dokuwiki search options (see manual)
     * 2. fulltext: use a full-text search, instead of page_id only [default]
     * 3. sort:     keys to sort by, in order of sorting. Each key can be followed by prefered sorting order
     *              available keys:
     *                  a, ab, abc          by 1st letter, 2 letters, or 3 letters
     *                  name                by page name (no namespace) or 1st heading [not grouped]
     *                  page|id             by full page id, including namespace [not grouped]
     *                  ns                  by namespace (without page name)
     *                  mdate, cdate        by modified|created dates (full) [not grouped]
     *                  m[year][month][day] by modified [year][month][day]; any combination accepted
     *                  c[year][month][day] by created [year][month][day]; any combination accepted
     *                  creator             by page author
     *              date sort default to descending, string sorts to ascending
     * 4. group:    show group headers for each change in sort keys
     *              Note: keys with no duplicate cannot be grouped (i.e. name, page|id, mdate, cdate)
     * 5. limit:    maximum number of results to return
     * 6. inwords:  use real month and day names instead of numeric dates
     * 7. cols:     number of columns in displayed list (max = 6)
     * 8. proper:   display page names and namespace in Proper Case (i.e. no _'s and Capitalised)
     *              header/hdr = group headers only, name = page name only, both = both!
     * 9. border:   turn on borders. 'inside' = between columns; 'outside' => border around table;
     *              'both' => in and out; 'none' => neither
     *10. fullregex:only useful on page name searches; allows a raw regex mode on the full page id
     *11. nostart:  ignore any 'start' pages in namespace (based on "config:start")
     *12. maxns:    maximum namespace level to be displayed; e.g. maxns=3 => one:two:three
     *13. title:    show 1st page heading instead of page name
     *14. snippet:  should an excerpt of the wikipage be shown:
     *              use :tooltip to show as a pop-up only
     *              use :<inline|plain|quoted>, <count>, <extent> to show 1st <count> items in list with an abstract
     *                  extent always choice of chars, words, lines, or find (c? w? l? ~????)
     *15. natsort:  use natural sorting order (good for words beginning with numbers)
     *16. case:     respect case when sorting, i.e. a != A when sorting.  a-z then A-Z (opp. to PHP term, easier on average users)
     *17. underline:show a faint underline between each link for clarity
     *
     * All options are optional, and the list will default to a boring long 1-column list...
     */
	function handle($match, $state, $pos, &$handler) {

		$match = substr($match, 12, -2); // strip markup "{{pagequery>"
		$options = explode(';', $match);
        $query = $options[0];

        // establish some basic option defaults
        $sort = array();
        $fulltext = false;
        $group = false;
        $limit = 0;
        $maxns = 0;
        $cols = 1;
        $proper = 'none';
        $border = 'none';
        $snippet = array('none');
        $title = false;
        $fullregex = false;
        $case = false;
        $natsort = false;
        $underline = false;

        foreach ($options as $option) {
            list($key, $value) = explode('=', $option);
            switch ($key) {
                case 'fulltext':
                    $fulltext = true;
                    break;
                case 'sort':
                    $values = explode(',', $value);
                    foreach ($values as $value) {
                        list($key, $dir) = explode(':', $value);
                        $sort[] = array($key, $dir);
                    }
                    break;
                case 'group':
                    $group = true;
                    break;
                case 'limit':
                    $limit = $value;
                    break;
                case 'maxns':
                    $maxns = $value;
                    break;
                case 'inwords':
                    $inwords = true;
                    break;
                case 'proper':
                    switch ($value) {
                        case 'hdr':
                        case 'header':
                        case 'group':
                            $proper = 'header';
                            break;
                        case 'name':
                        case 'page':
                            $proper = 'name';
                            break;
                        default:
                            $proper = 'both';
                    }
                    break;
                case 'cols':
                    $cols = ($value > MAX_COLS) ? MAX_COLS : $value;
                    break;
                case 'border':
                    switch ($value) {
                        case 'none':
                        case 'inside':
                        case 'outside':
                        case 'both':
                            $border = $value;
                            break;
                        default:
                            $border = 'both';
                    }
                    break;
				case 'fullregex':
					$fullregex = true;
					break;
                case 'nostart':
                    $nostart = true;
                    break;
                case 'title':
                    $title = true;
                    break;
                case 'abstract':    // old syntax, to be deprecated (2011-03-15)
                case 'snippet':
                    $opts = explode(',', $value);
                    $type = ( ! empty($opts[0])) ? $opts[0] : 'tooltip';
                    $valid = array('none', 'tooltip', 'inline', 'plain', 'quoted');
                    if ( ! in_array($type, $valid)) $type = 'tooltip';  // always valid!
                    $count = ( ! empty($opts[1])) ? $opts[1] : 0;
                    $extent = ( ! empty($opts[2])) ? $opts[2] : '';
                    $snippet = array($type, $count, $extent);
                    break;
                case 'case':
                    $case = true;
                    break;
                case 'natsort':
                    $natsort = true;
                    break;
                case 'underline':
                    $underline = true;
                    break;
            }
        }
		return array($query, $fulltext, $sort, $group, $limit, $maxns, $proper,
                      $cols, $inwords, $border, $fullregex, $nostart, $title,
                      $snippet, $case, $natsort, $underline);
	}

    function render($mode, &$renderer, $data) {
        $sortkeys = array();
        $incl_ns = array();
        $excl_ns = array();

        list($query, $fulltext, $sort, $group, $limit, $maxns, $proper,
              $cols, $inwords, $border, $fullregex, $nostart, $title,
              $snippet, $case, $natsort, $underline) = $data;

        if ($mode == 'xhtml') {
            // first get a raw list of matching results

            if ($fulltext) {
                // full text (Dokuwiki style) searching
                $results = array_keys(ft_pageSearch($query, $highlight));
            } else {
                // by page id only (
                if ($fullregex) {
                    // allow for raw regex mode, for power users, this searches the full page id
                    $pageonly = false;
                } else {
                    list($query, $incl_ns, $excl_ns) = $this->_parse_ns_query($query);
                    $pageonly = true;
                }
                if ($query == '*') $query = '.*';   // a lazy man's option!
                $results = $this->_page_lookup($query, $pageonly, $incl_ns, $excl_ns, $nostart, $maxns);
            }

            if ( ! empty($results)) {
                // this section is where the essential pagequery functionality happens...

                // prepare the necessary sorting arrays, as per users options
                $get_abstract = ($snippet[0] != 'none');
                list($sort_array, $sort_opts, $group_opts) =
                    $this->_build_sorting_array($results, $sort, $title, $proper, $inwords, $case, $natsort, $get_abstract);

                // now do the sorting (inc/msort.php)
                msort($sort_array, $sort_opts);
                // limit the result list length if required; this can only be done after sorting!
                $sort_array = ($limit > 0) ? array_slice($sort_array, 0, $limit) : $sort_array;

                // and finally the grouping
                if ($group) {
                    $keys = array(NAME_KEY, ID_KEY, ABST_KEY);
                    $sorted_results = mgroup($sort_array, $keys, $group_opts);
                } else {
                    foreach ($sort_array as $row) {
                        $sorted_results[] = array(0, $row[NAME_KEY], $row[ID_KEY], $row[ABST_KEY]);
                    }
                }
                $renderer->doc .= $this->_render_list($sorted_results, $cols, $proper, $snippet, $border, $underline);
            } else {
                $renderer->doc .= $this->_render_no_list($query);
            }
            return true;
        } else {
            return false;
        }
    }

    private function _adjusted_height($sorted_results, $ratios) {
        // ratio of different heading heights (%), to ensure more even use of columns (h1 -> h6)
        foreach ($sorted_results as $row) {
            $adjusted_height += $ratios[$row[0]];
        }
        return $adjusted_height;
    }

    /**
     * Render a simple "no results" message
     *
     * @param string $query => original query
     * @return string
     */
    private function _render_no_list($query) {
        $render = '<div id="pagequery" class="noborder">' . DOKU_LF;
        $render .= '<p class="noresults"><span>pagequery</span>' . $this->getLang("no_results") .
                                  '&nbsp; <strong>' . $query . '</strong></p>' . DOKU_LF;
        $render .= '</div>' . DOKU_LF;
        return $render;
    }
    /**
     * Render the final pagequery results list as HTML, indented and in columns as required
     *
     * @param array  $sorted_results
     * @param int    $cols
     * @param bool   $proper
     * @param string $snippet
     * @param string $border
     * @return string => HTML rendered list
     */
    private function _render_list($sorted_results, $cols, $proper, $snippet, $border, $underline) {
        $ratios = array(.80, 1.3, 1.17, 1.1, 1.03, .96, .90);   // height ratios: link, h1, h2, h3, h4, h5, h6
        $render = '';
        $prev_was_heading = false;
        $can_start_col = true;
        $cont_level = 1;
        $col = 0;
        $col_height = $this->_adjusted_height($sorted_results, $ratios) / $cols;
        $cur_height = 0;
        $width = floor(100 / $cols);
        $snippet_cnt = 0;    // needed by the snippet section for tracking
        $jump_txt= $this->getLang('jump_section');
        $is_first = true;

        // basic result page markup (always needed)
        $outer_border = ($border == 'outside' || $border == 'both') ? '' : ' noborder';
        $no_table = ($cols == 1) ? ' notable' : '';
        $top_id = 'top-' . mt_rand();   // fixed anchor point to jump back to at top of the table
        $render .= '<div class="pagequery' . $outer_border . $no_table . '" id="' . $top_id . '">' . DOKU_LF;
        if ($cols > 1) $render .= '<table><tbody><tr>' . DOKU_LF;

        $inner_border = ($border == 'inside' || $border == 'both') ? '' : ' class="noborder" ';

        // now render the pagequery list
        foreach ($sorted_results as $line) {
            list($level, $name, $id, $abstract) = $line;
            $is_heading = ($level > 0);

            // is it time to start a new column?
            if ($can_start_col === false && $col < $cols && $cur_height >= $col_height) {
                $can_start_col = true;
                $col++;
            }

            // how should headings be displayed?
            if ($is_heading) {
                $heading = $name;
                if ($proper == 'header' || $proper == 'both') $heading = $this->_proper($heading);
            }

            // no need for indent if there is no grouping
            if ($group === false) {
                $indent_style = ' class="nogroup"';
            } else {
                $indent = ($is_heading) ? $level - 1 : $cont_level - 1;
                $indent_style = ' style="margin-left:' . $indent * 10 . 'px"';
            }

            // Begin new column if: 1) we are at the start, 2) last item was not a heading or 3) if there is no grouping
            if ($can_start_col && ! $prev_was_heading) {
                $jump_tip = sprintf($jump_txt, $heading);
                // close the previous column if necessary; also adds a 'jump to anchor'
                $col_close = ( ! $is_heading) ? '<a title="'. $jump_tip . '" href="#' .
                                $top_id . '">' . "<h$cont_level>... </h$cont_level></a>" : '';
                $col_close = ( ! $is_first) ? $col_close . '</ul></td>' . DOKU_LF : '';
                $col_open = ( ! $is_first && ! $is_heading) ? "<h$cont_level$indent_style>" . "$heading...</h$cont_level>" : '';
                $td = ($cols > 1) ? '<td' . $inner_border . ' valign="top" width="' . $width . '%">' : '';
                $render .= $col_close . $td . $col_open . DOKU_LF;
                $can_start_col = false;
                $prev_was_heading = true;    // needed to correctly style page link lists <ul>...
                $cur_height = 0;
            }
            // finally display the appropriate heading or page link(s)
            if ($is_heading) {
                // close previous sub list if necessary
                if ( ! $prev_was_heading) {
                    $render .= '</ul>' . DOKU_LF;
                }
                $render .= "<h$level$indent_style>$heading</h$level>" . DOKU_LF;
                $prev_was_heading = true;
                $cont_level = $level + 1;
            } else {
                // open a new sub list if necessary
                if ($prev_was_heading || $is_first) {
                    $render .= "<ul$indent_style>";
                }
                // deal with normal page links
                $link = $this->_html_wikilink($id, $name, $snippet, $snippet_cnt, $abstract, $underline);
                $snippet_cnt++;
                $render .= $link;
                $prev_was_heading = false;
            }
            $cur_height += $ratios[$level];
            $is_first = false;
        }
        $render .= '</ul>' . DOKU_LF;
        if ($cols > 1) $render .= '</td></tr></tbody></table>' . DOKU_LF;
        $render .= '<a class="top" href="#' . $top_id . '">' . $this->getLang('link_to_top') . '</a>' . DOKU_LF;
        $render .= '</div>' . DOKU_LF;

        return $render;
    }

    /**
     * Renders the page link, plus tooltip, abstract, casing, etc...
     * @param string $id
     * @param bool  $proper
     * @param bool  $title
     * @param mixed $snippet
     * @param int   $snipet_cnt
     * @param bool  $underline
     */
    private function _html_wikilink($id, $name, $snippet_opt, $snippet_cnt, $abstract, $underline) {

        $id = (strpos($id, ':') === false) ? ':' . $id : $id;   // : needed for root pages (root level)

        list($type, $max, $extent) = $snippet_opt;
        $after= '';
        $inline = '';

        if ($type == 'none') {
            // Plain old wikilink
            $link = html_wikilink($id, $name);
        } else {
            $short = $this->_shorten($abstract, $extent);   // shorten BEFORE replacing html entities!
            $short = htmlentities($short, ENT_QUOTES, 'UTF-8');
            $abstract = htmlentities($abstract, ENT_QUOTES, 'UTF-8');
            $link = html_wikilink($id, $name);
            $no_snippet = ($max > 0 && $snippet_cnt >= $max);
            if ($type == 'tooltip' || $no_snippet) {
                $link = $this->_add_tooltip($link, $abstract);
            } elseif ($type == 'quoted' || $type == 'plain') {
                $more = html_wikilink($id, 'more');
                $after = trim($short);
                $after= str_replace("\n\n", "\n", $after);
                $after= str_replace("\n", '<br/>', $after);
                $after= '<div class="' . $type . '">' . $after . $more . '</div>' . DOKU_LF;
            } elseif ($type == 'inline') {
                $inline .= '<span>' . $short . '</span>';
            }
        }
        $noborder = ($underline) ? '' : ' class="noborder"';
        return "<li$noborder>" . $link . $inline . '</li>' . DOKU_LF . $after;
    }

    /**
     * Swap normal link title (popup) for a more useful preview
     *
     * @param string $id    page id
     * @param string $name  display name
     * @return complete href link
     */
    private function _add_tooltip($link, $tooltip) {
        $tooltip = str_replace("\n", '  ', $tooltip);
        $link = preg_replace('/title=\".+?\"/', 'title="' . $tooltip . '"', $link, 1);
        return $link;
    }

    /**
     * return the first part of the $text according to the $amount given
     * @param type $text
     * @param type $amount  c? = ? chars, w? = ? words, l? = ? lines, ~? = search up to text/char/symbol
     */
    private function _shorten($text, $extent, $more = '... ') {
        $elem = $extent[0];
        $cnt = substr($extent, 1);
        switch ($elem) {
            case 'c':
                $result = substr($text, 0, $cnt);
                if ($cnt > 0 && strlen($result) < strlen($text)) $result .= $more;
                break;
            case 'w':
                $words = str_word_count($text, 1, '.');
                $result = implode(' ', array_slice($words, 0, $cnt));
                if ($cnt > 0 && $cnt <= count($words) && $words[$cnt - 1] != '.') $result .= $more;
                break;
            case 'l':
                $lines = explode("\n", $text);
                $lines = array_filter($lines);  // remove blank lines
                $result = implode("\n", array_slice($lines, 0, $cnt));
                if ($cnt > 0 && $cnt < count($lines)) $result .= $more;
                break;
            case "~":
                $result = strstr($text, $cnt, true);
                break;
            default:
                $result = $text;
        }
        return $result;
    }

    /**
     * Changes a wiki page id into proper case (allowing for :'s etc...)
     * @param string    $id    page id
     * @return string
     */
    private function _proper($id) {
         $id = str_replace(':', ': ', $id); // make a little whitespace before words so ucwords can work!
         $id = str_replace('_', ' ', $id);
         $id = ucwords($id);
         $id = str_replace(': ', ':', $id);
         return $id;
    }

    /**
     * Parse out the namespace, and convert to a regex for array search
     *
     * @param  string $query user page query
     * @return string        processed query with necessary regex markup for namespace recognition
     */
    private function _parse_ns_query($query) {
        global $INFO;

        $cur_ns = $INFO['namespace'];
        $incl_ns = array();
        $excl_ns = array();
        $page_qry = '';
        $tokens = explode(' ', $query);
        if (count($tokens) == 1) {
            $page_qry = $query;
        } else {
            foreach ($tokens as $token) {
                if (preg_match('/^(?:\^|-ns:)(.+)$/u', $token, $matches)) {
                    $excl_ns[] = resolve_id($cur_ns, $matches[1]);  // also resolve relative and parent ns
                } elseif (preg_match('/^(?:@|ns:)(.+)$/u', $token, $matches)) {
                    $incl_ns[] = resolve_id($cur_ns, $matches[1]);
                } else {
                    $page_qry .= ' ' . $token;
                }
            }
        }
        $page_qry = trim($page_qry);
        return array($page_qry, $incl_ns, $excl_ns);
    }

    /**
     * Builds the sorting array: array of arrays (0 = id, 1 = name, 2 = abstract, 3 = ... , etc)
     *
     * @param array     $ids        array of page ids to be sorted
     * @param array     $sortkeys   list of array keys to sort by
     * @param bool      $title      use page heading instead of name for sorting
     * @param bool      $proper     use proper case where possible
     * @param bool      $inwords    show dates in words where possible
     * @param bool      $case       honour case when sorting
     * @param bool      $natsort    natural sorting, the human way
     *
     * @return array    $sort_array array of array(one value for each key to be sorted)
     *                   $sort_opts  sorting options for the msort function
     *                   $group_opts grouping options for the mgroup function
     */
    private function _build_sorting_array($ids, $sortkeys, $title, $proper, $inwords, $case, $natsort, $get_abstract) {
        global $conf;

        $sort_opts = array();
        $group_opts = array();
        $abstracts = array();

        $dformat = array();
        $wformat = array();

        $row = 0;
        $end_col = START_KEY + count($sortkeys);

        foreach ($ids as $id) {
            // getting metadata is time-consuming, hence ONCE per displayed row
            $meta = p_get_metadata ($id, false, true);

            if ( ! isset($meta['date']['modified'])) {
                $meta['date']['modified'] = $meta['date']['created'];
            }
            // use page heading instead of page name
            if ($title && isset($meta['title'])) {
                $name = $meta['title'];
            } else {
                $name = noNS($id);
            }
            if ($proper == 'name' || $proper == 'both') {
                $name = $this->_proper($name);
            }
            // first column is the basic page id
            $sort_array[$row][ID_KEY] = $id;
            // second column is the display 'name' (used when sorting by 'name')
            // this also avoids rebuilding the display name when building links later (DRY)
            $sort_array[$row][NAME_KEY] = $name;
            // third column: cache the page abstract if needed; this saves a lot of time later
            // and avoids repeated slow metadata retrievals (v. slow!)
            $sort_array[$row][ABST_KEY] = ($get_abstract) ? $meta['description']['abstract'] : '';

            $col = START_KEY;

            foreach ($sortkeys as $sortkey) {
                $key = $sortkey[0];
                switch ($key) {
                    case 'a':
                        $value = $this->_first($name, 1);
                        break;
                    case 'ab':
                        $value = $this->_first($name, 2);
                        break;
                    case 'abc':
                        $value = $this->_first($name, 3);
                        break;
                    case 'name':
                        // a name column already exists by default (col 1)
                        continue;
                    case 'id':
                    case 'page':
                        $value = $id;
                        break;
                    case 'ns':
                        $value = getNS($id);
                        if (empty($value)) $value = '[' . $conf['start'] . ']';
                        break;
                    case 'creator':
                        $value = $meta['creator'];
                        break;
                    case 'mdate':
                        $value = $meta['date']['modified'];
                        break;
                    case 'cdate':
                        $value = $meta['date']['created'];
                        break;
                    default:
                        // date sorting types (groupable)
                        $dtype = $key[0];
                        if ($dtype == 'c' || $dtype == 'm') {
                            // we only set real date once per id (needed for grouping)
                            // not per sort column--the date should remain same across all columns
                            // this is always the last column!
                            if ($col == START_KEY) {
                                if ($dtype == 'c') {
                                    $date = $meta['date']['created'];
                                } else {
                                    $date = $meta['date']['modified'];
                                }
                                $sort_array[$row][$end_col] = $date;
                            } else {
                                $date = $sort_array[$row][$end_col] ;
                            }
                            // only set date formats once per sort column/key (not per id!)
                            if ($row == 0) {
                                $dformat[$col] = $this->_date_format($key);
                                // collect date in word format for potential use in grouping
                                if ($inwords) {
                                    $wformat[$col] = $this->_date_format_words($dformat[$col]);
                                } else {
                                    $wformat[$col] = '';
                                }
                            }
                            // create a string date used for sorting only
                            // (we cannot just use the real date otherwise it would not group correctly)
                            $value = strftime($dformat[$col], $date);
                        }
                }
                $sort_array[$row][$col] = $value;
                $col++;
            }
            $row++;
        }

        $cnt = START_KEY;
        $order = 0;
        foreach ($sortkeys as $sortkey) {
            list($key, $opt) = $sortkey;

            if ($key == 'name') {
                $col = NAME_KEY;
                // this col number will be re-used next time through
            } else {
                $col = $cnt;
                $cnt++;
            }
            $sort_opts['key'][] = $col;

            // now the sort direction
            switch ($opt) {
                case 'a':
                case 'asc':
                    $dir = MSORT_ASC;
                    break;
                case 'd':
                case 'desc':
                    $dir = MSORT_DESC;
                    break;
                default:
                    // sort descending by default; text ascending
                    // watch for other sort options beginning with c or m ....!
                    if ($key[0] == 'c' || $key[0] == 'm') {
                        $dir = MSORT_DESC;
                    } else {
                        $dir = MSORT_ASC;
                    }
            }
            $sort_opts['dir'][] = $dir;

            // set the sort array's data type
            $is_ns = false;
            switch ($key) {
                case 'mdate':
                case 'cdate':
                    $type = MSORT_NUMERIC;
                    break;
                default:
                    if ($case) {
                        // case sensitive: a-z then A-Z
                        $type = ($natsort) ? MSORT_NAT : MSORT_STRING;
                    } else {
                        // case-insensitive
                        $type = ($natsort) ? MSORT_NAT_CASE : MSORT_STRING_CASE;
                    }
            }
            $sort_opts['type'][] = $type;

            // now establish grouping options
            switch ($key) {
                // name strings and full dates cannot be meaningfully grouped (no duplicates!)
                case 'mdate':
                case 'cdate':
                case 'name':
                case 'id':
                case 'page':
                    $group_by = MGROUP_NONE;
                    break;
                case 'ns':
                    $group_by = MGROUP_NAMESPACE;
                    break;
                default:
                    $group_by = MGROUP_HEADING;
            }
            if ($group_by != MGROUP_NONE) {
                $group_opts['key'][$order] = $col;
                $group_opts['type'][$order] = $group_by;
                $group_opts['dformat'][$order] = $wformat[$col];
                $order++;
            }
        }
        return array($sort_array, $sort_opts, $group_opts, $abstracts);
    }

    // returns first $count letters from $text
    private function _first($text, $count) {
        if ($count > 0) {
            return utf8_substr($text, 0, $count);
        }
    }

    /**
     * Parse the c|m-year-month-day option; used for sorting/grouping
     *
     * @param string  $key
     * @return string
     */
    private function _date_format($key) {
        if (strpos($key, 'year') !== false) $dkey[] = '%Y';
        if (strpos($key, 'month') !== false) $dkey[] = '%m';
        if (strpos($key, 'day') !== false) $dkey[] = '%d';
        $dformat = implode('-', $dkey);
        return $dformat;
    }

    /**
     * Provide month and day format in real words if required
     * used for display only ($dformat is used for sorting/grouping)
     *
     * @param string $dformat
     * @return string
     */
    private function _date_format_words($dformat) {
        $wformat = '';
        switch ($dformat) {
            case '%m':
                $wformat = "%B";
                break;
            case '%d':
                $wformat = "%#d%A ";
                break;
            case '%Y-%m':
                $wformat = "%B %Y";
                break;
            case '%m-%d':
                $wformat= "%B %#d, %A ";
                break;
            case '%Y-%m-%d':
                $wformat = "%A, %B %#d, %Y";
                break;
        }
        return $wformat;
    }

    /**
     * A heavily customised version of _ft_pageLookup in inc/fulltext.php
     * no sorting!
     */
    private function _page_lookup($query, $pageonly, $incl_ns, $excl_ns, $nostart = true, $maxns = 0) {
        global $conf;

        $queries = trim($query);
        $pages = file($conf['indexdir'] . '/page.idx');

        // first deal with excluded namespaces, then included
        $pages = $this->_filter_ns($pages, $excl_ns, true);

        // now include ONLY the selected namespaces if provided
        $pages = $this->_filter_ns($pages, $incl_ns, false);

        $cnt = count($pages);
        for ($i = 0; $i < $cnt; $i++) {
            $page = $pages[$i];
            if ( ! page_exists($page) || isHiddenPage($page)) {
                unset($pages[$i]);
                continue;
            }
            if ($pageonly) $page = noNS($page);
            /*
             * This is the actual "search" expression!
             * Note: preg_grep cannot be used because of the pageonly option above
             *       (needs to allow for "^" syntax)
             * The @ prevents problems with invalid queries!
             */
            if (@preg_match('/' . $query . '/i', $page) == 0) {
                unset($pages[$i]);
            }
        }
        if ( ! count($pages)) return array();

        $pages = array_map('trim',$pages);

        // check ACL permissions and remove any 'start' pages if req'd
        $start = $conf['start'];
        $pos = strlen($start);
        foreach($pages as $idx => $name) {
            if ($nostart && substr($name, -$pos) == $start) {
                unset($pages[$idx]);
            // TODO: this function is one of slowest in the plugin; solutions?
            } elseif(auth_quickaclcheck($pages[$idx]) < AUTH_READ) {
                unset($pages[$idx]);
            } elseif ($maxns > 0 && (substr_count($name,':') + 1) > $maxns) {
                unset($pages[$idx]);
            }
        }
        return $pages;
    }
    /**
     * Include/Exclude specific namespaces from a list of pages
     * @param type $pages   a list of wiki page ids
     * @param type $ns_qry  namespace(s) to include/exclude
     * @param type $exclude true = exclude
     * @return array
     */
    private function _filter_ns($pages, $ns_qry, $exclude) {
        $invert = ($exclude) ? PREG_GREP_INVERT : 0;
        foreach ($ns_qry as $ns) {
            $regexes[] = '.*' . $ns . ':.*';
        }
        if ( ! empty($regexes)) {
            $regex = '/(' . implode('|', $regexes) . ')/';
            return array_values(preg_grep($regex, $pages, $invert));
        } else {
            return $pages;
        }
    }
}
?>

blob
mark :99
data 657
<?php
/**
 * English language file
 *
 * @license    GPL 2 (http://www.gnu.org/licenses/gpl.html)
 * @author     Symon Bent <symonbent@gmail.com>
 */

// custom language strings for the pagequery plugin
$lang['no_results']   = 'No results for the search query:  %1s ';
$lang['jump_section'] = 'Continue with the  %1$s  section at the top...'; // '%1$s' will be replaced by the relevant heading
$lang['jump_to_top']  = 'Back to top of this page list';
$lang['link_to_top']  = 'Top ';
$lang['regex_error']  = 'There is an error in the regular expression.  Check and try again.';
$lang['empty_filter'] = 'The filter expression returned no results.';
blob
mark :100
data 35001
<?php
/**
 * PageQuery Plugin: search for and list pages, sorted/grouped by name, date, creator, etc
 *
 * @license    GPL 2 (http://www.gnu.org/licenses/gpl.html)
 * @author	   Symon Bent <hendrybadao@gmail.com>
 */

// must be run within Dokuwiki
if(!defined('DOKU_INC')) die();

if (!defined('DOKU_LF')) define('DOKU_LF', "\n");
if (!defined('DOKU_TAB')) define('DOKU_TAB', "\t");
if (!defined('DOKU_PLUGIN')) define('DOKU_PLUGIN',DOKU_INC.'lib/plugins/');

require_once(DOKU_PLUGIN . 'syntax.php');
require_once(DOKU_INC . 'inc/fulltext.php');
require_once(DOKU_PLUGIN . 'pagequery/inc/msort.php');

define ('MAX_COLS', 12);

class syntax_plugin_pagequery extends DokuWiki_Syntax_Plugin {

	function getType() {
		return 'substition';
	}

	function getPType() {
		return 'block';
	}

	function getSort() {
		return 98;
	}

	function connectTo($mode) {
		$this->Lexer->addSpecialPattern('\{\{pagequery>.*?\}\}', $mode, 'plugin_pagequery');
	}

    /**
     * Parses all the pagequery options:
     * Insert the pagequery markup wherever you want your list to appear. E.g:
     *
     *   {{pagequery>}}
     *
     *   {{pagequery>[query];fulltext;sort=key:direction,key2:direction;group;limit=??;cols=?;inwords;proper}}
     *
     * Parameters as follows:
     * 1. query:    any expression directly after the >; can use all Dokuwiki search options (see manual)
     * 2. fulltext: use a full-text search, instead of page_id only [default]
     * 3. sort:     keys to sort by, in order of sorting. Each key can be followed by prefered sorting order
     *              available keys:
     *                  a, ab, abc          by 1st letter, 2 letters, or 3 letters
     *                  name                by page name (no namespace) or 1st heading [not grouped]
     *                  page|id             by full page id, including namespace [not grouped]
     *                  ns                  by namespace (without page name)
     *                  mdate, cdate        by modified|created dates (full) [not grouped]
     *                  m[year][month][day] by modified [year][month][day]; any combination accepted
     *                  c[year][month][day] by created [year][month][day]; any combination accepted
     *                  creator             by page author
     *              date sort default to descending, string sorts to ascending
     * 4. group:    show group headers for each change in sort keys
     *              Note: keys with no duplicate cannot be grouped (i.e. name, page|id, mdate, cdate)
     * 5. limit:    maximum number of results to return
     * 6. inwords:  use real month and day names instead of numeric dates
     * 7. cols:     number of columns in displayed list (max = 6)
     * 8. proper:   display page names and namespace in Proper Case (i.e. no _'s and Capitalised)
     *              header/hdr = group headers only, name = page name only, both = both!
     * 9. border:   turn on borders. 'inside' = between columns; 'outside' => border around table;
     *              'both' => in and out; 'none' => neither
     *10. fullregex:only useful on page name searches; allows a raw regex mode on the full page id
     *11. nostart:  ignore any 'start' pages in namespace (based on "config:start")
     *12. maxns:    maximum namespace level to be displayed; e.g. maxns=3 => one:two:three
     *13. title:    show 1st page heading instead of page name
     *14. snippet:  should an excerpt of the wikipage be shown:
     *              use :tooltip to show as a pop-up only
     *              use :<inline|plain|quoted>, <count>, <extent> to show 1st <count> items in list with an abstract
     *                  extent always choice of chars, words, lines, or find (c? w? l? ~????)
     *15. natsort:  use natural sorting order (good for words beginning with numbers)
     *16. case:     respect case when sorting, i.e. a != A when sorting.  a-z then A-Z (opp. to PHP term, easier on average users)
     *17. underline:show a faint underline between each link for clarity
     *
     * All options are optional, and the list will default to a boring long 1-column list...
     */
	function handle($match, $state, $pos, &$handler) {

        $opt = array();

		$match = substr($match, 12, -2); // strip markup "{{pagequery>...}}"
		$params = explode(';', $match);
        $opt['query'] = $params[0];

        // establish some basic option defaults
        $opt['sort'] = array();
        $opt['filter'] = array();
        $opt['fulltext'] = false;
        $opt['fullregex'] = false;
        $opt['group'] = false;
        $opt['limit'] = 0;
        $opt['maxns'] = 0;
        $opt['nostart'] = false;
        $opt['cols'] = 1;
        $opt['proper'] = 'none';
        $opt['border'] = 'none';
        $opt['snippet'] = array('type' => 'none');
        $opt['title'] = false;
        $opt['case'] = false;
        $opt['natsort'] = false;
        $opt['underline'] = false;

        foreach ($params as $param) {
            list($option, $value) = explode('=', $param);
            switch ($option) {
                case 'fulltext':
				case 'fullregex':
                case 'group':
                case 'inwords':
                case 'nostart':
                case 'title':
                case 'case':
                case 'natsort':
                case 'underline':
                    $opt[$option] = true;
                    break;
                case 'limit':
                case 'maxns':
                    $opt[$option] = abs($value);
                    break;
                case 'sort':
                case 'filter':
                    $fields = explode(',', $value);
                    foreach ($fields as $field) {
                        list($key, $expr) = explode(':', $field);
                        $opt[$option][$key] = $expr;
                    }
                    break;
                case 'proper':
                    switch ($value) {
                        case 'hdr':
                        case 'header':
                        case 'group':
                            $opt['proper'] = 'header';
                            break;
                        case 'name':
                        case 'page':
                            $opt['proper'] = 'name';
                            break;
                        default:
                            $opt['proper'] = 'both';
                    }
                    break;
                case 'cols':
                    $opt['cols'] = ($value > MAX_COLS) ? MAX_COLS : $value;
                    break;
                case 'border':
                    switch ($value) {
                        case 'none':
                        case 'inside':
                        case 'outside':
                        case 'both':
                            $opt['border'] = $value;
                            break;
                        default:
                            $opt['border'] = 'both';
                    }
                    break;
                case 'abstract':    // old syntax, to be deprecated (2011-03-15)
                case 'snippet':
                    $options = explode(',', $value);
                    $type = ( ! empty($options[0])) ? $options[0] : 'tooltip';
                    $valid = array('none', 'tooltip', 'inline', 'plain', 'quoted');
                    if ( ! in_array($type, $valid)) $type = 'tooltip';  // always valid!
                    $count = ( ! empty($options[1])) ? $options[1] : 0;
                    $extent = ( ! empty($options[2])) ? $options[2] : '';
                    $opt['snippet'] = array('type' => $type, 'count' => $count, 'extent' => $extent);
                    break;
            }
        }
		return $opt;
	}

    function render($mode, &$renderer, $opt) {
        $query = $opt['query'];

        $incl_ns = array();
        $excl_ns = array();

        if ($mode == 'xhtml') {
            // first get a raw list of matching results

            if ($opt['fulltext']) {
                // full text (Dokuwiki style) searching
                $results = array_keys(ft_pageSearch($opt['query'], $highlight));
            } else {
                // by page id only (
                if ($opt['fullregex']) {
                    // allow for raw regex mode, for power users, this searches the full page id
                    $pageonly = false;
                } else {
                    list($query, $incl_ns, $excl_ns) = $this->_parse_ns_query($query);
                    $pageonly = true;
                }

                if ($query == '*') $query = '.*';   // a lazy man's option!
                $results = $this->_page_lookup($query, $pageonly, $incl_ns, $excl_ns, $opt['nostart'], $opt['maxns']);
            }

            if ($results === false) {
                $empty = true;
                $message = $this->getLang('regex_error');
            } elseif ( ! empty($results)) {
                // *** this section is where the essential pagequery functionality happens... ***

                // prepare the necessary sorting arrays, as per users options
                $get_abstract = ($opt['snippet']['type'] != 'none');
                list($sort_array, $sort_opts, $group_opts) = $this->_build_sorting_array($results, $get_abstract, $opt);

                // meta data filtering of the list is next
                $sort_array = $this->_filter_meta($sort_array, $opt['filter']);
                if (empty($sort_array)) {
                    $empty = true;
                    $message = $this-getLang("empty_filter");
                }
            }

            if ( ! $empty) {
                // now do the sorting (inc/msort.php)
                msort($sort_array, $sort_opts);
                // limit the result list length if required; this can only be done after sorting!
                $sort_array = ($opt['limit'] > 0) ? array_slice($sort_array, 0, $opt['limit']) : $sort_array;

                // and finally the grouping
                if ($opt['group']) {
                    $keys = array('name', 'id', 'abstract');
                    $sorted_results = mgroup($sort_array, $keys, $group_opts);
                } else {
                    foreach ($sort_array as $row) {
                        $sorted_results[] = array(0, $row['name'], $row['id'], $row['abstract']);
                    }
                }
                $renderer->doc .= $this->_render_list($sorted_results, $opt);
            } else {
                $renderer->doc .= $this->_render_no_list($query, $message);
            }
            return true;
        } else {
            return false;
        }
    }

    private function _adjusted_height($sorted_results, $ratios) {
        // ratio of different heading heights (%), to ensure more even use of columns (h1 -> h6)
        foreach ($sorted_results as $row) {
            $adjusted_height += $ratios[$row[0]];
        }
        return $adjusted_height;
    }

    /**
     * Render a simple "no results" message
     *
     * @param string $query => original query
     * @return string
     */
    private function _render_no_list($query, $error = '') {
        $render = '<div class="pagequery noborder">' . DOKU_LF;
        $render .= '<p class="noresults"><span>pagequery</span>' . sprintf($this->getLang("no_results"),
                                  '<strong>' . $query . '</strong>') . '</p>' . DOKU_LF;
        if ( ! empty($error)) {
            $render .= '<p class="noresults">' . $error . '</p>' . DOKU_LF;
        }
        $render .= '</div>' . DOKU_LF;
        return $render;
    }

    /**
     * Render the final pagequery results list as HTML, indented and in columns as required
     *
     * @param array  $sorted_results
     * @param int    $cols
     * @param bool   $proper
     * @param string $snippet
     * @param string $border
     * @return string => HTML rendered list
     */
    private function _render_list($sorted_results, $opt) {
        $ratios = array(.80, 1.3, 1.17, 1.1, 1.03, .96, .90);   // height ratios: link, h1, h2, h3, h4, h5, h6
        $render = '';
        $prev_was_heading = false;
        $can_start_col = true;
        $cont_level = 1;
        $col = 0;
        $multi_col = $opt['cols'] > 1;  // single columns are displayed without tables (better for TOC)
        $col_height = $this->_adjusted_height($sorted_results, $ratios) / $opt['cols'];
        $cur_height = 0;
        $width = floor(100 / $opt['cols']);
        $snippet_cnt = 0;    // needed by the snippet section for tracking
        $is_first = true;

        // basic result page markup (always needed)
        $outer_border = ($opt['border'] == 'outside' || $opt['border'] == 'both') ? '' : ' noborder';
        $no_table = ( ! $multi_col) ? ' notable' : '';
        $top_id = 'top-' . mt_rand();   // fixed anchor point to jump back to at top of the table
        $render .= '<div class="pagequery' . $outer_border . $no_table . '" id="' . $top_id . '">' . DOKU_LF;
        if ($multi_col) $render .= '<table><tbody><tr>' . DOKU_LF;

        $inner_border = ($border == 'inside' || $border == 'both') ? '' : ' class="noborder" ';

        // now render the pagequery list
        foreach ($sorted_results as $line) {
            list($level, $name, $id, $abstract) = $line;
            $is_heading = ($level > 0);

            // is it time to start a new column?
            if ($can_start_col === false && $col < $opt['cols'] && $cur_height >= $col_height) {
                $can_start_col = true;
                $col++;
            }

            // how should headings be displayed?
            if ($is_heading) {
                $heading = $name;
                if ($opt['proper'] == 'header' || $opt['proper'] == 'both') $heading = $this->_proper($heading);
            }

            // no need for indenting if there is no grouping
            if ($opt['group'] === false) {
                $indent_style = ' class="nogroup"';
            } else {
                $indent = ($is_heading) ? $level - 1 : $cont_level - 1;
                $indent_style = ' style="margin-left:' . $indent * 10 . 'px"';
            }

            // Begin new column if: 1) we are at the start, 2) last item was not a heading or 3) if there is no grouping
            if ($can_start_col && ! $prev_was_heading) {
                $jump_tip = sprintf($this->getLang('jump_section'), $heading);
                // close the previous column if necessary; also adds a 'jump to anchor'
                $col_close = ( ! $is_heading) ? '<a title="'. $jump_tip . '" href="#' .
                                $top_id . '">' . "<h$cont_level>... </h$cont_level></a>" : '';
                $col_close = ( ! $is_first) ? $col_close . '</ul></td>' . DOKU_LF : '';
                $col_open = ( ! $is_first && ! $is_heading) ? "<h$cont_level$indent_style>" . "$heading...</h$cont_level>" : '';
                $td = ($multi_col) ? '<td' . $inner_border . ' valign="top" width="' . $width . '%">' : '';
                $render .= $col_close . $td . $col_open . DOKU_LF;
                $can_start_col = false;
                $prev_was_heading = true;    // needed to correctly style page link lists <ul>...
                $cur_height = 0;
            }
            // finally display the appropriate heading or page link(s)
            if ($is_heading) {
                // close previous sub list if necessary
                if ( ! $prev_was_heading) {
                    $render .= '</ul>' . DOKU_LF;
                }
                $render .= "<h$level$indent_style>$heading</h$level>" . DOKU_LF;
                $prev_was_heading = true;
                $cont_level = $level + 1;
            } else {
                // open a new sub list if necessary
                if ($prev_was_heading || $is_first) {
                    $render .= "<ul$indent_style>";
                }
                // deal with normal page links
                $link = $this->_html_wikilink($id, $name, $snippet_cnt, $abstract, $opt);
                $snippet_cnt++;
                $render .= $link;
                $prev_was_heading = false;
            }
            $cur_height += $ratios[$level];
            $is_first = false;
        }
        $render .= '</ul>' . DOKU_LF;
        if ($multi_col) $render .= '</td></tr></tbody></table>' . DOKU_LF;
        $render .= '<a class="top" href="#' . $top_id . '">' . $this->getLang('link_to_top') . '</a>' . DOKU_LF;
        $render .= '</div>' . DOKU_LF;

        return $render;
    }

    /**
     * Renders the page link, plus tooltip, abstract, casing, etc...
     * @param string $id
     * @param bool  $proper
     * @param bool  $title
     * @param mixed $snippet
     * @param int   $snipet_cnt
     * @param bool  $underline
     */
    private function _html_wikilink($id, $name, $snippet_cnt, $abstract, $opt) {

        $id = (strpos($id, ':') === false) ? ':' . $id : $id;   // : needed for root pages (root level)

        $type = $opt['snippet']['type'];
        $count = $opt['snippet']['count'];
        $after= '';
        $inline = '';

        if ($type == 'none') {
            // Plain old wikilink
            $link = html_wikilink($id, $name);
        } else {
            $short = $this->_shorten($abstract, $opt['snippet']['extent']);   // shorten BEFORE replacing html entities!
            $short = htmlentities($short, ENT_QUOTES, 'UTF-8');
            $abstract = htmlentities($abstract, ENT_QUOTES, 'UTF-8');
            $link = html_wikilink($id, $name);
            $no_snippet = ($count > 0 && $snippet_cnt >= $count);
            if ($type == 'tooltip' || $no_snippet) {
                $link = $this->_add_tooltip($link, $abstract);
            } elseif ($type == 'quoted' || $type == 'plain') {
                $more = html_wikilink($id, 'more');
                $after = trim($short);
                $after = str_replace("\n\n", "\n", $after);
                $after = str_replace("\n", '<br/>', $after);
                $after = '<div class="' . $type . '">' . $after . $more . '</div>' . DOKU_LF;
            } elseif ($type == 'inline') {
                $inline .= '<span>' . $short . '</span>';
            }
        }
        $noborder = ($opt['underline']) ? '' : ' class="noborder"';
        return "<li$noborder>" . $link . $inline . '</li>' . DOKU_LF . $after;
    }

    /**
     * Swap normal link title (popup) for a more useful preview
     *
     * @param string $id    page id
     * @param string $name  display name
     * @return complete href link
     */
    private function _add_tooltip($link, $tooltip) {
        $tooltip = str_replace("\n", '  ', $tooltip);
        $link = preg_replace('/title=\".+?\"/', 'title="' . $tooltip . '"', $link, 1);
        return $link;
    }

    /**
     * return the first part of the $text according to the $amount given
     * @param type $text
     * @param type $amount  c? = ? chars, w? = ? words, l? = ? lines, ~? = search up to text/char/symbol
     */
    private function _shorten($text, $extent, $more = '... ') {
        $elem = $extent[0];
        $cnt = substr($extent, 1);
        switch ($elem) {
            case 'c':
                $result = substr($text, 0, $cnt);
                if ($cnt > 0 && strlen($result) < strlen($text)) $result .= $more;
                break;
            case 'w':
                $words = str_word_count($text, 1, '.');
                $result = implode(' ', array_slice($words, 0, $cnt));
                if ($cnt > 0 && $cnt <= count($words) && $words[$cnt - 1] != '.') $result .= $more;
                break;
            case 'l':
                $lines = explode("\n", $text);
                $lines = array_filter($lines);  // remove blank lines
                $result = implode("\n", array_slice($lines, 0, $cnt));
                if ($cnt > 0 && $cnt < count($lines)) $result .= $more;
                break;
            case "~":
                $result = strstr($text, $cnt, true);
                break;
            default:
                $result = $text;
        }
        return $result;
    }

    /**
     * Changes a wiki page id into proper case (allowing for :'s etc...)
     * @param string    $id    page id
     * @return string
     */
    private function _proper($id) {
         $id = str_replace(':', ': ', $id); // make a little whitespace before words so ucwords can work!
         $id = str_replace('_', ' ', $id);
         $id = ucwords($id);
         $id = str_replace(': ', ':', $id);
         return $id;
    }

    /**
     * Parse out the namespace, and convert to a regex for array search
     *
     * @param  string $query user page query
     * @return string        processed query with necessary regex markup for namespace recognition
     */
    private function _parse_ns_query($query) {
        global $INFO;

        $cur_ns = $INFO['namespace'];
        $incl_ns = array();
        $excl_ns = array();
        $page_qry = '';
        $tokens = explode(' ', trim($query));
        if (count($tokens) == 1) {
            $page_qry = $query;
        } else {
            foreach ($tokens as $token) {
                if (preg_match('/^(?:\^|-ns:)(.+)$/u', $token, $matches)) {
                    $excl_ns[] = resolve_id($cur_ns, $matches[1]);  // also resolve relative and parent ns
                } elseif (preg_match('/^(?:@|ns:)(.+)$/u', $token, $matches)) {
                    $incl_ns[] = resolve_id($cur_ns, $matches[1]);
                } else {
                    $page_qry .= ' ' . $token;
                }
            }
        }
        $page_qry = trim($page_qry);
        return array($page_qry, $incl_ns, $excl_ns);
    }

    /**
     * Builds the sorting array: array of arrays (0 = id, 1 = name, 2 = abstract, 3 = ... , etc)
     *
     * @param array     $ids        array of page ids to be sorted
     * @param array     $sortkeys   list of array keys to sort by
     * @param bool      $title      use page heading instead of name for sorting
     * @param bool      $proper     use proper case where possible
     * @param bool      $inwords    show dates in words where possible
     * @param bool      $case       honour case when sorting
     * @param bool      $natsort    natural sorting, the human way
     *
     * @return array    $sort_array array of array(one value for each key to be sorted)
     *                   $sort_opts  sorting options for the msort function
     *                   $group_opts grouping options for the mgroup function
     */
    private function _build_sorting_array($ids, $get_abstract, $opt) {
        global $conf;

        $sort_opts = array();
        $group_opts = array();

        $dformat = array();
        $wformat = array();
        $extrakeys = array();

        $row = 0;

        // any extra columns needed for filtering are added also!
        $extrakeys = array_diff_key($opt['filter'], $opt['sort']);
        $col_keys = array_merge($opt['sort'], $extrakeys);

        foreach ($ids as $id) {
            // getting metadata is very time-consuming, hence ONCE per displayed row
            $meta = p_get_metadata ($id, false, true);

            if ( ! isset($meta['date']['modified'])) {
                $meta['date']['modified'] = $meta['date']['created'];
            }
            // use page heading instead of page name
            if ($title && isset($meta['title'])) {
                $name = $meta['title'];
            } else {
                $name = noNS($id);
            }
            if ($opt['proper'] == 'name' || $opt['proper'] == 'both') {
                $name = $this->_proper($name);
            }
            // first column is the basic page id
            $sort_array[$row]['id'] = $id;

            // second column is the display 'name' (used when sorting by 'name')
            // this also avoids rebuilding the display name when building links later (DRY)
            $sort_array[$row]['name'] = $name;

            // third column: cache the page abstract if needed; this saves a lot of time later
            // and avoids repeated slow metadata retrievals (v. slow!)
            $sort_array[$row]['abstract'] = ($get_abstract) ? $meta['description']['abstract'] : '';

            // cache of full date for this row
            $real_date = 0;

            foreach ($col_keys as $key => $_void) {
                switch ($key) {
                    case 'a':
                    case 'ab':
                    case 'abc':
                        $value = $this->_first($name, strlen($key));
                        break;
                    case 'name':
                        // a name column already exists by default (col 1)
                        continue 2; // move on to the next key
                    case 'id':
                    case 'page':
                        $value = $id;
                        break;
                    case 'ns':
                        $value = getNS($id);
                        if (empty($value)) $value = '[' . $conf['start'] . ']';
                        break;
                    case 'creator':
                        $value = $meta['creator'];
                        break;
                    case 'contributor':
                        $value = implode(';', $meta['contributor']);
                        break;
                    case 'mdate':
                        $value = $meta['date']['modified'];
                        break;
                    case 'cdate':
                        $value = $meta['date']['created'];
                        break;
                    default:
                        // date sorting types (groupable)
                        $dtype = $key[0];
                        if ($dtype == 'c' || $dtype == 'm') {
                            // we only set real date once per id (needed for grouping)
                            // not per sort column--the date should remain same across all columns
                            // this is always the last column!
                            if ($real_date == 0) {
                                if ($dtype == 'c') {
                                    $real_date = $meta['date']['created'];
                                } else {
                                    $real_date = $meta['date']['modified'];
                                }
                                $sort_array[$row][MGROUP_REALDATE] = $real_date;
                            }
                            // only set date formats once per sort column/key (not per id!), i.e. on first row
                            if ($row == 0) {
                                $dformat[$key] = $this->_date_format($key);
                                // collect date in word format for potential use in grouping
                                if ($opt['inwords']) {
                                    $wformat[$key] = $this->_date_format_words($dformat[$key]);
                                } else {
                                    $wformat[$key] = '';
                                }
                            }
                            // create a string date used for sorting only
                            // (we cannot just use the real date otherwise it would not group correctly)
                            $value = strftime($dformat[$key], $real_date);
                        }
                }
                $sort_array[$row][$key] = $value;
            }
            $row++;
        }

        $idx = 0;
        foreach ($opt['sort'] as $key => $value) {

            $sort_opts['key'][] = $key;

            // now the sort direction
            switch ($value) {
                case 'a':
                case 'asc':
                    $dir = MSORT_ASC;
                    break;
                case 'd':
                case 'desc':
                    $dir = MSORT_DESC;
                    break;
                default:
                    switch ($key) {
                    // sort dates descending by default; text ascending
                        case 'a':
                        case 'ab':
                        case 'abc':
                        case 'page':
                        case 'id':
                        case 'name':
                        case 'ns':
                        case 'creator':
                        case 'contributor':
                            $dir = MSORT_ASC;
                            break;
                        default:
                            $dir = MSORT_DESC;
                            break;
                    }
            }
            $sort_opts['dir'][] = $dir;

            // set the sort array's data type
            $is_ns = false;
            switch ($key) {
                case 'mdate':
                case 'cdate':
                    $type = MSORT_NUMERIC;
                    break;
                default:
                    if ($case) {
                        // case sensitive: a-z then A-Z
                        $type = ($opt['natsort']) ? MSORT_NAT : MSORT_STRING;
                    } else {
                        // case-insensitive
                        $type = ($opt['natsort']) ? MSORT_NAT_CASE : MSORT_STRING_CASE;
                    }
            }
            $sort_opts['type'][] = $type;

            // now establish grouping options
            switch ($key) {
                // name strings and full dates cannot be meaningfully grouped (no duplicates!)
                case 'mdate':
                case 'cdate':
                case 'name':
                case 'id':
                case 'page':
                    $group_by = MGROUP_NONE;
                    break;
                case 'ns':
                    $group_by = MGROUP_NAMESPACE;
                    break;
                default:
                    $group_by = MGROUP_HEADING;
            }
            if ($group_by != MGROUP_NONE) {
                $group_opts['key'][$idx] = $key;
                $group_opts['type'][$idx] = $group_by;
                $group_opts['dformat'][$idx] = $wformat[$key];
                $idx++;
            }
        }
        return array($sort_array, $sort_opts, $group_opts);
    }

    // returns first $count letters from $text
    private function _first($text, $count) {
        if ($count > 0) {
            return utf8_substr($text, 0, $count);
        }
    }

    /**
     * Parse the c|m-year-month-day option; used for sorting/grouping
     *
     * @param string  $key
     * @return string
     */
    private function _date_format($key) {
        if (strpos($key, 'year') !== false) $dkey[] = '%Y';
        if (strpos($key, 'month') !== false) $dkey[] = '%m';
        if (strpos($key, 'day') !== false) $dkey[] = '%d';
        $dformat = implode('-', $dkey);
        return $dformat;
    }

    /**
     * Provide month and day format in real words if required
     * used for display only ($dformat is used for sorting/grouping)
     *
     * @param string $dformat
     * @return string
     */
    private function _date_format_words($dformat) {
        $wformat = '';
        switch ($dformat) {
            case '%m':
                $wformat = "%B";
                break;
            case '%d':
                $wformat = "%#d%A ";
                break;
            case '%Y-%m':
                $wformat = "%B %Y";
                break;
            case '%m-%d':
                $wformat= "%B %#d, %A ";
                break;
            case '%Y-%m-%d':
                $wformat = "%A, %B %#d, %Y";
                break;
        }
        return $wformat;
    }

    /**
     * A heavily customised version of _ft_pageLookup in inc/fulltext.php
     * no sorting!
     */
    private function _page_lookup($query, $pageonly, $incl_ns, $excl_ns, $nostart = true, $maxns = 0) {
        global $conf;

        $query = trim($query);
        $pages = file($conf['indexdir'] . '/page.idx');

        // first deal with excluded namespaces, then included
        $pages = $this->_filter_ns($pages, $excl_ns, true);

        // now include ONLY the selected namespaces if provided
        $pages = $this->_filter_ns($pages, $incl_ns, false);

        $cnt = count($pages);
        for ($i = 0; $i < $cnt; $i++) {
            $page = $pages[$i];
            if ( ! page_exists($page) || isHiddenPage($page)) {
                unset($pages[$i]);
                continue;
            }
            if ($pageonly) $page = noNS($page);
            /*
             * This is the actual "search" expression!
             * Note: preg_grep cannot be used because of the pageonly option above
             *       (needs to allow for "^" syntax)
             * The @ prevents problems with invalid queries!
             */
            $matched = @preg_match('/' . $query . '/i', $page);
            if ($matched === false) {
                return false;
            } elseif ($matched == 0) {
                unset($pages[$i]);
            }
        }
        if ( ! count($pages)) return array();

        $pages = array_map('trim',$pages);

        // check ACL permissions and remove any 'start' pages if req'd
        $start = $conf['start'];
        $pos = strlen($start);
        foreach($pages as $idx => $name) {
            if ($nostart && substr($name, -$pos) == $start) {
                unset($pages[$idx]);
            // TODO: this function is one of slowest in the plugin; solutions?
            } elseif(auth_quickaclcheck($pages[$idx]) < AUTH_READ) {
                unset($pages[$idx]);
            } elseif ($maxns > 0 && (substr_count($name,':') + 1) > $maxns) {
                unset($pages[$idx]);
            }
        }
        return $pages;
    }

    /**
     * Include/Exclude specific namespaces from a list of pages
     * @param type $pages   a list of wiki page ids
     * @param type $ns_qry  namespace(s) to include/exclude
     * @param type $exclude true = exclude
     * @return array
     */
    private function _filter_ns($pages, $ns_qry, $exclude) {
        $invert = ($exclude) ? PREG_GREP_INVERT : 0;
        foreach ($ns_qry as $ns) {
            $regexes[] = '.*' . $ns . ':.*';
        }
        if ( ! empty($regexes)) {
            $regex = '/(' . implode('|', $regexes) . ')/';
            return array_values(preg_grep($regex, $pages, $invert));
        } else {
            return $pages;
        }
    }

    /**
     * filter array of pages by specific meta data keys (or columns)
     *
     * @param type $sort_array  full sorting array, all meta columns included
     * @param type $filter  meta-data filter: <meta key>:<query>
     */
    private function _filter_meta($sort_array, $filter) {
        foreach ($filter as $metakey => $expr) {
            $sort_array = array_filter($sort_array, function($row) use ($metakey, $expr) {
                return preg_match('`' . $expr . '`', $row[$metakey]) > 0;
            });
        }
        return $sort_array;
    }
}
?>

blob
mark :101
data 11720
<?php
// keep key associations
define('MSORT_KEEP_ASSOC', 'msort01');

// additional sorting type
define('MSORT_NUMERIC', 'msort02');
define('MSORT_REGULAR', 'msort03');
define('MSORT_STRING', 'msort04');
define('MSORT_STRING_CASE', 'msort05'); // case insensitive
define('MSORT_NAT', 'msort06');         // natural sorting
define('MSORT_NAT_CASE', 'msort07');    // natural sorting, case insensitive

define('MSORT_ASC', 'msort08');
define('MSORT_DESC', 'msort09');

define('MSORT_DEFAULT_DIRECTION', MSORT_ASC);
define('MSORT_DEFAULT_TYPE', MSORT_STRING);

/**
 * A replacement for array_mulitsort which permits natural and caseless sorting
 * This function will sort an 'array of rows' only (not array of 'columns')
 *
 * @param array $sort_array  : multi-dimensional array of arrays, where the first index refers to the row number
 *                             and the second to the column number (e.g. $array[row_number][column_number])
 *                             i.e. = array(
 *                                          array('name1', 'job1', 'start_date1', 'rank1'),
 *                                          array('name2', 'job2', 'start_date2', 'rank2'),
 *                                          ...
 *                                          );
 *
 * @param mixed $sort_opts   : options for how the array should be sorted
 *                    :AS ARRAY
 *                             $sort_opts['key'][<column>] = 'key'
 *                             $sort_opts['type'][<column>] = 'type'
 *                             $sort_opts['dir'][<column>] = 'dir'
 *                             $sort_opts['assoc'][<column>] = MSORT_KEEP_ASSOC | true
 * @return boolean
 */

function msort(&$sort_array, $sort_opts) {

    // if a full sort_opts array was passed
    if (is_array($sort_opts) && ! empty($sort_opts)) {
        if (isset($sort_opts['assoc'])) {
            $keep_assoc = true;
        }
    } else {
        return false;
    }

    // Determine which u..sort function (with or without associations).
    $sort_func = ($keep_assoc) ? 'uasort' : 'usort';

    $keys = $sort_opts['key'];

    // Sort the data and get the result.
    $result = $sort_func (
        $sort_array,
        function(array &$left, array &$right) use(&$sort_opts, $keys) {

            // Assume that the entries are the same.
            $cmp = 0;

            // Work through each sort column
            foreach($keys as $idx => $key) {
                // Handle the different sort types.
                switch ($sort_opts['type'][$idx]) {
                    case MSORT_NUMERIC:
                        $key_cmp = ((intval($left[$key]) == intval($right[$key])) ? 0 :
                                   ((intval($left[$key]) < intval($right[$key])) ? -1 : 1 ) );
                        break;

                    case MSORT_STRING:
                        $key_cmp = strcmp((string)$left[$key], (string)$right[$key]);
                        break;

                    case MSORT_STRING_CASE: //case-insensitive
                        $key_cmp = strcasecmp((string)$left[$key], (string)$right[$key]);
                        break;

                    case MSORT_NAT:
                        $key_cmp = strnatcmp((string)$left[$key], (string)$right[$key]);
                        break;

                    case MSORT_NAT_CASE:    //case-insensitive
                        $key_cmp = strnatcasecmp((string)$left[$key], (string)$right[$key]);
                        break;

                    case MSORT_REGULAR:
                    default :
                        $key_cmp = (($left[$key] == $right[$key]) ? 0 :
                                   (($left[$key] < $right[$key]) ? -1 : 1 ) );
                    break;
                }

                // Is the column in the two arrays the same?
                if ($key_cmp == 0) {
                    continue;
                }

                // Are we sorting descending?
                $cmp = $key_cmp * (($sort_opts['dir'][$idx] == MSORT_DESC) ? -1 : 1);

                // no need for remaining keys as there was a difference
                break;
            }
            return $cmp;
        }
    );
	return $result;
}

/**
 * A replacement for array_mulitsort which permits natural and caseless sorting
 * This function will sort an 'array of rows' only (not array of 'columns')
 *
 * @param array $sort_array  : multi-dimensional array of arrays, where the first index refers to the row number
 *                             and the second to the column number (e.g. $array[row_number][column_number])
 *                             i.e. = array(
 *                                          array('name1', 'job1', 'start_date1', 'rank1'),
 *                                          array('name2', 'job2', 'start_date2', 'rank2'),
 *                                          ...
 *                                          );
 *
 * @param mixed $sort_opts   : options for how the array should be sorted
 *                   : AS ARGS
 *                             $key, $type, $direction [,$key2, $type2, $direction2, ...etc], $assoc
 *                             $key      = key/column to sort by
 *                             $type     = sorting type, one of following:
 *                                           MSORT_NUMERIC
 *                                           MSORT_REGULAR
 *                                           MSORT_STRING
 *                                           MSORT_STRING_CASE  : caseless sorting
 *                                           MSORT_NAT          : natural sorting
 *                                           MSORT_NAT_CASE
 *                             $direction = sorting direction:
 *                                           MSORT_ASC
 *                                           MSORT_DESC
 *                             $assoc     = keep associative array keys (uasort)
 *                                           MSORT_KEEP_ASSOC
 * @return boolean
 */
function msort_args(&$sort_array) {

    $sort_opts = array();

    $args = func_get_args();

    if (end($args) == MSORT_KEEP_ASSOC) {
        $keep_assoc = true;
        array_pop($args);
    }

    // make sure there is something to sort
    if (empty($args)) return true;

    $type_enums = array(
                       MSORT_NUMERIC,
                       MSORT_REGULAR,
                       MSORT_STRING,
                       MSORT_STRING_CASE,
                       MSORT_NAT,
                       MSORT_NAT_CASE
                       );
    $direction_enums = array(
                            MSORT_ASC,
                            MSORT_DESC
                            );

    // work through the args list (SORT_KEY, SORT_TYPE, SORT_DIRECTION)
    $order = -1;
    foreach ($args as $arg) {
        // is it a sort direction?
        if (in_array($arg, $direction_enums)) {
            $sort_opts['dir'][$order] = $arg;
        // is it a sort type?
        } elseif (in_array($arg, $type_enums)) {
            $sort_opts['type'][$order] = $arg;
        // is it a sort array?
        } elseif (is_numeric($arg)) {
            $order++;
            $sort_opts['key'][$order] = $arg;
            $sort_opts['type'][$order] = MSORT_DEFAULT_TYPE;
            $sort_opts['dir'][$order] = MSORT_DEFAULT_DIRECTION;
        }
    }
    return msort($sort_array, $sort_opts);
}

// grouping types
define ('MGROUP_NONE', 'mgrp00');
define ('MGROUP_HEADING', 'mgrp01');
define ('MGROUP_NAMESPACE', 'mgrp02');

// real date column
define ('MGROUP_REALDATE', '__realdate__');

/**
 * group a multi-dimensional array by each level heading
 * @param array $sort_array : array to be grouped (result of 'msort' function)
 *                             __realdate__' column should contain real dates if you need dates in words
 * @param array $keys       : which keys (columns) should be returned in results array? (as keys)
 * @param mixed $group_opts :  AS ARRAY:
 *                             $group_opts['key'][<order>] = column key to group by
 *                             $group_opts['type'][<order>] = grouping type [MGROUP...]
 *                             $group_opts['dformat'][<order>] = date formatting string
 *
 * @return array $results   : array of arrays: (level, display_name, page_id), e.g. array(1, 'Main Title')
 *                              array(0, '...') =>  0 = normal row item (not heading)
 */
function mgroup(&$sort_array, $keys, $group_opts) {
    $level = count($group_opts['key']) - 1;
    $prevs = array();
    $results = array();
    $idx = 0;

    foreach($sort_array as $row) {
        _add_heading($results, $sort_array, $group_opts, $level, $idx, $prevs);
        $result = array(0); // basic item (page link) is level 0
        for ($i = 0; $i < count($keys); $i++) {
            $result[] = $row[$keys[$i]];
        }
        $results[] = $result;
        $idx++;
    }
    return $results;
}
/**
 * as above, but by args:
*                    AS ARGS:
*                              key, type, dformat [,key, type, dformat]... [,real_dates]
*                              key      = group by key/column
*                              type     = one of the MGROUP types
*                              dformat  = date format (if used)
 *
 * @param array $sort_array
 * @param array $cols
 * @param mixed $group_opts
 */
function mgroup_args($sort_array, $keys) {
    $args = func_get_args();

    $type_enums = array(
                        MGROUP_HEADING,
                        MGROUP_NAMESPACE,
                        );

    // get all the grouping options
    // order (which key/column), type (grouping type see MGROUP_...), dformat (real date display format),... repeated
    $group_opts = array();
    $order = -1;
    foreach ($args as $arg) {
        if (is_numeric($arg)) {
            $order++;
            $group_opts['key'][$order] = $arg;
            $group_opts['type'] [$order]= MGROUP_HEADING; // defaults
            $group_opts['dformat'] [$order]= '';
        } elseif ($order > -1) {
            if (in_array($arg, $type_enums)) {
                $group_opts['type'][$order] = $arg;
            } else {
                $group_opts['dformat'][$order] = $arg;
            }
        }
    }
    msort($sort_array, $keys, $group_opts);
}

/**
 * private function used by mgroup only!
 */
function _add_heading(&$results, &$sort_array, &$group_opts, $level, $idx, &$prevs) {

    // recurse to find all parent headings
    if ($level > 0) {
        _add_heading($results, $sort_array, $group_opts, $level - 1, $idx, $prevs);
    }
    $group_type = $group_opts['type'][$level];

    $prev = (isset($prevs[$level])) ? $prevs[$level] : '';
    $key = $group_opts['key'][$level];
    $cur = $sort_array[$idx][$key];
    if ($cur != $prev) {
        $prevs[$level] = $cur;

        if ($group_type === MGROUP_HEADING) {
            $date_format = $group_opts['dformat'][$level];
            if ( ! empty($date_format)) {
                // the real date is always the the '__realdate__' column (MGROUP_REALDATE)
                $cur = strftime($date_format, $sort_array[$idx][MGROUP_REALDATE]);
            }
            $results[] = array($level + 1, $cur, '');

        } elseif ($group_type === MGROUP_NAMESPACE) {
            $cur_ns = explode(':', $cur);
            $prev_ns = explode(':', $prev);
            // only show namespaces that are different from the previous heading
            for ($i= 0; $i < count($cur_ns); $i++) {
                if ($cur_ns[$i] != $prev_ns[$i]) {
                    $hl = $level + $i + 1;
                    $results[] = array($hl , $cur_ns[$i], '');
                }
            }
        }
    }
}
?>
commit refs/heads/trunk
mark :104
committer  <syanna> 1272186206 +0000
data 22
initial empty check-in
deleteall

commit refs/heads/trunk
mark :109
committer  <syanna> 1272186704 +0000
data 27
Initial commit of pagequery
from :104
deleteall
M 100644 :2 lang/en/lang.php
M 100644 :3 readme.txt
M 100644 :4 style.css
M 100644 :5 syntax.php

commit refs/heads/trunk
mark :111
committer  <syanna> 1272221624 +0000
data 134
FIX: better edge case checking in column display algorithm, esp. when not grouping
NEW: start column only on heading (cleaner display)
from :109
deleteall
M 100644 :2 lang/en/lang.php
M 100644 :3 readme.txt
M 100644 :4 style.css
M 100644 :7 syntax.php

commit refs/heads/trunk
mark :114
committer  <syanna> 1272469309 +0000
data 45
FIX: better link styling--indent on multiline
from :111
deleteall
M 100644 :2 lang/en/lang.php
M 100644 :3 readme.txt
M 100644 :9 style.css
M 100644 :10 syntax.php

commit refs/heads/trunk
mark :116
committer  <syanna> 1272995771 +0000
data 228
CHG: added 'name', 'header', 'both' args to proper option
CHG: added a ':' in parse_ns_query func. to ensure corrent ns matches
NEW: 'nostart' option added: ignore 'start' pages
NEW: 'fullregex' option added: raw power-user mode
from :114
deleteall
M 100644 :2 lang/en/lang.php
M 100644 :3 readme.txt
M 100644 :9 style.css
M 100644 :12 syntax.php

commit refs/heads/trunk
mark :120
committer  <syanna> 1273074943 +0000
data 181
FIX: limit option now works correctly
FIX: colons in namespaces now display correctly
FIX: mdate and cdate now sort correctly by number
CHG: updated the readme; and code header info
from :116
deleteall
M 100644 :2 lang/en/lang.php
M 100644 :14 readme.txt
M 100644 :15 style.css
M 100644 :16 syntax.php

commit refs/heads/trunk
mark :125
committer  <syanna> 1273400074 +0000
data 136
NEW: added a new 'abstract' option: can now add an abstract snippet to all or some links
CHG: added htmlspecialchars to abstract parsing
from :120
deleteall
M 100644 :20 images/blockquote-icon.png
M 100644 :21 images/blockquote.gif
M 100644 :2 lang/en/lang.php
M 100644 :14 readme.txt
M 100644 :18 style.css
M 100644 :19 syntax.php

commit refs/heads/trunk
mark :129
committer  <syanna> 1273654386 +0000
data 181
  *  CHG: factored out wikilink/abstract creation into separate function (cleaner)
  *  ADD: new 'more...' link at end of snippet abstracts
  *  UPD: readme file--added new commands
from :125
deleteall
M 100644 :20 images/blockquote-icon.png
M 100644 :21 images/blockquote.gif
M 100644 :2 lang/en/lang.php
M 100644 :23 readme.txt
M 100644 :24 style.css
M 100644 :25 syntax.php

commit refs/heads/trunk
mark :131
committer  <syanna> 1273937640 +0000
data 49
FIX: inconsistent abstract results; now corrected
from :129
deleteall
M 100644 :20 images/blockquote-icon.png
M 100644 :21 images/blockquote.gif
M 100644 :2 lang/en/lang.php
M 100644 :23 readme.txt
M 100644 :24 style.css
M 100644 :27 syntax.php

commit refs/heads/trunk
mark :134
committer  <syanna> 1273953685 +0000
data 255
CHG: better column breaks: i.e. Heading...
CHG: refined the CSS; px instead of em for indent (more consistent); better use of bold
NEW: special grouping for namespaces, extra headers for each sub-namespace
FIX: use conf[start] for 'start' namespace header
from :131
deleteall
M 100644 :20 images/blockquote-icon.png
M 100644 :21 images/blockquote.gif
M 100644 :2 lang/en/lang.php
M 100644 :23 readme.txt
M 100644 :29 style.css
M 100644 :30 syntax.php

commit refs/heads/trunk
mark :136
committer  <syanna> 1289641680 +0000
data 202
<h3>papgequery 0.6.3beta</h3>
  *  FIX: dates in words are now correctly handled (complex change!)
  *  CHG: now using plugin.info.txt
  *  LNG: fixed email address, and some spelling errors in comments
from :134
deleteall
M 100644 :20 images/blockquote-icon.png
M 100644 :21 images/blockquote.gif
M 100644 :2 lang/en/lang.php
M 100644 :23 readme.txt
M 100644 :29 style.css
M 100644 :32 syntax.php

commit refs/heads/trunk
mark :138
committer  <syanna> 1294680535 +0000
data 236
  *  FIX: bug when sorting if no dates involved!
  *  CHG: improved the date formatting function
  *  CHG: now allow for up to 6 columns in display (for larger monitors!)
  *  CHG: allow for UTF-8 strings when counting number of letters
from :136
deleteall
M 100644 :20 images/blockquote-icon.png
M 100644 :21 images/blockquote.gif
M 100644 :2 lang/en/lang.php
M 100644 :23 readme.txt
M 100644 :29 style.css
M 100644 :34 syntax.php

commit refs/heads/trunk
mark :140
committer  <syanna> 1296408047 +0000
data 143
<h3>pagequery 0.6.6</h3>
  *  NEW: added a maxns option, to control how many namespace levels should be displayed
  *  CHG: few comment updates
from :138
deleteall
M 100644 :20 images/blockquote-icon.png
M 100644 :21 images/blockquote.gif
M 100644 :2 lang/en/lang.php
M 100644 :23 readme.txt
M 100644 :29 style.css
M 100644 :36 syntax.php

commit refs/heads/trunk
mark :142
committer  <syanna> 1296582443 +0000
data 246
<h3>pagequery 0.6.7</h3>
  *  CHG: improved pagename search: include and exclude namespaces now work correctly
  *  FIX: now use Dokuwiki utf8_substr function instead of mb_string
  *  CHG: code clean-up in render function; easier to follow logic
from :140
deleteall
M 100644 :20 images/blockquote-icon.png
M 100644 :21 images/blockquote.gif
M 100644 :2 lang/en/lang.php
M 100644 :23 readme.txt
M 100644 :29 style.css
M 100644 :38 syntax.php

commit refs/heads/trunk
mark :145
committer  <syanna> 1298738775 +0000
data 185
<h3>pagequery 0.6.8</h3>
  *  FIX: incorrect grouping and sorting by title (1st heading);
  *  CHG: tiny CSS font size changes
  *  CHG: internal code improvements in sort_opts function
from :142
deleteall
M 100644 :20 images/blockquote-icon.png
M 100644 :21 images/blockquote.gif
M 100644 :2 lang/en/lang.php
M 100644 :23 readme.txt
M 100644 :40 style.css
M 100644 :41 syntax.php

commit refs/heads/trunk
mark :148
committer  <syanna> 1298741441 +0000
data 44
  *  NEW: added plugin.info.txt to repositry
from :145
deleteall
M 100644 :20 images/blockquote-icon.png
M 100644 :21 images/blockquote.gif
M 100644 :2 lang/en/lang.php
M 100644 :44 plugin.info.txt
M 100644 :23 readme.txt
M 100644 :40 style.css
M 100644 :41 syntax.php

commit refs/heads/trunk
mark :150
committer  <syanna> 1300021171 +0000
data 278
<h3>pagequery 0.6.9</h3>
  *  FIX: better recognition of ^exclude_namespaces vs ^begin regex syntax (could be improved further one day)
  *  FIX: allow pageonly regex searches to recognise the string beginning (^); previously impossible as whole id was being searched initially.
from :148
deleteall
M 100644 :20 images/blockquote-icon.png
M 100644 :21 images/blockquote.gif
M 100644 :2 lang/en/lang.php
M 100644 :44 plugin.info.txt
M 100644 :23 readme.txt
M 100644 :40 style.css
M 100644 :46 syntax.php

commit refs/heads/new_msort
mark :151
committer  <syanna> 1300021724 +0000
data 35
Create new branch named "new_msort"
from :150
deleteall
M 100644 :20 images/blockquote-icon.png
M 100644 :21 images/blockquote.gif
M 100644 :2 lang/en/lang.php
M 100644 :44 plugin.info.txt
M 100644 :23 readme.txt
M 100644 :40 style.css
M 100644 :46 syntax.php

commit refs/heads/trunk
mark :156
committer  <syanna> 1300533485 +0000
data 1646
<h2>pagequery 0.7  Major release!</h2>
<h4>CSS</h4>
  *  CHG: more compact line layout; removed underlined hyperlink style
  *  CHG: added quiet background colour to A-Z | Year headers
  *  CHG: many subtle CSS tweaks to clear up layout; more information on one page
<h4>Sorting</h4>
  *  NEW: complete rewrite of multi-column sorting routine.  Can now handle caseless and natural sorting.  Based on idea in PHP array_multisort manual page.  Just as fast, and much more flexible.  Made for cleaner code.
  *  NEW: all sorting now done by included functions: 'msort', and 'mgroup' (could be used standalone)
  *  NEW: new option 'case': honour case when sorting a..z then A..Z
  *  NEW: new option 'natsort': use PHP's natural case sorting functions, as humans expect.
<h4>Other</h4>
  *  CHG: 'abstract' option is now 'snippet' (old syntax still works, remove later)
  *  FIX: missing 'break' statement on option switch, potential fall-through bug.
  *  CHG: no separate columns fo rdates/names, etc... all sorting/grouping is done with same.
  *  CHG: display 'name' is calculated once only prior to sorting, now sorting is based on what user sees.
  *  CHG: indenting CSS is added dynamically, making the layout more consistent.
  *  CHG: rewrote the link rendering function to use the existing display name ((now one of sort columns), faster.
  *  NEW: function: _html_wikilink_snippet().  Factored out into separate function.
  *  CHG: factored out _date_format_words() from _date_format().  Cleaner and more obvious code.
  *  CHG: removed all class variables, everything passed via function args; less confusing and encapsulated functions.
from :150
deleteall
M 100644 :20 images/blockquote-icon.png
M 100644 :21 images/blockquote.gif
M 100644 :52 inc/msort.php
M 100644 :2 lang/en/lang.php
M 100644 :44 plugin.info.txt
M 100644 :23 readme.txt
M 100644 :50 style.css
M 100644 :51 syntax.php

commit refs/heads/trunk
mark :164
committer  <syanna> 1300554374 +0000
data 236
  *  CHG: revised comments for accuracy
  *  NEW: added "jump to top" links at bottom of columns, and on section continuation symbol
  *  LNG: updated the plugin.info.txt file
  *  LNG: new lang strings for "jump" links and tooltips
  *
from :156
deleteall
M 100644 :20 images/blockquote-icon.png
M 100644 :21 images/blockquote.gif
M 100644 :60 inc/msort.php
M 100644 :56 lang/en/lang.php
M 100644 :59 plugin.info.txt
M 100644 :23 readme.txt
M 100644 :57 style.css
M 100644 :58 syntax.php

commit refs/heads/trunk
mark :168
committer  <syanna> 1300625183 +0000
data 120
  *  CHG: new border options added: inside, outside, both and none.  Allows only internal borders (i.e. column dividers)
from :164
deleteall
M 100644 :20 images/blockquote-icon.png
M 100644 :21 images/blockquote.gif
M 100644 :60 inc/msort.php
M 100644 :56 lang/en/lang.php
M 100644 :59 plugin.info.txt
M 100644 :23 readme.txt
M 100644 :63 style.css
M 100644 :64 syntax.php

commit refs/heads/trunk
mark :172
committer  <syanna> 1300810567 +0000
data 194
  *  CHG: improved the "jump to top" feature; works on every simple 1-column list correctly now
  *  FIX: options not being parsed correctly
  *  FIX: "more..." link styling was incorrect--fixed
from :168
deleteall
M 100644 :20 images/blockquote-icon.png
M 100644 :21 images/blockquote.gif
M 100644 :60 inc/msort.php
M 100644 :56 lang/en/lang.php
M 100644 :68 plugin.info.txt
M 100644 :23 readme.txt
M 100644 :66 style.css
M 100644 :67 syntax.php

commit refs/heads/trunk
mark :176
committer  <syanna> 1300815230 +0000
data 126
  *  FIX: fixed a whopping great big bug when list not grouped!  Needed to reformat result list to include name and level too.
from :172
deleteall
M 100644 :20 images/blockquote-icon.png
M 100644 :21 images/blockquote.gif
M 100644 :60 inc/msort.php
M 100644 :56 lang/en/lang.php
M 100644 :68 plugin.info.txt
M 100644 :23 readme.txt
M 100644 :71 style.css
M 100644 :72 syntax.php

commit refs/heads/trunk
mark :178
committer  <syanna> 1301164079 +0000
data 37
  *  CHG: clean up of header comments
from :176
deleteall
M 100644 :20 images/blockquote-icon.png
M 100644 :21 images/blockquote.gif
M 100644 :74 inc/msort.php
M 100644 :56 lang/en/lang.php
M 100644 :68 plugin.info.txt
M 100644 :23 readme.txt
M 100644 :71 style.css
M 100644 :72 syntax.php

commit refs/heads/trunk
mark :183
committer  <syanna> 1301647108 +0000
data 817
<h4>pagequery 0.7.1</h4>
  *  CHG: refactored the mgroup function: separated the "by mixed args" option
  *  CHG: allowed for user-defined keys to be returned by mgroup function
  *  CSS: better colours/styling for "no results" message
  *  FIX: better handling of "*" search queries: always converted to .* for page name queries
  *  FIX: added error override to search function, to ignore incorrect regex patterns
  *  CHG: refactored render function into 1) _render_no_list and _render_list, plus _create_index.  Easier to follow logic now
  *  CHG: better allowance for column heights (result still affected line wraps on page links!); calculate a more realistic column height based on estimated ratios for headers
  *  FIX: maxns in page_lookup function was incorrect ($this->maxns...)
  *  REL: updated to 0.7.1
from :178
deleteall
M 100644 :20 images/blockquote-icon.png
M 100644 :21 images/blockquote.gif
M 100644 :79 inc/msort.php
M 100644 :56 lang/en/lang.php
M 100644 :78 plugin.info.txt
M 100644 :23 readme.txt
M 100644 :76 style.css
M 100644 :77 syntax.php

commit refs/heads/trunk
mark :185
committer  <syanna> 1301647471 +0000
data 55
  *  FIX: changed plugin.info.txt EOL to LF (PHP style)
from :183
deleteall
M 100644 :20 images/blockquote-icon.png
M 100644 :21 images/blockquote.gif
M 100644 :79 inc/msort.php
M 100644 :56 lang/en/lang.php
M 100644 :81 plugin.info.txt
M 100644 :23 readme.txt
M 100644 :76 style.css
M 100644 :77 syntax.php

commit refs/heads/trunk
mark :187
committer  <syanna> 1301650701 +0000
data 84
  *  CHG: refactoring in _render_list function: better variable names; cleaner logic
from :185
deleteall
M 100644 :20 images/blockquote-icon.png
M 100644 :21 images/blockquote.gif
M 100644 :79 inc/msort.php
M 100644 :56 lang/en/lang.php
M 100644 :81 plugin.info.txt
M 100644 :23 readme.txt
M 100644 :76 style.css
M 100644 :83 syntax.php

commit refs/heads/trunk
mark :190
committer  <syanna> 1302456462 +0000
data 181
  *  NEW: underline option for each page link row (subtle, but visible)
  *  NEW: inline snippet option, up to no. of chars limit
  *  NEW: better, rounded corners on outside border
from :187
deleteall
M 100644 :20 images/blockquote-icon.png
M 100644 :21 images/blockquote.gif
M 100644 :79 inc/msort.php
M 100644 :56 lang/en/lang.php
M 100644 :81 plugin.info.txt
M 100644 :23 readme.txt
M 100644 :85 style.css
M 100644 :86 syntax.php

commit refs/heads/trunk
mark :194
committer  <syanna> 1302801750 +0000
data 594
<h3>Faster!</h3>
  *  CHG: profiled the code with xdebug/webgrind and discovered that the metadata retrieval is the slowest factor.  Therefore rewrote code to fetch metadata only once per displayed page.  Saved a second or more on render.
  *  CHG: no table used when only one column; this avoids the TOC pushdown effect.
  *  CHG: rewrote snippet function, clearer and more flexible.  Now offers 3 types: inline, plain and quoted, plus extent (length) options (based on new _shorten function, quite handy for future use)
  *  CHG: renamed _get_options -> _build_sorting_array (more meaningful)
from :190
deleteall
M 100644 :20 images/blockquote-icon.png
M 100644 :21 images/blockquote.gif
M 100644 :79 inc/msort.php
M 100644 :56 lang/en/lang.php
M 100644 :90 plugin.info.txt
M 100644 :23 readme.txt
M 100644 :88 style.css
M 100644 :89 syntax.php

commit refs/heads/trunk
mark :197
committer  <syanna> 1305396916 +0000
data 99
  * NEW: current and relative namespaces now allowed
  * CHG: updated some function comment headers
from :194
deleteall
M 100644 :20 images/blockquote-icon.png
M 100644 :21 images/blockquote.gif
M 100644 :79 inc/msort.php
M 100644 :92 lang/en/lang.php
M 100644 :90 plugin.info.txt
M 100644 :23 readme.txt
M 100644 :88 style.css
M 100644 :93 syntax.php

commit refs/heads/trunk
mark :199
committer  <syanna> 1306063101 +0000
data 43
  *  NEW: relative namespaces now supported
from :197
deleteall
M 100644 :20 images/blockquote-icon.png
M 100644 :21 images/blockquote.gif
M 100644 :79 inc/msort.php
M 100644 :92 lang/en/lang.php
M 100644 :90 plugin.info.txt
M 100644 :23 readme.txt
M 100644 :88 style.css
M 100644 :95 syntax.php

commit refs/heads/trunk
mark :201
committer  <syanna> 1306063151 +0000
data 34
  *  CHG: fixed wrong line endings
from :199
deleteall
M 100644 :20 images/blockquote-icon.png
M 100644 :21 images/blockquote.gif
M 100644 :79 inc/msort.php
M 100644 :92 lang/en/lang.php
M 100644 :90 plugin.info.txt
M 100644 :23 readme.txt
M 100644 :88 style.css
M 100644 :97 syntax.php

commit refs/heads/trunk
mark :205
committer  <syanna> 1310663213 +0000
data 327
<h3>pagequery 0.7.4</h3>
  *  NEW: filter option: by any meta-data column using regex
  *  CHG: refactored options into a single array (clearer, cleaner,and easier to extend); much simpler metadata column handling!
  *  CHG: better error messages regexes and empty lists
  *  NEW: added contributor meta key (mainly for search)
from :201
deleteall
M 100644 :20 images/blockquote-icon.png
M 100644 :21 images/blockquote.gif
M 100644 :101 inc/msort.php
M 100644 :99 lang/en/lang.php
M 100644 :90 plugin.info.txt
M 100644 :23 readme.txt
M 100644 :88 style.css
M 100644 :100 syntax.php

tag pagequery0.7alpha
from :156
tagger <tagger> 1300533626 +0000
data 0
tag pagequery0.7alpha
from :164
tagger <tagger> 1300555950 +0000
data 0
